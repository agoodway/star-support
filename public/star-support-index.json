{
  "version": "2.0",
  "generated": "2025-08-03T13:50:31.730Z",
  "languages": [
    "en"
  ],
  "count": 378,
  "metadata": {
    "urlStrategy": "auto",
    "baseUrl": null,
    "summaryStrategy": "standard"
  },
  "documents": [
    {
      "id": "guides/integrations-guide/alpinejs",
      "language": "en",
      "filePath": "src/content/docs/en/guides/integrations-guide/alpinejs.mdx",
      "title": "@astrojs/alpinejs",
      "summary": "Astro components are extended with Alpine.js support through the @astrojs/alpinejs framework integration, enabling the use of Alpine.js anywhere on the page. Key features include: * Installation via `astro add` command or manual installation using npm, pnpm, or yarn * Integration with Astro's `astro.config.*` file using the `integrations` property * Support for Alpine.js methods and APIs, such as `x-data`, `x-init`, and `x-on` Implementation details include installing the `@astrojs/alpinejs` package and associated peer dependencies, and applying the integration to the `astro.config.*` file. Use cases include building interactive web applications with Astro and Alpine.js.",
      "url": "/en/guides/integrations-guide/alpinejs/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "renderer",
        "integration",
        "@astrojs/alpinejs"
      ],
      "type": "integration"
    },
    {
      "id": "guides/integrations-guide/cloudflare",
      "language": "en",
      "filePath": "src/content/docs/en/guides/integrations-guide/cloudflare.mdx",
      "title": "@astrojs/cloudflare",
      "summary": "**@astrojs/cloudflare Adapter** The @astrojs/cloudflare adapter enables deployment of Astro projects to Cloudflare, supporting on-demand rendered routes, server islands, actions, and sessions. This adapter integrates with Cloudflare's Developer Platform, providing access to resources such as storage and AI, deployed to a global edge network. The adapter can be installed using the `astro add` command or manually, and enables server-rendering and on-demand rendering capabilities.",
      "url": "/en/guides/integrations-guide/cloudflare/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "adapter",
        "integration",
        "@astrojs/cloudflare"
      ],
      "type": "integration"
    },
    {
      "id": "guides/integrations-guide/db",
      "language": "en",
      "filePath": "src/content/docs/en/guides/integrations-guide/db.mdx",
      "title": "@astrojs/db",
      "summary": "Astro DB is a fully-managed SQL database designed for the Astro ecosystem, enabling local development and deployment to libSQL-compatible databases. Key features include type-safe querying and modeling of content as a relational database, with support for Astro's `astro add` command for automated setup and manual installation via npm or yarn. The integration is configured through `astro.config.mjs` and `db/config.ts` files, allowing for customization of database settings.",
      "url": "/en/guides/integrations-guide/db/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "other",
        "integration",
        "@astrojs/db"
      ],
      "type": "integration"
    },
    {
      "id": "guides/integrations-guide/markdoc",
      "language": "en",
      "filePath": "src/content/docs/en/guides/integrations-guide/markdoc.mdx",
      "title": "@astrojs/markdoc",
      "summary": "Astro components are enhanced with Markdoc functionality to create components, pages, and content collection entries. Key features include Astro.props, getStaticPaths, and integration with Astro components such as FileTree, Steps, and ReadMore. This integration enables the usage of Markdoc to bring existing content authored in Markdoc to an Astro project using content collections.",
      "url": "/en/guides/integrations-guide/markdoc/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "other",
        "integration",
        "@astrojs/markdoc"
      ],
      "type": "integration"
    },
    {
      "id": "guides/integrations-guide/mdx",
      "language": "en",
      "filePath": "src/content/docs/en/guides/integrations-guide/mdx.mdx",
      "title": "@astrojs/mdx",
      "summary": "**@astrojs/mdx Integration** Astro components are enabled for MDX usage, allowing creation of pages as `.mdx` files, with support for variables, JSX expressions, and components within Markdown content. Key features include: * `astro add mdx` command for automated setup * `@astrojs/mdx` package installation * `integrations` property in `astro.config.*` file for integration application * Support for editor integration in VS Code through the official MDX extension Implementation details include: * Using `getStaticPaths` and `Astro.props` to leverage MDX features * Integrating with existing MDX content authored in Astro projects * Manual installation and setup options for the `@astrojs/mdx` package",
      "url": "/en/guides/integrations-guide/mdx/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "other",
        "integration",
        "@astrojs/mdx"
      ],
      "type": "integration"
    },
    {
      "id": "guides/integrations-guide/netlify",
      "language": "en",
      "filePath": "src/content/docs/en/guides/integrations-guide/netlify.mdx",
      "title": "@astrojs/netlify",
      "summary": "**@astrojs/netlify Adapter** The @astrojs/netlify adapter enables Astro to deploy on-demand rendered routes and features to Netlify, including server islands, actions, and sessions. It enhances the Astro build process to prepare projects for deployment through Netlify, supporting features like Netlify Image CDN. The adapter can be installed using the `astro add` command or manually, and enables on-demand rendering per page or server-rendering all pages by default.",
      "url": "/en/guides/integrations-guide/netlify/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "adapter",
        "integration",
        "@astrojs/netlify"
      ],
      "type": "integration"
    },
    {
      "id": "guides/integrations-guide/node",
      "language": "en",
      "filePath": "src/content/docs/en/guides/integrations-guide/node.mdx",
      "title": "@astrojs/node",
      "summary": "Astro components are deployable to Node targets using the @astrojs/node adapter, enabling on-demand rendered routes and features, including server islands, actions, and sessions. Key features include: * getStaticPaths for server-side rendering * Astro.props for accessing page props * Support for server islands, actions, and sessions * Integration with Express and other http servers Implementation details include using the `astro add` command to automate setup, or manually installing the adapter and configuring build output to `output: 'server'` for server-rendering all pages by default.",
      "url": "/en/guides/integrations-guide/node/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "adapter",
        "integration",
        "@astrojs/node"
      ],
      "type": "integration"
    },
    {
      "id": "guides/integrations-guide/partytown",
      "language": "en",
      "filePath": "src/content/docs/en/guides/integrations-guide/partytown.mdx",
      "title": "@astrojs/partytown",
      "summary": "**@astrojs/partytown Integration** Astro components are enabled with the @astrojs/partytown integration, which utilizes Partytown to lazy-load resource-intensive scripts into a web worker, offloading them from the main thread. Key features include: * Installation via `astro add partytown` or manual installation with `npm install @astrojs/partytown`/`pnpm add @astrojs/partytown`/`yarn add @astrojs/partytown` * Configuration through `astro.config.*` file using the `integrations` property * Utilization of Partytown's web worker to offload scripts from the main thread Implementation details involve integrating Partytown into Astro projects to improve performance and prevent third-party scripts from slowing down the site.",
      "url": "/en/guides/integrations-guide/partytown/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "other",
        "integration",
        "@astrojs/partytown"
      ],
      "type": "integration"
    },
    {
      "id": "guides/integrations-guide/preact",
      "language": "en",
      "filePath": "src/content/docs/en/guides/integrations-guide/preact.mdx",
      "title": "@astrojs/preact",
      "summary": "Astro components are extended with Preact support through the @astrojs/preact framework integration, enabling rendering and client-side hydration for Preact components. Key features include Astro.props, getStaticPaths, and compatibility with React components via the compat configuration option. Implementation details involve installing the @astrojs/preact package using astro add or manual npm/yarn installation, followed by setup and configuration. Use cases include building interactive UI components for web applications and leveraging Preact's smaller package size and React compatibility.",
      "url": "/en/guides/integrations-guide/preact/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "renderer",
        "integration",
        "@astrojs/preact"
      ],
      "type": "integration"
    },
    {
      "id": "guides/integrations-guide/prefetch",
      "language": "en",
      "filePath": "src/content/docs/en/guides/integrations-guide/prefetch.mdx",
      "title": "@astrojs/prefetch",
      "summary": "Astro components are enabled with prefetch integration for optimized page loading. The `@astrojs/prefetch` integration provides features such as `prefetch` API, `prefetch` method, and Astro.props for controlling prefetch behavior. It allows developers to implement prefetching for specific routes and components, improving page loading performance. Implementation details and use cases include using the `prefetch` API to prefetch data for routes, and leveraging Astro.props to configure prefetch settings. This integration is suitable for optimizing page loading in Astro applications, particularly in scenarios requiring dynamic data loading.",
      "url": "/en/guides/integrations-guide/prefetch/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "@astrojs/prefetch"
      ],
      "type": "guide"
    },
    {
      "id": "guides/integrations-guide/react",
      "language": "en",
      "filePath": "src/content/docs/en/guides/integrations-guide/react.mdx",
      "title": "@astrojs/react",
      "summary": "Astro components are extended with React support through the @astrojs/react framework integration, enabling rendering and client-side hydration for React components. Key features include Astro.add() command for automated setup, support for npm, pnpm, and yarn package managers, and integration with astro.config.* files using the integrations property.",
      "url": "/en/guides/integrations-guide/react/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "renderer",
        "integration",
        "@astrojs/react"
      ],
      "type": "integration"
    },
    {
      "id": "guides/integrations-guide/sitemap",
      "language": "en",
      "filePath": "src/content/docs/en/guides/integrations-guide/sitemap.mdx",
      "title": "@astrojs/sitemap",
      "summary": "**Astro Sitemap Integration** The Astro Sitemap integration generates a sitemap based on statically-generated routes in Astro projects, including dynamic routes like `[...slug]` or `src/pages/[lang]/[version]/info.astro` generated by `getStaticPaths()`. This integration is recommended for large multi-page sites to ensure search engine friendliness. It uses the `@astrojs/sitemap` package, which can be installed using `astro add sitemap` or manually via npm/pnpm/yarn.",
      "url": "/en/guides/integrations-guide/sitemap/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "other",
        "integration",
        "@astrojs/sitemap"
      ],
      "type": "integration"
    },
    {
      "id": "guides/integrations-guide/solid-js",
      "language": "en",
      "filePath": "src/content/docs/en/guides/integrations-guide/solid-js.mdx",
      "title": "@astrojs/solid-js",
      "summary": "Astro components are extended with SolidJS support through the @astrojs/solid-js framework integration, enabling rendering and client-side hydration for SolidJS components. Key features include: * `astro add` command for automated setup * `integrations` property in `astro.config.*` file for manual integration * Support for SolidJS components, including rendering and client-side hydration * Installation via npm, pnpm, or yarn package managers Implementation details involve installing the `@astrojs/solid-js` package and associated peer dependencies, such as SolidJS, and applying the integration to the `astro.config.*` file.",
      "url": "/en/guides/integrations-guide/solid-js/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "renderer",
        "integration",
        "@astrojs/solid-js"
      ],
      "type": "integration"
    },
    {
      "id": "guides/integrations-guide/svelte",
      "language": "en",
      "filePath": "src/content/docs/en/guides/integrations-guide/svelte.mdx",
      "title": "@astrojs/svelte",
      "summary": "Astro components are extended with Svelte 5 support through the @astrojs/svelte framework integration, enabling rendering and client-side hydration for Svelte components. Key features include Astro.props, getStaticPaths, and integration with Astro's build and rendering pipeline. This integration is installed via the `astro add` command or manually with npm, yarn, or pnpm, requiring Svelte and TypeScript peer dependencies.",
      "url": "/en/guides/integrations-guide/svelte/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "renderer",
        "integration",
        "@astrojs/svelte"
      ],
      "type": "integration"
    },
    {
      "id": "guides/integrations-guide/tailwind",
      "language": "en",
      "filePath": "src/content/docs/en/guides/integrations-guide/tailwind.mdx",
      "title": "@astrojs/tailwind",
      "summary": "Astro components are integrated with Tailwind CSS for styling and layout management through the @astrojs/tailwind package, utilizing features such as `Astro.props` and `getStaticPaths` for dynamic styling and server-side rendering. The integration provides access to Tailwind's utility-first CSS framework, enabling developers to write concise and modular CSS code. Implementation details and use cases are outlined in the styling guide for Tailwind.",
      "url": "/en/guides/integrations-guide/tailwind/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "@astrojs/tailwind"
      ],
      "type": "guide"
    },
    {
      "id": "guides/integrations-guide/vercel",
      "language": "en",
      "filePath": "src/content/docs/en/guides/integrations-guide/vercel.mdx",
      "title": "@astrojs/vercel",
      "summary": "**@astrojs/vercel Adapter** The @astrojs/vercel adapter enables deployment of Astro projects to Vercel, supporting on-demand rendered routes, server islands, actions, and sessions. It integrates with Vercel services such as Web Analytics and Image Optimization. The adapter is installed using the `astro add` command, which automates setup and configures the `astro.config.mjs` file.",
      "url": "/en/guides/integrations-guide/vercel/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "adapter",
        "integration",
        "@astrojs/vercel"
      ],
      "type": "integration"
    },
    {
      "id": "guides/integrations-guide/vue",
      "language": "en",
      "filePath": "src/content/docs/en/guides/integrations-guide/vue.mdx",
      "title": "@astrojs/vue",
      "summary": "Astro components are extended with Vue 3 support through the @astrojs/vue framework integration, enabling rendering and client-side hydration for Vue components. Key features include Astro.add, astro.config.mjs integrations, and support for Vue 3 components, with implementation details involving installation via astro add or manual npm/yarn installation, and configuration through the astro.config.mjs file.",
      "url": "/en/guides/integrations-guide/vue/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "renderer",
        "integration",
        "@astrojs/vue"
      ],
      "type": "integration"
    },
    {
      "id": "guides/integrations-guide/deno",
      "language": "en",
      "filePath": "src/content/docs/en/guides/integrations-guide/deno.mdx",
      "title": "@deno/astro-adapter",
      "summary": "The Deno Astro adapter enables Astro to deploy SSR sites to Deno targets, including Deno Deploy. Key features include support for Deno Deploy and integration with Deno's SSR capabilities. The adapter is maintained by Deno and can be used with Astro projects, requiring migration to the new Deno version or addition of another adapter for continued SSR functionality.",
      "url": "/en/guides/integrations-guide/deno/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "@deno/astro-adapter"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/redirect-with-no-location",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/redirect-with-no-location.mdx",
      "title": "A redirect must be given a location with the Location header.",
      "summary": "Astro components require a redirect to be given a location with the `Location` header, utilizing the `Astro.redirect` API, which is a critical implementation detail for successful redirects in Astro applications. The `Location` header is a required parameter for the `Astro.redirect` method, ensuring seamless navigation between routes. This technical requirement is essential for Astro developers to implement redirects effectively.",
      "url": "/en/reference/errors/redirect-with-no-location/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "redirect",
        "must",
        "given",
        "location"
      ],
      "type": "guide"
    },
    {
      "id": "tutorial/0-introduction/1",
      "language": "en",
      "filePath": "src/content/docs/en/tutorial/0-introduction/1.mdx",
      "title": "About this Tutorial",
      "summary": "**Astro Tutorial Overview** Astro components are used to create interactive web applications, utilizing HTML, Markdown, CSS, and JavaScript. Key features include Astro.props, Astro components (e.g., Checklist, Box), and GitHub integration for publishing projects. Implementation details involve using Astro's development tools, online accounts, and deployment to Netlify. Use cases include creating new Astro projects, storing them on GitHub, and deploying them to Netlify.",
      "url": "/en/tutorial/0-introduction/1/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "0 introduction",
        "about",
        "this"
      ],
      "type": "tutorial"
    },
    {
      "id": "reference/errors/actions-returned-invalid-data-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/actions-returned-invalid-data-error.mdx",
      "title": "Action handler returned invalid data.",
      "summary": "**Actions Returned Invalid Data Error** Astro actions handler returned invalid data, violating the requirement to return serializable data types such as objects, arrays, strings, and numbers. The error occurs when the handler returns a Response object, which is not a supported data type. This issue is addressed in the Astro actions handler reference.",
      "url": "/en/reference/errors/actions-returned-invalid-data-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "action",
        "handler",
        "returned",
        "invalid"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/action-not-found-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/action-not-found-error.mdx",
      "title": "Action not found.",
      "summary": "**ActionNotFoundError**: The server received a request for an action named `ACTION_NAME` but could not find a match. This error occurs when the server fails to locate an action with the specified name, typically due to a mismatch between the action name and its updated reference in `actions/index` or calling code. The error is triggered by the `ActionNotFoundError` exception, which can be resolved by verifying the action name consistency across the application.",
      "url": "/en/reference/errors/action-not-found-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "action",
        "found."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/action-called-from-server-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/action-called-from-server-error.mdx",
      "title": "Action unexpected called from the server.",
      "summary": "**ActionCalledFromServerError**: A wrapper component that must be used to call actions from server code, preventing unexpected action calls from server pages or endpoints without using `Astro.callAction()`. This component is critical for ensuring proper action handling in server-side rendering scenarios. It is typically used in conjunction with `Astro.callAction()` to manage action calls from server code.",
      "url": "/en/reference/errors/action-called-from-server-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "action",
        "unexpected",
        "called",
        "from"
      ],
      "type": "guide"
    },
    {
      "id": "guides/actions",
      "language": "en",
      "filePath": "src/content/docs/en/guides/actions.mdx",
      "title": "Actions",
      "summary": "**Astro Actions are a type-safe server function system that enables seamless communication between client and server code, automating data fetching, JSON parsing, and input validation using Zod validation.** **Key Features:** * Define backend functions with `defineAction` from `astro:actions` * Use `astro:actions` module to call actions client-side * Actions return an object with `data` or `error` properties * Automatic JSON parsing and input validation using Zod validation * Standardized backend errors with `ActionError` object **Implementation Details:** * Define actions in `server` object exported from `src/actions/index.ts` * Use `defineAction` to create type-safe functions * Call actions client-side within UI framework components, form POST requests, or script tags in Astro components **Use Cases:** * Reduce boilerplate code for data fetching and validation * Standardize backend errors and improve error handling * Enable seamless communication between client and server code",
      "url": "/en/guides/actions/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "actions"
      ],
      "type": "guide"
    },
    {
      "id": "reference/modules/astro-actions",
      "language": "en",
      "filePath": "src/content/docs/en/reference/modules/astro-actions.mdx",
      "title": "Actions API Reference",
      "summary": "**Actions API Reference** Actions help you build a type-safe backend you can call from client code and HTML forms. The `astro:actions` module exposes utilities to define and call actions, including `defineAction()`, `isInputError()`, `isActionError()`, and `ActionError`. **Key Features and APIs** * `defineAction()`: defines new actions from the `src/actions/index.ts` file, accepting a `handler()` function and an optional `input` property for input validation. * `handler()`: a required function containing server logic to run when the action is called, receiving user input and context as arguments. * `input` validator: an optional property to validate input parameters at runtime using a schema from `astro:schema`. * `isInputError()`, `isActionError()`, and `ActionError`: utilities for error handling and validation. **Implementation Details and Use Cases** * Define actions in `src/actions/index.ts` using `defineAction()`. * Use `handler()` to implement server logic, receiving user input and context as arguments. * Validate input parameters using an `input` validator schema from `astro:schema`. * Handle errors using `isInputError()`, `isActionError()`, and `ActionError`.",
      "url": "/en/reference/modules/astro-actions/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "modules",
        "actions"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/actions-without-server-output-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/actions-without-server-output-error.mdx",
      "title": "Actions must be used with server output.",
      "summary": "**Actions must be used with server output.** Astro components require a server output to create callable backend functions, which can be achieved by adding an adapter to the Astro config and configuring routes for on-demand rendering using the `getStaticPaths` method and `Astro.props` API. This ensures that backend functions can be executed on a server, enabling features like server-side rendering and API routes. Implementation details involve configuring the Astro adapter and using the `onDemandRendering` option in the Astro config.",
      "url": "/en/reference/errors/actions-without-server-output-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "actions",
        "must",
        "used",
        "with"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/adapter-support-output-mismatch",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/adapter-support-output-mismatch.mdx",
      "title": "Adapter does not support server output.",
      "summary": "**Adapter does not support server output.** The `ADAPTER_NAME` adapter is configured to output a static website, but the project contains server-rendered pages. This mismatch is resolved by installing and configuring the appropriate server adapter for final deployment. The adapter's entrypoint for server-side rendering varies, e.g., `@astrojs/vercel/serverless` for Vercel.",
      "url": "/en/reference/errors/adapter-support-output-mismatch/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "adapter",
        "does",
        "support",
        "server"
      ],
      "type": "guide"
    },
    {
      "id": "recipes/rss",
      "language": "en",
      "filePath": "src/content/docs/en/recipes/rss.mdx",
      "title": "Add an RSS feed",
      "summary": "**Astro RSS Feed Generation** Astro supports fast, automatic RSS feed generation for blogs and other content websites using the `@astrojs/rss` package. This package provides helpers for generating RSS feeds using API endpoints, unlocking both static builds and on-demand generation when using an SSR adapter. **Key Features and APIs** * `rss()` helper from `@astrojs/rss` package * `GET` method for exporting RSS feed function * `title`, `site`, and other parameters for customizing RSS feed output * Integration with Astro's API endpoints and SSR adapters **Implementation Details and Use Cases** * Install `@astrojs/rss` using npm, pnpm, or yarn * Create a `.xml.js` file in `src/pages/` to define RSS feed output URL * Import `rss()` helper and export a function that returns it with specified parameters",
      "url": "/en/recipes/rss/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "feed"
      ],
      "type": "recipe"
    },
    {
      "id": "tutorial/5-astro-api/4",
      "language": "en",
      "filePath": "src/content/docs/en/tutorial/5-astro-api/4.mdx",
      "title": "Add an RSS feed",
      "summary": "**Astro components are used to add an RSS feed to a website.** **Key features and APIs include:** * Installation of the `@astrojs/rss` package using npm, pnpm, or yarn * Generation of an RSS feed document in XML format * Use of the `rss.xml.js` file to create the feed document * Integration with Astro's development server for automatic feed updates **Implementation details and use cases include:** * Creating a new file `rss.xml.js` in the `src/pages/` directory * Using the `@astrojs/rss` package to generate the RSS feed document * Restarting the Astro development server after installation to begin working on the RSS feed",
      "url": "/en/tutorial/5-astro-api/4/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "5 astro api",
        "feed"
      ],
      "type": "tutorial"
    },
    {
      "id": "tutorial/2-pages/3",
      "language": "en",
      "filePath": "src/content/docs/en/tutorial/2-pages/3.mdx",
      "title": "Add dynamic content about you",
      "summary": "**Astro components are used to add dynamic content to HTML files, enabling conditional rendering and variable usage.** **Key features include:** * Conditional rendering using Astro components (e.g., `PreCheck`) * Variable definition and usage in frontmatter script (e.g., `const pageTitle = \"About Me\";`) * Dynamic HTML element replacement using variables (e.g., `{pageTitle}`) * Integration with Astro's Starlight components (e.g., `Steps`) **Implementation details and use cases:** * Astro components can be used to create interactive and dynamic content on multi-page websites. * Variables can be defined in frontmatter script and used throughout the HTML file. * Conditional rendering enables the display of specific content based on user input or other conditions.",
      "url": "/en/tutorial/2-pages/3/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "2 pages",
        "dynamic",
        "about"
      ],
      "type": "tutorial"
    },
    {
      "id": "recipes/i18n",
      "language": "en",
      "filePath": "src/content/docs/en/recipes/i18n.mdx",
      "title": "Add i18n features",
      "summary": "Astro components are designed to support internationalization (i18n) through dynamic routing and content collections, enabling the creation of multilingual websites. Key features include: * Dynamic routing for serving content in different languages * Content collections for managing language-specific content * Helper functions for assisting in serving an international audience * Support for hiding the default language in the URL Implementation details involve setting up language-specific directories and pages, using meta refresh redirects, and leveraging Astro's built-in i18n routing features.",
      "url": "/en/recipes/i18n/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "i18n",
        "features"
      ],
      "type": "recipe"
    },
    {
      "id": "recipes/external-links",
      "language": "en",
      "filePath": "src/content/docs/en/recipes/external-links.mdx",
      "title": "Add icons to external links",
      "summary": "Astro components are used to add icons to external links in Markdown files by installing a rehype plugin. Specific features include installing the `rehype-external-links` plugin, importing it into `astro.config.mjs`, and passing it to the `rehypePlugins` array with an options object that includes a content property. Implementation details involve setting the `type` property to either `text` or `raw` to add plain text or HTML to the end of the link, respectively. Use cases include adding icons to external links in Markdown files to indicate that visitors are leaving the site.",
      "url": "/en/recipes/external-links/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "icons",
        "external",
        "links"
      ],
      "type": "recipe"
    },
    {
      "id": "guides/integrations-guide/index",
      "language": "en",
      "filePath": "src/content/docs/en/guides/integrations-guide/index.mdx",
      "title": "Add Integrations",
      "summary": "**Astro integrations** add new functionality and behaviors for your project with only a few lines of code, unlocking features like React, Vue, Svelte, and Solid UI frameworks, on-demand rendering, and tool integrations like MDX and Partytown. Integrations can be browsed or searched in the Astro integrations directory, and can be set up automatically using the `astro add` command or installed manually. Key features include renderer support, SSR adapters, and custom code hooks into the build process, dev server, and more.",
      "url": "/en/guides/integrations-guide/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "integrations"
      ],
      "type": "guide"
    },
    {
      "id": "recipes/modified-time",
      "language": "en",
      "filePath": "src/content/docs/en/recipes/modified-time.mdx",
      "title": "Add last modified time",
      "summary": "**Astro components are used to build a remark plugin that adds the last modified time to Markdown and MDX files.** **Key features and APIs include:** * `execSync` to run Git commands and retrieve the timestamp of the latest commit * `remarkModifiedTime` plugin function that adds the last modified time to the frontmatter of files * `Day.js` library for modifying and formatting times * `statSync` alternative for using file system modified time (optional) **Implementation details and use cases:** * Install `Day.js` using npm, pnpm, or yarn * Create a remark plugin using `execSync` to run a Git command and retrieve the timestamp * Add the last modified time to the frontmatter of Markdown and MDX files * Use the `lastModified` property to display the modified time in pages",
      "url": "/en/recipes/modified-time/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "last",
        "modified",
        "time"
      ],
      "type": "recipe"
    },
    {
      "id": "recipes/reading-time",
      "language": "en",
      "filePath": "src/content/docs/en/recipes/reading-time.mdx",
      "title": "Add reading time",
      "summary": "**Astro components are used to create a remark plugin that adds a reading time property to the frontmatter of Markdown or MDX files.** **Features and APIs:** * `remarkReadingTime` plugin function * `getReadingTime` function from `reading-time` package * `toString` function from `mdast-util-to-string` package * `data.astro.frontmatter.minutesRead` property **Implementation details and use cases:** * Install `reading-time` and `mdast-util-to-string` packages * Create a remark plugin using `remarkReadingTime` function * Calculate reading time using `getReadingTime` function * Add reading time property to frontmatter using `data.astro.frontmatter.minutesRead` property * Use in Astro project by adding plugin to `astro.config.mjs` file",
      "url": "/en/recipes/reading-time/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "reading",
        "time"
      ],
      "type": "recipe"
    },
    {
      "id": "tutorial/2-pages/5",
      "language": "en",
      "filePath": "src/content/docs/en/tutorial/2-pages/5.mdx",
      "title": "Add site-wide styling",
      "summary": "**Astro components are used to add site-wide styling by importing a global stylesheet and applying styles globally.** **Key features and APIs include:** * Importing a global stylesheet (`global.css`) into each page using the `import` statement * Defining global styles using CSS selectors (e.g., `html`, `body`, `*`) * Using the `` tag to apply scoped styles * Utilizing Astro's built-in components (e.g., `Steps`, `PreCheck`) to guide the implementation process **Implementation details and use cases:** * Creating a new file at `src/styles/global.css` to define global styles * Copying and pasting CSS code into the `global.css` file to apply site-wide styling * Importing the `global.css` file into each page using the `import` statement in the frontmatter * Using the `global.css` file to control some styles site-wide and apply specific styles exactly where needed.",
      "url": "/en/tutorial/2-pages/5/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "2 pages",
        "site-wide",
        "styling"
      ],
      "type": "tutorial"
    },
    {
      "id": "reference/errors/action-query-string-invalid-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/action-query-string-invalid-error.mdx",
      "title": "An invalid Action query string was passed by a form.",
      "summary": "**ActionQueryStringInvalidError**: The server received the query string `?_astroAction=ACTION_NAME`, but could not find an action with that name. This error occurs when the server receives an invalid action query string, typically due to a mismatch between the action name in the URL and the actual action function name. To resolve this, use the action function's `.queryString` property to retrieve the form `action` URL.",
      "url": "/en/reference/errors/action-query-string-invalid-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "invalid",
        "action",
        "query",
        "string"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/actions-used-with-for-get-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/actions-used-with-for-get-error.mdx",
      "title": "An invalid Action query string was passed by a form.",
      "summary": "**Action Query String Validation** Astro components validate action query strings to prevent invalid requests. Specifically, Astro checks for GET requests on forms that require POST requests, typically due to missing `method=\"POST\"` attributes. This is achieved through the `ActionsUsedWithForGetError` mechanism, which flags deprecated actions since version 4.13.2.",
      "url": "/en/reference/errors/actions-used-with-for-get-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "invalid",
        "action",
        "query",
        "string"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/unknown-filesystem-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/unknown-filesystem-error.mdx",
      "title": "An unknown error occurred while reading or writing files to disk.",
      "summary": "**Error Handling in Astro Components** Astro components are designed to handle file system errors, including unknown errors while reading or writing files to disk. Key features include error detection through file system operations, with specific APIs such as `fs` module usage and error handling through `try-catch` blocks. Implementation details involve checking for missing permissions and non-existent files, with use cases including file uploads, downloads, and caching.",
      "url": "/en/reference/errors/unknown-filesystem-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "unknown",
        "error",
        "occurred",
        "while"
      ],
      "type": "guide"
    },
    {
      "id": "recipes/analyze-bundle-size",
      "language": "en",
      "filePath": "src/content/docs/en/recipes/analyze-bundle-size.mdx",
      "title": "Analyze bundle size",
      "summary": "**Astro bundle analysis using `rollup-plugin-visualizer`** Astro components are analyzed using `rollup-plugin-visualizer` to visualize and optimize bundle size. Key features include installation of `rollup-plugin-visualizer` via npm/pnpm/yarn, configuration in `astro.config.mjs` with `visualizer` plugin, and execution of the build command to generate `stats.html` files. Implementation details involve adding the plugin to the Vite configuration and emitting the stats file for analysis.",
      "url": "/en/recipes/analyze-bundle-size/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "analyze",
        "bundle",
        "size"
      ],
      "type": "recipe"
    },
    {
      "id": "guides/cms/apostrophecms",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/apostrophecms.mdx",
      "title": "ApostropheCMS & Astro",
      "summary": "**ApostropheCMS & Astro Integration** ApostropheCMS is a content management system that enables on-page editing in Astro projects, providing a seamless editing experience for content creators. **Key Features and APIs** * `APOS_EXTERNAL_FRONT_KEY` environment variable for project communication * Integration with ApostropheCMS using the official Apostrophe integration * Support for on-demand rendered Astro projects with Node.js adapter * Internationalization ready **Implementation Details and Use Cases** * Set `APOS_EXTERNAL_FRONT_KEY` environment variable in Astro project's `.env` file * Install Apostrophe integration using npm or yarn * Configure project communication between Astro and ApostropheCMS using shared key * Enable on-page editing in Astro project using ApostropheCMS as the CMS",
      "url": "/en/guides/cms/apostrophecms/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "apostrophecms",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/backend/appwriteio",
      "language": "en",
      "filePath": "src/content/docs/en/guides/backend/appwriteio.mdx",
      "title": "Appwrite & Astro",
      "summary": "Appwrite & Astro is a backend integration that enables self-hosted backend-as-a-service functionality for Astro projects, providing authentication, account management, database persistence, cloud functions, localization, and image manipulation through APIs such as `appwrite.auth`, `appwrite.database`, and `appwrite.storage`, with implementation details and use cases demonstrated in the Appwrite Demos for Astro repository.",
      "url": "/en/guides/backend/appwriteio/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "backend",
        "appwrite",
        "astro"
      ],
      "type": "backend"
    },
    {
      "id": "reference/adapter-reference",
      "language": "en",
      "filePath": "src/content/docs/en/reference/adapter-reference.mdx",
      "title": "Astro Adapter API",
      "summary": "**Astro Adapter API** Astro adapters are integrations that provide an entrypoint for server rendering at request time, implementing host-specific APIs for handling requests and configuring the build according to host conventions. **Key Features and APIs** * `setAdapter` API in the `astro:config:done` hook to configure the adapter * `AstroAdapter` interface with properties: + `name`: string + `serverEntrypoint`: string + `previewEntrypoint`: string + `exports`: string[] + `args`: any + `adapterFeatures`: `AstroAdapterFeatures` + `supportedAstroFeatures`: `AstroAdapterFeatureMap` * `AstroAdapterFeatures` interface with properties: + `edgeMiddleware`: boolean + `buildOutput`: 'static' | 'server' **Implementation and Use Cases** Adapters can be built as integrations and must call the `setAdapter` API to configure the adapter. The adapter object passed into `setAdapter` defines the adapter's properties and features. Adapters can be used to provide on-demand rendering for various cloud providers.",
      "url": "/en/reference/adapter-reference/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "astro",
        "adapter"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/cant-render-page",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/cant-render-page.mdx",
      "title": "Astro cant render the route.",
      "summary": "**Astro Route Rendering Failure** Astro components fail to render routes when no associated file or redirect is found, resulting in a \"CantRenderPage\" error. This error occurs due to the absence of a file or redirect associated with the route, which is an Astro-specific issue. The error can be resolved by ensuring a file or redirect is present for the route, or by filing an issue if the problem persists after restarting the dev server.",
      "url": "/en/reference/errors/cant-render-page/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "astro",
        "cant",
        "render",
        "route."
      ],
      "type": "guide"
    },
    {
      "id": "reference/container-reference",
      "language": "en",
      "filePath": "src/content/docs/en/reference/container-reference.mdx",
      "title": "Astro Container API (experimental)",
      "summary": "**Astro Container API (experimental)** The Astro Container API allows rendering Astro components in isolation, unlocking potential future uses such as testing `.astro` component output in `vite` environments and manually loading rendering scripts for creating containers in pages rendered on demand or other \"shell\" environments. **Key Features and APIs:** * `create()`: Creates a new instance of the container with options for streaming and loaded client renderers. * `streaming` option: Enables rendering components using HTML streaming (Type: `boolean`). * `renderers` option: A list of loaded client renderers required by the component (Type: `AddServerRenderer[]`). * `renderTostring()`: Renders an Astro component returning a string. * `renderToresponse()`: Renders an Astro component returning a `Response`. **Implementation Details and Use Cases:** * Experimental server-side API subject to breaking changes. * Currently scoped for testing `.astro` component output in `vite` environments. * Allows manual loading of rendering scripts for creating containers in pages rendered on demand or other \"shell\" environments.",
      "url": "/en/reference/container-reference/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "astro",
        "container",
        "(experimental)"
      ],
      "type": "guide"
    },
    {
      "id": "reference/content-loader-reference",
      "language": "en",
      "filePath": "src/content/docs/en/reference/content-loader-reference.mdx",
      "title": "Astro Content Loader API",
      "summary": "Here is the technical documentation summary: **Astro Content Loader API** Astro's Content Loader API allows loading data from any source, local or remote, and interacting with Astro's content layer to manage content collections. The API provides features such as defining loaders in collection schemas, using built-in loaders like `glob()` and `file()`, and creating custom loaders for other sources. Key APIs include `glob()`, `file()`, and `defineCollection()`, with methods like `loader` and `schema` for configuring collections. **Key Features and APIs** * `glob()`: creates entries from directories of files from anywhere on the filesystem * `file()`: loads content from the file system * `defineCollection()`: defines a content collection with a loader and schema * `loader` property: specifies the loader to use for a collection * `schema` property: defines the schema for a collection **Implementation Details and Use Cases** * Loaders can be defined inline in `src/content.config.ts` or shared between multiple collections * Loaders can be published to NPM as a package for sharing and reuse * Built-in loaders support Markdown, MDX, Markdoc, JSON, and YAML file types",
      "url": "/en/reference/content-loader-reference/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "astro",
        "loader"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/failed-to-find-page-map-ssr",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/failed-to-find-page-map-ssr.mdx",
      "title": "Astro couldnt find the correct page to render",
      "summary": "**Astro Error Handling: FailedToFindPageMapSSR** Astro components fail to render due to incorrect page mapping for Server-Side Rendering (SSR) usage, resulting in an internal error. This error is triggered by the `FailedToFindPageMapSSR` exception, which occurs when Astro cannot find a matching page to render. The error is typically resolved by ensuring correct page mapping and SSR configuration.",
      "url": "/en/reference/errors/failed-to-find-page-map-ssr/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "astro",
        "couldnt",
        "find",
        "correct"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/rewrite-encountered-an-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/rewrite-encountered-an-error.mdx",
      "title": "Astro couldnt find the route to rewrite, or if was found but it emitted an error during the rendering phase.",
      "summary": "**Astro Error Handling: RewriteEncounteredAnError** Astro components are unable to rewrite routes that do not exist or emit errors during rendering. This error is triggered when Astro encounters a route that is not defined or fails to render, resulting in a `RewriteEncounteredAnError` exception. The error message includes the non-existent route and a stack trace, indicating the source of the issue.",
      "url": "/en/reference/errors/rewrite-encountered-an-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "astro",
        "couldnt",
        "find",
        "route"
      ],
      "type": "guide"
    },
    {
      "id": "astro-courses",
      "language": "en",
      "filePath": "src/content/docs/en/astro-courses.mdx",
      "title": "Astro Courses",
      "summary": "Astro Courses are a collection of educational resources for learning Astro, including official tutorials, recommended courses, and community learning materials. Key features include: * Integration with Astro's affiliate links for discounts with education partners * Support for various learning formats, such as video lessons, interactive challenges, and projects * APIs for linking to external courses and tutorials, including `LinkCard` and `CardGrid` components Implementation details include: * Use of Astro's `LinkCard` and `CardGrid` components for displaying course information * Integration with external learning platforms, such as Scrimba and Coding in Public * Support for community learning resources, including guides, articles, and blog posts Technical keywords: Astro, education, tutorials, courses, community learning resources, LinkCard, CardGrid, affiliate links, Scrimba, Coding in Public.",
      "url": "/en/astro-courses/",
      "keywords": [
        "content",
        "docs",
        "astro",
        "courses"
      ],
      "type": "guide"
    },
    {
      "id": "guides/astro-db",
      "language": "en",
      "filePath": "src/content/docs/en/guides/astro-db.mdx",
      "title": "Astro DB",
      "summary": "**Astro DB is a fully-managed SQL database designed exclusively for Astro, enabling local development and deployment to any libSQL-compatible database.** **Key Features:** * **Local Database**: A local database is created in `.astro/content.db` when running `astro dev`, allowing data management without Docker or network connection. * **Table Definition**: Define database tables in `db/config.ts` using `defineDb` and `defineTable` utilities, enabling TypeScript support with property autocompletion and type-checking. * **Integration**: Install the `@astrojs/db` integration using `astro add db` and configure database tables to generate a TypeScript interface for querying data. **Implementation Details:** * **Installation**: Use `astro add db` to install the `@astrojs/db` integration and create a `db/config.ts` file for defining database tables. * **Table Structure**: Define tables using `defineTable` and `column` utilities, specifying the structure of data in existing libSQL databases or new databases. **Use Cases:** * **Local Development**: Use Astro DB for local development, creating a database in `.astro/content.db` without requiring Docker or network connection. * **Deployment**: Deploy Astro DB to any libSQL-compatible database, enabling seamless data management and querying.",
      "url": "/en/guides/astro-db/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "astro"
      ],
      "type": "guide"
    },
    {
      "id": "reference/integrations-reference",
      "language": "en",
      "filePath": "src/content/docs/en/reference/integrations-reference.mdx",
      "title": "Astro Integration API",
      "summary": "**Astro Integrations** add new functionality and behaviors for your project with only a few lines of code, utilizing the AstroIntegration API with methods such as `hooks`, `astro:config:setup`, `astro:route:setup`, and `astro:routes:resolved`, which provide access to Astro's configuration, route setup, and resolved routes, allowing for customization and extension of Astro's core functionality. The API is designed to be extensible, enabling developers to create custom integrations using TypeScript interfaces and type-safe APIs. This API is used by official Astro integrations, such as renderers, libraries, and features, and can be leveraged to build custom integrations for specific use cases.",
      "url": "/en/reference/integrations-reference/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "astro",
        "integration"
      ],
      "type": "guide"
    },
    {
      "id": "recipes/index",
      "language": "en",
      "filePath": "src/content/docs/en/recipes/index.mdx",
      "title": "Astro recipes",
      "summary": "Astro recipes are short, focused how-to guides that provide step-by-step instructions for adding new features or behavior to an Astro project. Key features include: * Official recipes that walk users through completing a working example of a specific task * Community resources available through Astro Tips, a collection of user-submitted recipes * Integration with Astro components, such as RecipesNav and ReadMore Implementation details include importing Astro components and using them to display guided examples and community resources. Use cases include adding new features or behavior to an Astro project, and leveraging community resources for additional guidance.",
      "url": "/en/recipes/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "astro"
      ],
      "type": "guide"
    },
    {
      "id": "reference/api-reference",
      "language": "en",
      "filePath": "src/content/docs/en/reference/api-reference.mdx",
      "title": "Astro render context",
      "summary": "Astro render context provides a runtime API specific to the current render, including the current page URL and APIs for actions like redirecting to another page. The `Astro` global object is available to all `.astro` files, offering properties like `Astro.props` and `Astro.redirect()`, which are also mirrored on the `context` object passed to endpoint functions and middleware. The `context` object contains properties such as `props`, which includes values passed as component attributes, and `redirect()`, allowing for dynamic routing and page redirects.",
      "url": "/en/reference/api-reference/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "astro",
        "render",
        "context"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/prerender-client-address-not-available",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/prerender-client-address-not-available.mdx",
      "title": "Astro.clientAddress cannot be used inside prerendered routes.",
      "summary": "**Astro.clientAddress cannot be used inside prerendered routes.** `Astro.clientAddress` property is not accessible within prerendered routes due to limitations in on-demand rendering. This is because `Astro.clientAddress` relies on client-side information, which is not available during prerendering. Refer to [On-demand rendering](/en/guides/on-demand-rendering/) and [Astro.clientAddress](/en/reference/api-reference/#clientaddress) for more information.",
      "url": "/en/reference/errors/prerender-client-address-not-available/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "astro.clientaddress",
        "cannot",
        "used",
        "inside"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/client-address-not-available",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/client-address-not-available.mdx",
      "title": "Astro.clientAddress is not available in current adapter.",
      "summary": "**Astro.clientAddress is a feature that provides client-side address information, but it is not supported in the current adapter.** **Key Features:** * `Astro.clientAddress` API is not available due to adapter limitations * Requires adapter support for `Astro.clientAddress` functionality * Use official integrations or file an issue with the adapter to add support **Implementation Details:** * Adapter-specific implementation required for `Astro.clientAddress` support * Refer to official integrations guide for compatible adapters * Use `Astro.clientAddress` API for client-side address information in supported adapters",
      "url": "/en/reference/errors/client-address-not-available/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "astro.clientaddress",
        "available",
        "current",
        "adapter."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/static-client-address-not-available",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/static-client-address-not-available.mdx",
      "title": "Astro.clientAddress is not available in prerendered pages.",
      "summary": "**Astro.clientAddress is only available on server-rendered pages.** `Astro.clientAddress` property is only accessible when Server-side rendering is enabled, and can be used to retrieve the user's IP address. In static mode, alternative APIs such as Ipify can be used in Client-side scripts or serverless functions to obtain the user's IP address.",
      "url": "/en/reference/errors/static-client-address-not-available/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "astro.clientaddress",
        "available",
        "prerendered",
        "pages."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/astro-glob-no-match",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/astro-glob-no-match.mdx",
      "title": "Astro.glob() did not match any files.",
      "summary": "**Astro.glob() is a utility function for globbing files in Astro, returning an array of matching files.** **Key Features:** * `Astro.glob(GLOB_STR)` returns an array of matching files based on the provided glob pattern. * Supports glob patterns for file matching, including wildcards and path separators. * Throws an error if no matching files are found, indicating a potential typo in the glob pattern. **Implementation Details:** * Utilizes the `glob` module under the hood for file matching. * Can be used in Astro components to dynamically import files based on a glob pattern. **Use Cases:** * Dynamic file import in Astro components. * Automating file matching and import in Astro projects. * Error handling for missing files in Astro applications.",
      "url": "/en/reference/errors/astro-glob-no-match/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "astro.glob()",
        "match",
        "files."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/astro-glob-used-outside",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/astro-glob-used-outside.mdx",
      "title": "Astro.glob() used outside of an Astro file.",
      "summary": "Astro.glob() is a function used to import multiple files at once, but it can only be used within Astro files (.astro). To achieve a similar result outside of Astro files, use import.meta.glob() instead, which provides a similar functionality for importing multiple files. This allows developers to leverage the glob import feature in Vite to import files dynamically.",
      "url": "/en/reference/errors/astro-glob-used-outside/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "astro.glob()",
        "used",
        "outside",
        "astro"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/locals-not-serializable",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/locals-not-serializable.mdx",
      "title": "Astro.locals is not serializable",
      "summary": "**Astro.locals is not serializable** Astro.locals is a feature that allows storing data in the context of a request, but it must store only serializable data to avoid errors. The `LocalsNotSerializable` error occurs when attempting to store non-serializable data, such as functions or objects with circular references, in `Astro.locals`. This error is typically thrown in development mode and can be resolved by ensuring that only serializable data is stored in `locals`.",
      "url": "/en/reference/errors/locals-not-serializable/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "astro.locals",
        "serializable"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/static-redirect-not-available",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/static-redirect-not-available.mdx",
      "title": "Astro.redirect is not available in static mode.",
      "summary": "Astro components are subject to limitations in static mode, specifically regarding redirects. The Astro.redirect function is only available when Server-side rendering (SSR) is enabled, which can be achieved by setting output to 'server' or 'hybrid' in the Astro config. To redirect on a static website, alternative methods such as the meta refresh attribute or host-based redirects (e.g., Netlify redirects) can be employed.",
      "url": "/en/reference/errors/static-redirect-not-available/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "astro.redirect",
        "available",
        "static",
        "mode."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/astro-response-headers-reassigned",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/astro-response-headers-reassigned.mdx",
      "title": "Astro.response.headers must not be reassigned.",
      "summary": "Astro components are restricted from reassigning the `Astro.response.headers` object, which can be modified by adding or removing individual headers, but not replaced with a new instance of `Headers`. This restriction is enforced to prevent unexpected behavior and ensure predictable output. The `AstroResponseHeadersReassigned` error is thrown when attempting to set a new value as the `headers` field on the `ResponseInit` object.",
      "url": "/en/reference/errors/astro-response-headers-reassigned/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "astro.response.headers",
        "must",
        "reassigned."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/render-undefined-entry-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/render-undefined-entry-error.mdx",
      "title": "Attempted to render an undefined content collection entry.",
      "summary": "**Astro components are designed to render content collection entries, but may fail if an entry is undefined.** **Key features and APIs:** * `Astro.props` is used to access component props * `getStaticPaths` is not directly related to this issue, but is a relevant Astro feature for handling dynamic routes * Rendering undefined content collection entries can occur when trying to access a non-existent entry **Implementation details and use cases:** * This error can occur when trying to render a content collection entry that does not exist * Use `Astro.props` to access component props and ensure they are defined before rendering * Implement error handling to catch and display a meaningful error message when an undefined entry is encountered",
      "url": "/en/reference/errors/render-undefined-entry-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "attempted",
        "render",
        "undefined",
        "collection"
      ],
      "type": "guide"
    },
    {
      "id": "guides/authentication",
      "language": "en",
      "filePath": "src/content/docs/en/guides/authentication.mdx",
      "title": "Authentication",
      "summary": "**Authentication in Astro** Authentication in Astro enables customization of site areas for logged-in individuals and provides protection for personal or private information. Astro does not have an official authentication solution, but community integrations, such as `auth-astro`, are available for frameworks like Auth.js. These integrations provide utilities for multiple authentication methods, including email sign-in and OAuth providers. **Key Features and APIs** * `auth-astro` integration for Astro * Support for multiple authentication methods (email sign-in, OAuth providers) * Community framework adapter for Auth.js * Installation via `astro add` command or manual installation **Implementation Details and Use Cases** * Use `auth-astro` integration to add authentication to Astro projects * Implement email sign-in and OAuth providers using Auth.js * Customize site areas for logged-in individuals * Protect personal or private information with authentication **Technical Keywords** * Authentication * Authorization * Astro * Auth.js * OAuth * Email sign-in * Community integrations * Framework adapters",
      "url": "/en/guides/authentication/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "authentication"
      ],
      "type": "guide"
    },
    {
      "id": "tutorial/6-islands/2",
      "language": "en",
      "filePath": "src/content/docs/en/tutorial/6-islands/2.mdx",
      "title": "Back on dry land. Take your blog from day to night, no island required!",
      "summary": "**Astro components are used to build interactive elements, including theme toggles, using vanilla JavaScript and CSS.** **Key features and APIs:** * `button` element with `id` attribute for theme toggle functionality * `svg` element with `path` elements for sun and moon icons * Use of CSS classes (`sun` and `moon`) for styling * JavaScript code for interactivity, sent to the browser with minimal framework code **Implementation details and use cases:** * Create a new file at `src/components/ThemeIcon.astro` and paste the provided code * Use the `Steps` component to guide the development process * Implement a theme toggle icon with JavaScript and CSS, sending minimal JavaScript to the browser",
      "url": "/en/tutorial/6-islands/2/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "6 islands",
        "back",
        "land.",
        "take",
        "your"
      ],
      "type": "tutorial"
    },
    {
      "id": "recipes/build-custom-img-component",
      "language": "en",
      "filePath": "src/content/docs/en/recipes/build-custom-img-component.mdx",
      "title": "Build a custom image component",
      "summary": "**Custom Image Component** Astro components are used to display and optimize images, with built-in components like `` and `` supporting responsive images and optimization. However, when custom options are required, the `getImage()` function can be used to create a custom image component. **Key Features and APIs** * `getImage()` function for generating custom images * `Astro.props` for passing props to custom components * `mobileImgUrl` and `desktopImgUrl` props for creating responsive images * `alt` prop for image alt text * TypeScript support for typing props **Implementation and Use Cases** The `getImage()` function is used to create a custom image component that displays different source images based on media queries. The component receives props from `Astro.props` and uses the `getImage()` function to define responsive images. This approach allows for custom image optimization and formatting.",
      "url": "/en/recipes/build-custom-img-component/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "build",
        "custom",
        "image",
        "component"
      ],
      "type": "recipe"
    },
    {
      "id": "tutorial/5-astro-api/3",
      "language": "en",
      "filePath": "src/content/docs/en/tutorial/5-astro-api/3.mdx",
      "title": "Build a tag index page",
      "summary": "**Build a Tag Index Page** Astro components are used to create a tag index page that displays a list of all unique tags, linking to each tag page, utilizing the `/pages/folder/index.astro` routing pattern. **Key Features and APIs** * `/pages/folder/index.astro` routing pattern for organizing related files * `index.astro` file creation in `src/pages/tags/` directory * Importing and using `BaseLayout` component * Utilizing Astro's built-in routing and layout features **Implementation Details and Use Cases** Create a new file `index.astro` in `src/pages/tags/` and use the `/pages/folder/index.astro` routing pattern to display a list of all unique tags, linking to each tag page. This can be achieved by importing and using the `BaseLayout` component and utilizing Astro's built-in routing and layout features.",
      "url": "/en/tutorial/5-astro-api/3/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "5 astro api",
        "build",
        "index",
        "page"
      ],
      "type": "tutorial"
    },
    {
      "id": "recipes/build-forms-api",
      "language": "en",
      "filePath": "src/content/docs/en/recipes/build-forms-api.mdx",
      "title": "Build forms with API routes",
      "summary": "**Astro API Routes enable sending form submissions to a custom API endpoint** Astro API Routes provide a way to intercept form submissions using JavaScript, allowing form data to be sent to a custom API endpoint instead of refreshing the page. Key features include `request.formData()` for processing form data and `APIRoute` for defining API endpoints. Implementation details include creating a `POST` API endpoint at `/api/feedback` to receive form data, validating form values, and returning a success response. Use cases include integrating with UI frameworks and handling form submissions in Astro projects.",
      "url": "/en/recipes/build-forms-api/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "build",
        "forms",
        "with",
        "routes"
      ],
      "type": "recipe"
    },
    {
      "id": "recipes/build-forms",
      "language": "en",
      "filePath": "src/content/docs/en/recipes/build-forms.mdx",
      "title": "Build HTML forms in Astro pages",
      "summary": "**Astro pages can display and handle HTML forms, utilizing server-side rendering and frontmatter scripts to process form submissions without client-side JavaScript.** **Key Features and APIs:** * Use `` tags with `name` attributes for input fields * Implement client-side validation with attributes like `required`, `minlength`, and `type=\"email\"` * Utilize server-side rendering with Astro's frontmatter scripts to handle form submissions * Leverage Astro's `server adapter` for on-demand rendering **Implementation Details and Use Cases:** * Create an Astro page with a `` tag and input fields * Add validation attributes to input fields for basic client-side validation * Use Astro's frontmatter script to handle form submissions on the server * Integrate with Astro's `server adapter` for on-demand rendering and server-side rendering capabilities",
      "url": "/en/recipes/build-forms/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "build",
        "html",
        "forms",
        "astro"
      ],
      "type": "recipe"
    },
    {
      "id": "tutorial/3-components/3",
      "language": "en",
      "filePath": "src/content/docs/en/tutorial/3-components/3.mdx",
      "title": "Build it yourself - Header",
      "summary": "**Header Component** Astro components are used to create a responsive page navigation that adapts to multiple screen sizes. **Key Features and APIs** * Import and use existing `Navigation.astro` component inside a `` element within a `` element. * Utilize Astro's built-in `header` and `nav` elements for semantic HTML structure. * Leverage Astro's component composition to create a reusable Header component. **Implementation Details and Use Cases** * Create a new `Header.astro` component in `src/components/` and import `Navigation.astro` inside a `` element. * Update existing pages to replace `Navigation` component with the new `Header` component. * Use Astro's `import` and `export` syntax to manage component dependencies and reuse.",
      "url": "/en/tutorial/3-components/3/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "3 components",
        "build",
        "yourself",
        "header"
      ],
      "type": "tutorial"
    },
    {
      "id": "recipes/docker",
      "language": "en",
      "filePath": "src/content/docs/en/recipes/docker.mdx",
      "title": "Build your Astro site with Docker",
      "summary": "**Build your Astro site with Docker** Astro components are containerized using Docker to enable deployment on various platforms, including AWS, Azure, and Google Cloud. Key features and APIs include: * `Dockerfile` creation for building and serving Astro sites in SSR and static modes * `FROM node:lts` and `FROM node:lts-alpine` images for Node.js runtime * `WORKDIR /app`, `COPY . .`, `RUN npm install`, and `RUN npm run build` commands for building and installing dependencies * `ENV HOST=0.0.0.0`, `ENV PORT=4321`, and `EXPOSE 4321` environment variables for serving the site * `CMD node ./dist/server/entry.mjs` command for running the server Implementation details include creating a `Dockerfile` in the project root directory, using a `.dockerignore` file to exclude unnecessary files, and customizing the Dockerfile for specific needs. Use cases include deploying Astro sites to cloud platforms and running the site in a containerized environment.",
      "url": "/en/recipes/docker/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "build",
        "your",
        "astro",
        "site"
      ],
      "type": "recipe"
    },
    {
      "id": "tutorial/0-introduction/index",
      "language": "en",
      "filePath": "src/content/docs/en/tutorial/0-introduction/index.mdx",
      "title": "Build your first Astro Blog",
      "summary": "Astro components are used to build a fully-functioning blog from scratch, leveraging features such as Astro.props, getStaticPaths, and Astro components to create pages and blog posts, query local files, and add interactivity to the site. Implementation details include setting up a development environment, building with Astro components, and deploying the site to the web using online coding environments like IDX or StackBlitz. Technical keywords: Astro components, getStaticPaths, Astro.props, local file querying, interactivity, deployment.",
      "url": "/en/tutorial/0-introduction/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "0 introduction",
        "build",
        "your",
        "first",
        "astro"
      ],
      "type": "tutorial"
    },
    {
      "id": "tutorial/6-islands/1",
      "language": "en",
      "filePath": "src/content/docs/en/tutorial/6-islands/1.mdx",
      "title": "Build your first Astro island",
      "summary": "**Astro components are used to build interactive web applications with Preact components.** **Key features and APIs include:** * `client:` directives for making Astro islands interactive * `Astro.props` for passing data to components * `useState` hook from Preact for managing component state * `Steps` component from `@astrojs/starlight/components` for displaying step-by-step instructions **Implementation details and use cases:** * Add Preact to an Astro project using `npx astro add preact` or equivalent command * Create a Preact component (e.g., `Greeting.jsx`) and use `useState` to manage component state * Use `client:` directives to make the Preact component interactive on the client-side * Display step-by-step instructions using the `Steps` component",
      "url": "/en/tutorial/6-islands/1/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "6 islands",
        "build",
        "your",
        "first",
        "astro"
      ],
      "type": "tutorial"
    },
    {
      "id": "tutorial/4-layouts/1",
      "language": "en",
      "filePath": "src/content/docs/en/tutorial/4-layouts/1.mdx",
      "title": "Build your first layout",
      "summary": "**Astro components are used to create reusable layouts and components for web applications.** **Key features and APIs include:** * Creating a shared page layout component using Astro's `` element * Passing page-specific values as props to the layout component using Astro.props * Using Astro's `import` statement to import components and styles from other files * Implementing internationalization (i18n) using Astro's built-in support **Implementation details and use cases:** * Creating a new file for the layout component at `src/layouts/BaseLayout.astro` * Copying the contents of `index.astro` into the new file and refactoring common elements * Using the layout component on a page by importing it and passing page-specific values as props * Utilizing Astro's `import` statement to import components and styles from other files **Technical keywords:** Astro, layout component, reusable components, internationalization, i18n, Astro.props, `` element, `import` statement.",
      "url": "/en/tutorial/4-layouts/1/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "4 layouts",
        "build",
        "your",
        "first",
        "layout"
      ],
      "type": "tutorial"
    },
    {
      "id": "guides/cms/builderio",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/builderio.mdx",
      "title": "Builder.io & Astro",
      "summary": "**Builder.io & Astro Integration** Builder.io components are integrated with Astro to enable drag-and-drop content editing for building websites with zero client-side JavaScript. This integration utilizes the Builder API to fetch content from a Builder space, with features including `getStaticPaths` and `Astro.props` for dynamic content rendering. Implementation details involve setting up a `.env` file with Builder API credentials and configuring environment variables for IntelliSense support.",
      "url": "/en/guides/cms/builderio/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "builder.io",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/build-with-ai",
      "language": "en",
      "filePath": "src/content/docs/en/guides/build-with-ai.mdx",
      "title": "Building Astro sites with AI tools",
      "summary": "**Astro sites with AI tools are enhanced with up-to-date knowledge of Astro's core APIs and concepts, leveraging AI-powered editors and agentic coding tools.** **Key features and APIs include:** * `llms.txt` and `llms-full.txt` files for AI consumption, providing static Astro Docs content in a streamlined Markdown format * Astro Docs MCP Server for real-time access to the latest documentation, ensuring AI tools avoid outdated recommendations and understand current best practices * Model Context Protocol (MCP) for standardized access to external tools and data sources **Implementation details and use cases:** * Use `https://docs.astro.build` as a docs source for AI tools to auto-discover context files * Leverage the MCP server for efficient access to the full documentation with real-time search capabilities * Update context files regularly to stay current, or use the MCP server as a fallback when available",
      "url": "/en/guides/build-with-ai/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "building",
        "astro",
        "sites",
        "with",
        "tools"
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/buttercms",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/buttercms.mdx",
      "title": "ButterCMS & Astro",
      "summary": "Astro components are integrated with ButterCMS to fetch and display structured content in Astro projects. Key features include using the ButterCMS SDK to bring data into Astro projects, setting up environment variables for API tokens, and installing the ButterCMS package as a dependency. Implementation details involve creating a `buttercms.js` file to initialize the ButterCMS client with the API token, and using the `butterClient` instance to fetch and render content in Astro components.",
      "url": "/en/guides/cms/buttercms/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "buttercms",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/cms/caisy",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/caisy.mdx",
      "title": "Caisy & Astro",
      "summary": "**Caisy & Astro Integration** Caisy & Astro is a headless CMS integration that enables content fetching and rendering in Astro projects using Caisy's GraphQL API and `graphql-request`. Key features include: * Utilizing `graphql-request` to fetch CMS data and display content on Astro pages * Implementing Caisy's rich text renderer for Astro to render content * Supporting internationalization and localization through Caisy's GraphQL API * Enabling pagination, filtering, and ordering of query results Implementation details include using the `GraphQLClient` to establish a connection to the Caisy API, defining GraphQL queries to fetch content, and rendering content using the `RichTextRenderer` component. Official resources include a GitHub example repository and documentation on Caisy's API features.",
      "url": "/en/guides/cms/caisy/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "caisy",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "recipes/call-endpoints",
      "language": "en",
      "filePath": "src/content/docs/en/recipes/call-endpoints.mdx",
      "title": "Call endpoints from the server",
      "summary": "Astro components are capable of calling endpoints from the server using the `APIRoute` type and the `GET` method, which returns a `Response` object containing data. This can be achieved by importing the `GET` method from an endpoint file and calling it with the `Astro` global to provide the request context, allowing for server-side rendering without additional fetch requests. The `GET` method can be used to serve various types of data, such as JSON responses, and can be utilized in Astro pages to fetch and display data from the server.",
      "url": "/en/recipes/call-endpoints/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "call",
        "endpoints",
        "from",
        "server"
      ],
      "type": "recipe"
    },
    {
      "id": "reference/errors/cannot-determine-weight-and-style-from-font-file",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/cannot-determine-weight-and-style-from-font-file.mdx",
      "title": "Cannot determine weight and style from font file.",
      "summary": "**Font File Weight and Style Determination** Font files cannot automatically determine weight and style, requiring manual configuration in the family config. Update the `weight` and `style` properties to resolve the issue. Use the `Astro.fonts` API to manually specify font weights and styles.",
      "url": "/en/reference/errors/cannot-determine-weight-and-style-from-font-file/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "cannot",
        "determine",
        "weight",
        "style"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/cannot-extract-font-type",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/cannot-extract-font-type.mdx",
      "title": "Cannot extract the font type from the given URL.",
      "summary": "**Font Type Extraction Error** Cannot extract the font type from the given URL due to a critical error in font type resolution. This issue is caused by a failure to parse the font type from the provided URL, resulting in an inability to load the font. The error is triggered when the `font-type` attribute is not properly formatted or is missing from the URL.",
      "url": "/en/reference/errors/cannot-extract-font-type/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "cannot",
        "extract",
        "font",
        "type"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/cannot-fetch-font-file",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/cannot-fetch-font-file.mdx",
      "title": "Cannot fetch the given font file.",
      "summary": "**Font File Fetching Error** Font file fetching errors occur when Astro components fail to retrieve font files from specified URLs, resulting in a critical error. This issue can be caused by invalid font file URLs, network connectivity issues, or font file format errors. To resolve this, ensure the font file URL is correct, verify network connectivity, and check the font file format for compatibility.",
      "url": "/en/reference/errors/cannot-fetch-font-file/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "cannot",
        "fetch",
        "given",
        "font"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/cannot-load-font-provider",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/cannot-load-font-provider.mdx",
      "title": "Cannot load font provider",
      "summary": "**Astro Font Provider Loading** Astro components are unable to load font providers due to an inability to fetch or render the font assets. This issue is typically resolved by checking the font provider's repository for any known issues or by implementing a fallback font or font loading strategy using APIs such as `getStaticPaths` or `Astro.props`.",
      "url": "/en/reference/errors/cannot-load-font-provider/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "cannot",
        "load",
        "font",
        "provider"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/incompatible-descriptor-options",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/incompatible-descriptor-options.mdx",
      "title": "Cannot set both densities and widths",
      "summary": "**Image Descriptor Options:** Cannot set both densities and widths, as they are mutually exclusive attributes used to construct a srcset attribute. Only one of `densities` or `widths` can be specified, with `widths` being the recommended option for specific widths. This limitation is due to the inherent conflict between `x` and `w` descriptors in the srcset attribute.",
      "url": "/en/reference/errors/incompatible-descriptor-options/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "cannot",
        "both",
        "densities",
        "widths"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/rewrite-with-body-used",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/rewrite-with-body-used.mdx",
      "title": "Cannot use Astro.rewrite after the request body has been read",
      "summary": "Astro components are designed to handle server-side rendering and routing, featuring APIs such as Astro.rewrite and Astro.props, with methods like getStaticPaths for static site generation. However, Astro.rewrite cannot be used if the request body has already been read, requiring the request to be cloned before reading the body. This is achieved through methods like Request.clone() and Astro.request.clone().",
      "url": "/en/reference/errors/rewrite-with-body-used/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "cannot",
        "astro.rewrite",
        "after",
        "request"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/no-adapter-installed-server-islands",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/no-adapter-installed-server-islands.mdx",
      "title": "Cannot use Server Islands without an adapter.",
      "summary": "**Server Islands Require Adapter** Server islands in Astro cannot be used without an adapter, which is necessary for server-side rendering. The `NoAdapterInstalledServerIslands` error occurs when attempting to use server islands without a configured adapter. To resolve this, install and configure a server adapter for your final deployment.",
      "url": "/en/reference/errors/no-adapter-installed-server-islands/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "cannot",
        "server",
        "islands",
        "without"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/no-adapter-installed",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/no-adapter-installed.mdx",
      "title": "Cannot use Server-side Rendering without an adapter.",
      "summary": "**Server-side Rendering in Astro** Server-side rendering in Astro is enabled through the installation and configuration of a server adapter, which is required for generating output on the targeted deployment platform. Key features and APIs include: * `server-side rendering` enabled through adapter installation * Adapter configuration for targeted deployment platform * `NoAdapterInstalled` error when server-side rendering is attempted without an adapter Implementation details and use cases involve installing and configuring a server adapter, such as `@astrojs/express` or `@astrojs/next`, to enable server-side rendering for Astro applications.",
      "url": "/en/reference/errors/no-adapter-installed/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "cannot",
        "server-side",
        "rendering",
        "without"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/cant-use-astro-config-module-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/cant-use-astro-config-module-error.mdx",
      "title": "Cannot use the astro:config module without enabling the experimental feature.",
      "summary": "**Astro components are used to render dynamic content, but cannot use the astro:config module without enabling the experimental feature.** **Key features and APIs:** * `experimental.serializeConfig` flag in `astro.config.mjs` * `astro:config` module import error * `CantUseAstroConfigModuleError` error type **Implementation details and use cases:** * Enable `experimental.serializeConfig` to use `astro:config` module * Use `astro:config` module for dynamic configuration rendering * Upgrade to a recent Astro version to resolve deprecated error",
      "url": "/en/reference/errors/cant-use-astro-config-module-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "cannot",
        "astro:config",
        "module",
        "without"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/actions-cant-be-loaded",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/actions-cant-be-loaded.mdx",
      "title": "Cant load the Astro actions.",
      "summary": "**Astro Actions Loading Error** Astro actions loading fails due to an unknown error while loading the actions file, thrown in development mode. **Key Features and APIs:** * `Astro.actions` API returns an error when the actions file cannot be loaded * `DontEditWarning` component is rendered when actions loading fails * Error message indicates \"ActionsCantBeLoaded\" and provides a brief description of the issue **Implementation Details and Use Cases:** * Astro actions loading is critical for development mode * Error handling is essential to prevent application crashes * Debugging and troubleshooting require access to the actions file and error messages",
      "url": "/en/reference/errors/actions-cant-be-loaded/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "cant",
        "load",
        "astro",
        "actions."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/middleware-cant-be-loaded",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/middleware-cant-be-loaded.mdx",
      "title": "Cant load the middleware.",
      "summary": "**Astro middleware loading error handling** Astro middleware loading error handling is triggered when an error occurs while loading middleware in development mode. This error is thrown when middleware throws an error while attempting to load it, preventing the application from proceeding. The `MiddlewareCantBeLoaded` error is raised, providing a clear indication of the issue, with a stacktrace and error message for debugging purposes.",
      "url": "/en/reference/errors/middleware-cant-be-loaded/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "cant",
        "load",
        "middleware."
      ],
      "type": "guide"
    },
    {
      "id": "tutorial/1-setup/index",
      "language": "en",
      "filePath": "src/content/docs/en/tutorial/1-setup/index.mdx",
      "title": "Check in: Unit 1 - Setup",
      "summary": "Here is the technical documentation summary: **Setup and Deployment** Astro components are used to set up development environments and deploy to Netlify. Key features include importing Astro components (`Checklist`, `Box`), using Starlight components (`Steps`), and implementing deployment to Netlify. Implementation details include using online code editors (Google IDX) and creating GitHub repositories.",
      "url": "/en/tutorial/1-setup/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "1 setup",
        "check",
        "unit",
        "setup"
      ],
      "type": "tutorial"
    },
    {
      "id": "tutorial/2-pages/index",
      "language": "en",
      "filePath": "src/content/docs/en/tutorial/2-pages/index.mdx",
      "title": "Check in: Unit 2 - Pages",
      "summary": "Astro components are used to create pages and posts with Markdown (.md) files, style individual pages with tags, and apply global styles across pages. Key features include: * Creating Astro pages with the `.astro` syntax * Using Markdown (.md) files for blog posts * Styling individual pages with `` tags * Applying global styles across pages using variables and conditional rendering Implementation details include: * Understanding the two sections of a `.astro` file * Using variables and conditional rendering on pages * Integrating Markdown files for blog posts Technical keywords: Astro components, Markdown, `.astro` syntax, `` tags, global styles, variables, conditional rendering.",
      "url": "/en/tutorial/2-pages/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "2 pages",
        "check",
        "unit",
        "pages"
      ],
      "type": "tutorial"
    },
    {
      "id": "tutorial/3-components/index",
      "language": "en",
      "filePath": "src/content/docs/en/tutorial/3-components/index.mdx",
      "title": "Check in: Unit 3 - Components",
      "summary": "**Astro components are reusable, self-contained pieces of HTML, CSS, and JavaScript code that can be easily imported and used across multiple pages on a website.** **Key features and APIs include:** * Importing and using Astro components (e.g., `import Box from '~/components/tutorial/Box.astro';`) * Utilizing Astro component props (e.g., `Astro.props`) * Leveraging Astro component methods (e.g., `getStaticPaths`) * Implementing responsive design with CSS and JavaScript * Creating interactive components that react to user input (e.g., hamburger menu) **Implementation details and use cases include:** * Building reusable components for common elements (e.g., Navigation, Footer, Social Media) * Creating interactive components (e.g., Hamburger menu) * Using Astro components to enhance website responsiveness and user experience",
      "url": "/en/tutorial/3-components/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "3 components",
        "check",
        "unit",
        "components"
      ],
      "type": "tutorial"
    },
    {
      "id": "tutorial/4-layouts/index",
      "language": "en",
      "filePath": "src/content/docs/en/tutorial/4-layouts/index.mdx",
      "title": "Check in: Unit 4 - Layouts",
      "summary": "**Layout Components are reusable Astro templates that enable sharing common elements and styles across pages and blog posts.** **Key Features:** * Create reusable layout components using Astro's component syntax * Pass content to layouts using `` elements * Pass data from Markdown frontmatter to layouts using Astro.props API * Nest multiple layouts to create complex page structures **Implementation Details:** * Use Astro's component syntax to define layout components * Utilize `` elements to inject content into layouts * Leverage Astro.props API to access Markdown frontmatter data in layouts",
      "url": "/en/tutorial/4-layouts/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "4 layouts",
        "check",
        "unit",
        "layouts"
      ],
      "type": "tutorial"
    },
    {
      "id": "tutorial/5-astro-api/index",
      "language": "en",
      "filePath": "src/content/docs/en/tutorial/5-astro-api/index.mdx",
      "title": "Check in: Unit 5 - Astro API",
      "summary": "Astro API enables developers to work with files in their project using `import.meta.glob()` and access data from files. Key features include `getStaticPaths()` for creating multiple pages at once and the Astro RSS package for generating an RSS feed. This API is used to implement index pages, tag pages, and RSS feeds in Astro projects.",
      "url": "/en/tutorial/5-astro-api/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "5 astro api",
        "check",
        "unit",
        "astro"
      ],
      "type": "tutorial"
    },
    {
      "id": "tutorial/6-islands/index",
      "language": "en",
      "filePath": "src/content/docs/en/tutorial/6-islands/index.mdx",
      "title": "Check in: Unit 6 - Astro Islands",
      "summary": "Astro islands enable the integration of frontend framework components into Astro sites, allowing for interactive elements and enhanced user experiences. Key features include: * Integration with UI frameworks such as Preact * Use of Astro islands to create interactive components, such as the greeting component * APIs and methods for managing island behavior, including Astro.props and getStaticPaths Implementation details involve adding a UI framework to the Astro project and using it to create interactive components, with use cases including enhancing user experiences and adding interactivity to Astro sites.",
      "url": "/en/tutorial/6-islands/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "6 islands",
        "check",
        "unit",
        "astro",
        "islands"
      ],
      "type": "tutorial"
    },
    {
      "id": "reference/cli-reference",
      "language": "en",
      "filePath": "src/content/docs/en/reference/cli-reference.mdx",
      "title": "CLI Commands",
      "summary": "**CLI Commands** The Astro CLI provides a set of commands for developing, building, and previewing projects from a terminal window. Key features include: * `astro dev` command to start the development server with live preview updates * `astro --help` command to display a list of available commands and flags * Support for package managers (npm, pnpm, yarn) with corresponding command syntax (e.g., `npx astro dev`) Implementation details include: * Integration with package managers for command execution * Flag-based customization of command behavior * Support for various commands (add, build, check, create-key, dev, docs, info, preview, sync) Use cases include: * Rapid development and testing of Astro projects * Automated build and deployment processes * Integration with CI/CD pipelines",
      "url": "/en/reference/cli-reference/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "commands"
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/cloudcannon",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/cloudcannon.mdx",
      "title": "CloudCannon & Astro",
      "summary": "CloudCannon & Astro integrates CloudCannon's Git-based headless CMS with Astro components, enabling content management and live editing of Astro projects. Key features include Astro components (e.g., `Grid`, `Card`) and APIs (e.g., `Astro.props`), with implementation details and use cases outlined in official resources and community documentation. This integration supports internationalization and is ready for production use.",
      "url": "/en/guides/cms/cloudcannon/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "cloudcannon",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/media/cloudinary",
      "language": "en",
      "filePath": "src/content/docs/en/guides/media/cloudinary.mdx",
      "title": "Cloudinary & Astro",
      "summary": "**Cloudinary & Astro** Cloudinary & Astro components are a set of native Astro components for image, video, and upload functionality, as well as a content loader for Astro content collections, leveraging Cloudinary's Transformation API for asset editing and delivery. Key features include: * `CloudinaryImage`, `CloudinaryVideo`, and `CloudinaryUpload` components for seamless integration * `getStaticPaths` and `Astro.props` support for optimized asset delivery * Integration with Cloudinary's Transformation API for dynamic cropping, resizing, and generative AI * Support for Cloudinary's Node.js and JavaScript SDKs for uploading assets and making API requests Implementation details include installing the Cloudinary Astro SDK via npm, pnpm, or yarn, and configuring Cloudinary credentials in a `.env` file.",
      "url": "/en/guides/media/cloudinary/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "media",
        "cloudinary",
        "astro"
      ],
      "type": "media"
    },
    {
      "id": "reference/errors/content-collection-type-mismatch-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/content-collection-type-mismatch-error.mdx",
      "title": "Collection contains entries of a different type.",
      "summary": "**ContentCollectionTypeMismatchError**: COLLECTION contains EXPECTED_TYPE entries, but is configured as a ACTUAL_TYPE collection. **Purpose/Function**: Legacy content collections must contain entries of the type configured. **Features/APIs**: `type` property in collection config, `ContentCollectionTypeMismatchError` error. **Implementation Details/Use Cases**: Collections are `type: 'content'` by default; add `type: 'data'` to collection config for data collections. **Keywords**: Legacy content collections, collection config, type mismatch error.",
      "url": "/en/reference/errors/content-collection-type-mismatch-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "collection",
        "contains",
        "entries",
        "different"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/collection-does-not-exist-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/collection-does-not-exist-error.mdx",
      "title": "Collection does not exist",
      "summary": "**Collection does not exist** Astro components handle non-existent collections by displaying a warning instead of throwing an error. This is achieved through the use of the `getCollection()` API, which returns a warning message when a collection with the requested name does not exist. The warning is displayed via the `DontEditWarning` component, and can be customized using the `caution` component with a deprecated message.",
      "url": "/en/reference/errors/collection-does-not-exist-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "collection",
        "does",
        "exist"
      ],
      "type": "guide"
    },
    {
      "id": "tutorial/4-layouts/3",
      "language": "en",
      "filePath": "src/content/docs/en/tutorial/4-layouts/3.mdx",
      "title": "Combine layouts to get the best of both worlds",
      "summary": "**Astro layouts are composable components that enable nesting of layouts to achieve a unified design across pages.** **Key features:** * Nesting layouts using Astro's composable component architecture * Importing and wrapping layouts using Astro's `import` and `wrap` syntax * Passing props between layouts using Astro's `props` API * Utilizing Astro's `pageTitle` prop to set the page title **Implementation details:** * Importing `BaseLayout.astro` in `MarkdownPostLayout.astro` and wrapping the entire template content * Passing `pageTitle` prop from `MarkdownPostLayout.astro` to `BaseLayout.astro` * Removing redundant `meta` tag in `MarkdownPostLayout.astro` as it is already included in `BaseLayout.astro` **Use cases:** * Unifying design across pages by nesting layouts * Creating a consistent layout structure for blog posts and other pages * Utilizing Astro's composable component architecture to build modular and reusable layouts",
      "url": "/en/tutorial/4-layouts/3/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "4 layouts",
        "combine",
        "layouts",
        "best",
        "both"
      ],
      "type": "tutorial"
    },
    {
      "id": "basics/astro-components",
      "language": "en",
      "filePath": "src/content/docs/en/basics/astro-components.mdx",
      "title": "Components",
      "summary": "**Astro components** are HTML-only templating components with no client-side runtime, using the `.astro` file extension, and can be as small as a snippet of HTML or an entire page layout. Key features include: * **getStaticPaths**: Not applicable, as Astro components don't render on the client. * **Astro.props**: Not applicable, as Astro components use HTML-only templating. * **server directives**: Can be used to defer server rendering for personalized or dynamic content. * **client islands**: Can be added using standard HTML `` tags or UI Framework components. Implementation details include: * **Component Script**: Contains JavaScript code that is stripped from the final page sent to users' browsers. * **Component Template**: The HTML template that renders to HTML at build-time or on-demand. * **Server islands**: Can be used to render personalized or dynamic content when it is available. Use cases include: * Creating reusable UI elements, such as headers or profile cards. * Building entire page layouts or pages themselves. * Deferring server rendering for personalized or dynamic content.",
      "url": "/en/basics/astro-components/",
      "keywords": [
        "content",
        "docs",
        "basics",
        "components"
      ],
      "type": "guide"
    },
    {
      "id": "reference/modules/astro-config",
      "language": "en",
      "filePath": "src/content/docs/en/reference/modules/astro-config.mdx",
      "title": "Config imports API Reference",
      "summary": "**Config imports API Reference** The `astro:config` module exposes a non-exhaustive, serializable, type-safe version of the Astro configuration, allowing access to configuration values through two submodules: `/client` and `/server`. The `/client` submodule provides a subset of configuration values accessible on the client-side, while the `/server` submodule exposes all available config values, including sensitive file system information. **Features and APIs:** * `astro:config/client`: exposes client-side accessible configuration values, including `i18n`, `trailingSlash`, `base`, `build.format`, and `site`. * `astro:config/server`: exposes all available configuration values, including sensitive file system information, such as `srcDir`, `cacheDir`, `outDir`, `publicDir`, and `root`. * Importable configuration values include `i18n`, `trailingSlash`, `base`, `build`, `site`, `srcDir`, `cacheDir`, `outDir`, `publicDir`, and `root`. **Implementation Details and Use Cases:** * Use `astro:config/client` for client-side code, such as utility functions that rely on client-side configuration values. * Use `astro:config/server` for server-side code, such as server-side rendering or API integrations that require access to sensitive file system information.",
      "url": "/en/reference/modules/astro-config/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "modules",
        "config",
        "imports"
      ],
      "type": "guide"
    },
    {
      "id": "guides/configuring-astro",
      "language": "en",
      "filePath": "src/content/docs/en/guides/configuring-astro.mdx",
      "title": "Configuration overview",
      "summary": "**Astro Configuration Overview** Astro is a flexible, unopinionated framework that allows configuration through various files, including the Astro config file (`astro.config.mjs`) and TypeScript config file (`tsconfig.json`). The Astro config file uses the `defineConfig()` helper to provide IntelliSense and configure build and rendering options, while the TypeScript config file enables type checking and editor tooling. Supported configuration options are documented in the Astro configuration reference.",
      "url": "/en/guides/configuring-astro/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "configuration",
        "overview"
      ],
      "type": "guide"
    },
    {
      "id": "reference/configuration-reference",
      "language": "en",
      "filePath": "src/content/docs/en/reference/configuration-reference.mdx",
      "title": "Configuration Reference",
      "summary": "**Astro Configuration Reference** Astro components are configured using the `defineConfig` function from `astro/config`, which exports a configuration object with top-level options. **Top-Level Options** * **site**: `string` - Your final, deployed URL, used for generating sitemap and canonical URLs. (e.g., `site: 'https://www.my-site.dev'`) * **base**: `string` - The base path to deploy to, used as the root for pages and assets. (e.g., `base: '/docs'`) **Implementation Details** * `import.meta.env.BASE_URL` is determined by `trailingSlash` config, and is used to prefix static asset imports and URLs. * `config.base` is internally manipulated by Astro before being made available to integrations, and its value is determined by `trailingSlash` config.",
      "url": "/en/reference/configuration-reference/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "configuration"
      ],
      "type": "guide"
    },
    {
      "id": "reference/experimental-flags/index",
      "language": "en",
      "filePath": "src/content/docs/en/reference/experimental-flags/index.mdx",
      "title": "Configuring experimental flags",
      "summary": "Astro components are configurable with experimental flags to enable early access to new features for testing and feedback. Experimental flags are enabled in the Astro configuration file using the `experimental` property, allowing users to try out new features and participate in feature development by reporting issues and sharing opinions. The `experimental` property is defined in the `astro.config.mjs` file, where users can specify flags to enable experimental features.",
      "url": "/en/reference/experimental-flags/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "experimental flags",
        "configuring",
        "experimental",
        "flags"
      ],
      "type": "guide"
    },
    {
      "id": "tutorial/6-islands/3",
      "language": "en",
      "filePath": "src/content/docs/en/tutorial/6-islands/3.mdx",
      "title": "Congratulations!",
      "summary": "**Astro components are a set of reusable UI components for building web applications, featuring internationalization support and integration with Astro's Starlight components.** **Key features include:** * Integration with Astro's Starlight components, such as CardGrid and LinkCard * Support for internationalization (i18n) through Astro's built-in i18n features * Customizable components, including Box, Checklist, CompletionConfetti, PreCheck, and Button * API access to component props, such as Astro.props and getStaticPaths **Implementation details and use cases include:** * Using Astro components to build reusable UI components for web applications * Integrating Astro components with Starlight components for a consistent design language * Customizing Astro components to fit specific design and functionality needs * Using Astro's i18n features to support multiple languages and regions.",
      "url": "/en/tutorial/6-islands/3/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "6 islands",
        "congratulations!"
      ],
      "type": "tutorial"
    },
    {
      "id": "reference/errors/mixed-content-data-collection-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/mixed-content-data-collection-error.mdx",
      "title": "Content and data cannot be in same collection.",
      "summary": "**Legacy Content Collections** Legacy content collections in Astro cannot contain a mix of content and data entries, requiring separate collections by type to avoid **MixedContentDataCollectionError**. This is enforced by the **COLLECTION_NAME** validation, which checks for consistent entry types. To resolve, migrate legacy collections to separate content and data collections, as outlined in the [Legacy content collections](/en/guides/upgrade-to/v5/#updating-existing-collections) guide.",
      "url": "/en/reference/errors/mixed-content-data-collection-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "data",
        "cannot",
        "same",
        "collection."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/markdown-content-schema-validation-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/markdown-content-schema-validation-error.mdx",
      "title": "Content collection frontmatter invalid.",
      "summary": "**Content collection frontmatter validation** Content collection frontmatter validation ensures that Markdown documents in `src/content/` conform to their collection schema. This involves checking for required fields and correct data types, such as `title` and `date`, against the schema defined in `src/content/config.*`. The `getStaticPaths` API and `Astro.props` can be used to validate frontmatter in content collections.",
      "url": "/en/reference/errors/markdown-content-schema-validation-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "collection",
        "frontmatter",
        "invalid."
      ],
      "type": "guide"
    },
    {
      "id": "guides/content-collections",
      "language": "en",
      "filePath": "src/content/docs/en/guides/content-collections.mdx",
      "title": "Content collections",
      "summary": "**Content collections are a feature in Astro that enables managing sets of content, organizing and querying documents, and providing automatic TypeScript type-safety.** **Key features and APIs:** * Define collections from structurally similar data * Support for local and remote content loaders * Built-in content loaders for local collections * Custom loader support for remote content * TypeScript type-safety and Intellisense support * APIs: `getStaticPaths`, `Astro.props`, `Content Layer API` **Implementation details and use cases:** * Collections can be defined from local files (Markdown, MDX, Markdoc, YAML, TOML, JSON) or remote data sources * Use cases: managing blog posts, product items, authors, or any data representing multiple items of the same shape * Remote content loaders can fetch data from external sources, such as CMS, databases, or headless payment systems",
      "url": "/en/guides/content-collections/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "collections"
      ],
      "type": "guide"
    },
    {
      "id": "reference/modules/astro-content",
      "language": "en",
      "filePath": "src/content/docs/en/reference/modules/astro-content.mdx",
      "title": "Content Collections API Reference",
      "summary": "**Content Collections API Reference** Content collections offer APIs to configure and query Markdown or MDX documents in `src/content/`. The `defineCollection()` function is a utility to configure a collection in a `src/content.config.*` file, accepting `loader` and `schema` properties. **Key Features and APIs** * `defineCollection()`: configures a collection in a `src/content.config.*` file * `loader`: a function or object to load data from any source into content collections * `schema`: an optional Zod object to configure the type and shape of document frontmatter * `getCollection()`, `getEntry()`, `getEntries()`, `reference()`, and `render()` APIs for querying and rendering content collections **Implementation Details and Use Cases** * Use `defineCollection()` to configure a collection in a `src/content.config.*` file * Implement a `loader` function or object to load data from any source into content collections * Use `schema` to configure the type and shape of document frontmatter for a collection * Utilize `getCollection()`, `getEntry()`, `getEntries()`, `reference()`, and `render()` APIs to query and render content collections in your Astro application.",
      "url": "/en/reference/modules/astro-content/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "modules",
        "collections"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/content-entry-data-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/content-entry-data-error.mdx",
      "title": "Content entry data does not match schema.",
      "summary": "**Content Entry Validation** Content entry data validation ensures that content entries conform to their respective collection schema. The validation process checks for required fields and correct data types, such as \"title\" being required and \"date\" being a valid date. This is achieved through the `src/content.config.*` file, which defines the collection schema, and can be referenced in the [Content collections documentation](/en/guides/content-collections/).",
      "url": "/en/reference/errors/content-entry-data-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "entry",
        "data",
        "does",
        "match"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/invalid-content-entry-data-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/invalid-content-entry-data-error.mdx",
      "title": "Content entry data does not match schema.",
      "summary": "**Content Entry Validation** Content entry data validation ensures that content entries conform to their respective collection schema. The validation process checks for required fields and correct data types, such as date formats. This is achieved through the `src/content.config.*` file, where collection schema definitions are stored.",
      "url": "/en/reference/errors/invalid-content-entry-data-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "entry",
        "data",
        "does",
        "match"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/invalid-content-entry-frontmatter-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/invalid-content-entry-frontmatter-error.mdx",
      "title": "Content entry frontmatter does not match schema.",
      "summary": "**Content Entry Validation** Content entry frontmatter validation ensures that Markdown or MDX entries conform to their collection schema. The `validateFrontmatter` function checks for required fields and correct data types, such as `title` and `date`, against the schema defined in `src/content.config.*` files. This validation is critical for maintaining data integrity and consistency across content collections.",
      "url": "/en/reference/errors/invalid-content-entry-frontmatter-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "entry",
        "frontmatter",
        "does",
        "match"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/content-loader-invalid-data-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/content-loader-invalid-data-error.mdx",
      "title": "Content entry is missing an ID",
      "summary": "**Content entry is missing an ID** Astro components require a unique ID field in the returned data from inline loaders to function correctly. Key features include: `id` field validation, array or object data return types, and error handling for missing `id` properties. Implementation details involve checking for `id` fields in returned data, with use cases including content collection loaders and Astro component rendering.",
      "url": "/en/reference/errors/content-loader-invalid-data-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "entry",
        "missing"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/content-loader-returns-invalid-id",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/content-loader-returns-invalid-id.mdx",
      "title": "Content loader returned an entry with an invalid id.",
      "summary": "**Content Loader Error Handling** Content loaders in Astro are designed to fetch and render content from collections, but may return entries with invalid IDs, causing errors. Specifically, the `id` property of an entry must be a string, and any mismatch can lead to errors. The `id` validation is crucial for proper content rendering, and developers should ensure that the `id` is correctly set in their content collections.",
      "url": "/en/reference/errors/content-loader-returns-invalid-id/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "loader",
        "returned",
        "entry",
        "with"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/content-schema-contains-slug-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/content-schema-contains-slug-error.mdx",
      "title": "Content Schema should not contain slug.",
      "summary": "**Content Schema should not contain slug.** A content collection schema should not contain `slug` since it is reserved for slug generation. Remove this from your COLLECTION_NAME collection schema. The `slug` field is reserved by Astro for generating entry slugs, but you can still use custom slugs in your frontmatter.",
      "url": "/en/reference/errors/content-schema-contains-slug-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "schema",
        "should",
        "contain",
        "slug."
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/contentful",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/contentful.mdx",
      "title": "Contentful & Astro",
      "summary": "**Contentful & Astro Integration** Astro components are designed to integrate with Contentful, a headless CMS, to manage and publish content to multiple platforms. **Key Features and APIs** * Utilize the Contentful SDK to connect Contentful spaces to Astro with zero client-side JavaScript. * Use environment variables to store Contentful credentials, including space ID, delivery access token, and preview access token. * Leverage Astro's built-in support for internationalization (i18n) to manage content in multiple languages. **Implementation Details and Use Cases** * Create an `.env` file to store Contentful credentials, such as `CONTENTFUL_SPACE_ID`, `CONTENTFUL_DELIVERY_TOKEN`, and `CONTENTFUL_PREVIEW_TOKEN`. * Use Contentful SDK to fetch and render content in Astro components, such as `FileTree` and `PackageManagerTabs`. * Integrate with other services and publish to multiple platforms using Contentful's API.",
      "url": "/en/guides/cms/contentful/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "contentful",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "contribute",
      "language": "en",
      "filePath": "src/content/docs/en/contribute.mdx",
      "title": "Contribute to Astro",
      "summary": "**Astro Contribution Framework** Astro components are designed to facilitate contributions to the Astro project, enabling developers to contribute code, content, and ideas to various repositories. **Key Features and APIs** * `ContributorList` component for showcasing contributors * `CONTRIBUTING.md` file in each repository for contribution guidelines * `README` files in each repository with links to `CONTRIBUTING.md` * GitHub profile for Astro with links to various repositories * APIs for contributing to Astro Docs, compiler, language tools, Starlight, and Roadmap **Implementation Details and Use Cases** * Contribution repositories include Astro codebase, Docs, compiler, language tools, Starlight, and Roadmap * Types of contributions include code, content, review comments, and ideas * Governance doc outlines roles, maintainer nomination processes, code review processes, and Code of Conduct enforcement **Technical Keywords** * Open-source project * Contribution guidelines * GitHub profile * Repository management * Code review processes * Code of Conduct enforcement",
      "url": "/en/contribute/",
      "keywords": [
        "content",
        "docs",
        "contribute",
        "astro"
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/cosmic",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/cosmic.mdx",
      "title": "Cosmic & Astro",
      "summary": "**Cosmic & Astro Integration** Cosmic & Astro is a headless CMS integration that enables content management and API-driven frontend development. Key features include: * **Cosmic JavaScript SDK**: Fetch data from Cosmic Bucket using `@cosmicjs/sdk` package. * **API Keys**: Configure API keys in `.env` file with `BUCKET_SLUG` and `BUCKET_READ_KEY` variables. * **Astro Components**: Utilize Astro components such as `PackageManagerTabs`, `Grid`, `Card`, and `Steps` from `@astrojs/starlight/components`. Implementation details include installing the Cosmic JavaScript SDK using npm, pnpm, or yarn, and configuring API keys in a `.env` file. Use cases include building a headless CMS theme with Tailwind CSS and integrating with Astro projects.",
      "url": "/en/guides/cms/cosmic/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "cosmic",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "reference/errors/missing-sharp",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/missing-sharp.mdx",
      "title": "Could not find Sharp.",
      "summary": "**Astro image processing is enabled by Sharp, a default image service.** Sharp must be installed manually into the project using a package manager like pnpm, or an alternative image service can be configured using `passthroughImageService()`. This can be achieved by setting the `image.service` option in the Astro configuration to `passthroughImageService()`, as shown in the following code snippet: ```js import { defineConfig, passthroughImageService } from \"astro/config\"; export default defineConfig({ image: { service: passthroughImageService(), }, }); ``` **Searchable keywords:** Astro, image processing, Sharp, image service, passthroughImageService, pnpm, package manager.",
      "url": "/en/reference/errors/missing-sharp/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "could",
        "find",
        "sharp."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/failed-to-load-module-ssr",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/failed-to-load-module-ssr.mdx",
      "title": "Could not import file.",
      "summary": "**Astro components are unable to import files due to incorrect paths or type import issues.** **Key Features and APIs:** * `FailedToLoadModuleSSR` error message indicates import path errors or type import issues * Import path errors can be caused by non-existent files or typos * Type import issues occur when importing types without specifying type imports **Implementation Details and Use Cases:** * Verify import paths and file existence to resolve errors * Use type imports correctly to avoid import issues * Refer to Astro guides for type import best practices",
      "url": "/en/reference/errors/failed-to-load-module-ssr/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "could",
        "import",
        "file."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/no-image-metadata",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/no-image-metadata.mdx",
      "title": "Could not process image metadata.",
      "summary": "Astro components are unable to process image metadata due to corrupted or malformed image files, often resolved by re-exporting the image from the editor. Key features and APIs include Astro's image processing capabilities, Astro.props, and potential use of getStaticPaths for image metadata retrieval. Implementation details involve Astro's image metadata parsing and error handling mechanisms.",
      "url": "/en/reference/errors/no-image-metadata/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "could",
        "process",
        "image",
        "metadata."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/could-not-transform-image",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/could-not-transform-image.mdx",
      "title": "Could not transform image.",
      "summary": "**Astro image transformation error handling** Astro components are designed to handle image transformation errors, providing a `CouldNotTransformImage` component to display error messages and stack traces. Key features include error message display, stack trace analysis, and integration with image services. The `CouldNotTransformImage` component can be used to handle corrupted or malformed images, with implementation details including error message formatting and stack trace parsing.",
      "url": "/en/reference/errors/could-not-transform-image/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "could",
        "transform",
        "image."
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/craft-cms",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/craft-cms.mdx",
      "title": "Craft CMS & Astro",
      "summary": "**Craft CMS & Astro Integration** Craft CMS is a flexible open source CMS that can be used as a headless CMS to provide content to Astro projects, enabling internationalization and ready for use with Astro's static site generation (SSG) and server-side rendering (SSR) capabilities. Key features include: * Utilizing Craft CMS's GraphQL API to fetch content at build time or cache in advance * Configuring Craft CMS's `headlessMode` setting to enable headless CMS functionality * Integrating with Astro's `getStaticPaths` and `Astro.props` APIs to fetch and render Craft CMS content Implementation details and use cases include: * Using Craft CMS as a headless CMS to provide content to Astro projects * Fetching content at build time or caching in advance using Craft CMS's GraphQL API * Configuring Craft CMS's `headlessMode` setting to enable headless CMS functionality in Astro projects",
      "url": "/en/guides/cms/craft-cms/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "craft",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "tutorial/5-astro-api/1",
      "language": "en",
      "filePath": "src/content/docs/en/tutorial/5-astro-api/1.mdx",
      "title": "Create a blog post archive",
      "summary": "Here is the technical documentation summary: **Create a blog post archive** Astro components are used to dynamically display a list of blog posts on the Blog page, utilizing `import.meta.glob()` to access data from all Markdown files at once. **Key Features and APIs** * `import.meta.glob()` API to import Markdown files * `Object.values()` method to extract post metadata * Astro components: `BaseLayout`, `ul`, `li`, `a` * Dynamic list generation using Astro code **Implementation Details and Use Cases** * Refactor `blog.astro` to return post information using `import.meta.glob()` * Replace individual `` tags with Astro code to generate dynamic list of posts * Use `pageTitle` and `allPosts` variables to customize blog page content",
      "url": "/en/tutorial/5-astro-api/1/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "5 astro api",
        "create",
        "blog",
        "post",
        "archive"
      ],
      "type": "tutorial"
    },
    {
      "id": "recipes/making-toolbar-apps",
      "language": "en",
      "filePath": "src/content/docs/en/recipes/making-toolbar-apps.mdx",
      "title": "Create a dev toolbar app",
      "summary": "**Astro components are used to create custom dev toolbar apps for site development and inspection.** **Key features and APIs include:** * `astro:config:setup` hook for Astro Integrations * Custom app creation using `app.ts` and integration files * Use of Astro components, such as `PackageManagerTabs` and `FileTree`, for app development * Integration with Astro's development toolbar for site inspection and debugging **Implementation details and use cases include:** * Creating a new Astro project with the `toolbar-app` template * Building a custom dev toolbar app from scratch using Astro Integrations and the `astro:config:setup` hook * Adding custom apps to the Astro development toolbar for site development and inspection",
      "url": "/en/recipes/making-toolbar-apps/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "create",
        "toolbar"
      ],
      "type": "recipe"
    },
    {
      "id": "tutorial/3-components/2",
      "language": "en",
      "filePath": "src/content/docs/en/tutorial/3-components/2.mdx",
      "title": "Create a social media footer",
      "summary": "**Create a Social Media Footer** Astro components are used to create a reusable Footer component that can be imported and used across multiple pages. **Key Features and APIs:** * Importing and using Astro components (`Footer.astro`) * Passing props to a Social Media component (`platform` and `username` props) * Using Astro's built-in `Steps` component for tutorial guidance * Implementing internationalization (i18n) support **Implementation Details and Use Cases:** * Creating a new file for the Footer component (`src/components/Footer.astro`) * Importing and using the Footer component in multiple Astro pages (`index.astro`, `about.astro`, and `blog.astro`) * Customizing the footer to display multiple social networks and include a username link.",
      "url": "/en/tutorial/3-components/2/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "3 components",
        "create",
        "social",
        "media",
        "footer"
      ],
      "type": "tutorial"
    },
    {
      "id": "tutorial/4-layouts/2",
      "language": "en",
      "filePath": "src/content/docs/en/tutorial/4-layouts/2.mdx",
      "title": "Create and pass data to a custom blog layout",
      "summary": "**Create and pass data to a custom blog layout** Astro components are used to create a custom blog layout that can be applied to Markdown files, allowing for dynamic rendering of frontmatter values as props. The `layout` frontmatter property is used to specify the layout file, and Astro's `Astro.props` API is utilized to access and render frontmatter values, such as `title`, `author`, and `image`. This implementation enables the creation of reusable layouts for blog posts, with use cases including internationalization and dynamic content rendering.",
      "url": "/en/tutorial/4-layouts/2/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "4 layouts",
        "create",
        "pass",
        "data",
        "custom"
      ],
      "type": "tutorial"
    },
    {
      "id": "tutorial/2-pages/1",
      "language": "en",
      "filePath": "src/content/docs/en/tutorial/2-pages/1.mdx",
      "title": "Create your first Astro page",
      "summary": "**Create your first Astro page** Astro components are used to build web pages, and can be created by importing and rendering Astro components, such as `Checklist`, `Blanks`, `Box`, and `PreCheck`, within an `.astro` file. The `Steps` component from `@astrojs/starlight/components` can be used to guide the user through a series of steps. The `getStaticPaths` method is not explicitly mentioned, but Astro's page generation capabilities are used to render the page at build time.",
      "url": "/en/tutorial/2-pages/1/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "2 pages",
        "create",
        "your",
        "first",
        "astro"
      ],
      "type": "tutorial"
    },
    {
      "id": "tutorial/1-setup/2",
      "language": "en",
      "filePath": "src/content/docs/en/tutorial/1-setup/2.mdx",
      "title": "Create your first Astro project",
      "summary": "Here is the technical documentation summary: **Create your first Astro project** Astro components are used to create a new Astro project using the `create astro` setup wizard, which includes features such as `npm create astro@latest`, `pnpm create astro@latest`, and `yarn create astro` commands, as well as APIs like `Steps` and `PackageManagerTabs` for interactive tutorials and package manager integration. The implementation details include running the setup wizard, installing dependencies, and choosing a starter template. Use cases include creating a new Astro project from scratch, installing dependencies, and selecting a starter template.",
      "url": "/en/tutorial/1-setup/2/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "1 setup",
        "create",
        "your",
        "first",
        "astro"
      ],
      "type": "tutorial"
    },
    {
      "id": "guides/cms/crystallize",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/crystallize.mdx",
      "title": "Crystallize & Astro",
      "summary": "Crystallize & Astro integrates Crystallize, a headless eCommerce CMS, with Astro, a framework for building fast and scalable websites. Key features include: * Fetching catalogue paths and data from Crystallize's GraphQL API using `createClient` and `catalogueApi` methods * Utilizing Astro's `getStaticPaths` and `Astro.props` to render dynamic content * Implementing internationalization support for multilingual websites Example use cases include building eCommerce websites with dynamic product catalogs, integrating with Crystallize's API to fetch product data, and rendering catalogue paths and names in Astro components.",
      "url": "/en/guides/cms/crystallize/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "crystallize",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "reference/errors/csp-not-enabled",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/csp-not-enabled.mdx",
      "title": "CSP feature isnt enabled",
      "summary": "Astro components are affected by the experimental Content Security Policy (CSP) feature, which is not enabled by default. The `experimental.csp` configuration is not set, resulting in the CSP feature being disabled. This is indicated by the presence of the `DontEditWarning` component, which is rendered when the CSP feature is not enabled.",
      "url": "/en/reference/errors/csp-not-enabled/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "feature",
        "isnt",
        "enabled"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/csssyntax-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/csssyntax-error.mdx",
      "title": "CSS Syntax Error.",
      "summary": "**CSS Syntax Error Handling** Astro components are designed to handle CSS syntax errors, providing error messages for missed semicolons and unclosed strings. Key features include error detection via `CSSSyntaxError` and output of specific error messages, such as \"Missed semicolon\" and \"Unclosed string\". Implementation details involve parsing CSS and identifying syntax errors, with use cases including debugging and troubleshooting CSS code in Astro components.",
      "url": "/en/reference/errors/csssyntax-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "syntax",
        "error."
      ],
      "type": "guide"
    },
    {
      "id": "recipes/customizing-output-filenames",
      "language": "en",
      "filePath": "src/content/docs/en/recipes/customizing-output-filenames.mdx",
      "title": "Customize file names in the build output",
      "summary": "**Customize file names in the build output** Astro components are customizable to change the default naming pattern for built assets like JavaScript, CSS, and images using Vite Rollup options. Specific features include: - `vite.build.rollupOptions.output` configuration - `entryFileNames`, `chunkFileNames`, and `assetFileNames` options - Custom naming patterns for JavaScript entry files, code-split chunks, and other assets Implementation details include modifying `astro.config.mjs` to include custom Rollup output options, using `dist/js/[name]-[hash].js` for JavaScript entry files, `dist/js/chunks/[name]-[hash].js` for code-split chunks, and `dist/static/[name]-[hash][extname]` for other assets.",
      "url": "/en/recipes/customizing-output-filenames/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "customize",
        "file",
        "names",
        "build"
      ],
      "type": "recipe"
    },
    {
      "id": "reference/errors/data-collection-entry-parse-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/data-collection-entry-parse-error.mdx",
      "title": "Data collection entry failed to parse.",
      "summary": "**Data Collection Entry Failed to Parse** Astro components are unable to parse collection entries of type 'data' due to invalid JSON, YAML, or TOML formatting. Specifically, the issue occurs when the `COLLECTION_ENTRY_NAME` fails to return a valid object, which is required for Astro to process data collection entries. This can be resolved by ensuring that collection entries return a valid JSON, YAML, or TOML object.",
      "url": "/en/reference/errors/data-collection-entry-parse-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "data",
        "collection",
        "entry",
        "failed"
      ],
      "type": "guide"
    },
    {
      "id": "guides/data-fetching",
      "language": "en",
      "filePath": "src/content/docs/en/guides/data-fetching.mdx",
      "title": "Data fetching",
      "summary": "**Data Fetching in Astro** Astro components can fetch remote data using the global `fetch()` function in their component script, making HTTP requests to APIs using full URLs. This allows for dynamic data generation in HTML, with data available at build time or runtime depending on SSR mode. Key features include top-level `await` support, passing fetched data to components as props, and using `new URL()` to construct URLs to project pages and endpoints.",
      "url": "/en/guides/data-fetching/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "data",
        "fetching"
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/datocms",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/datocms.mdx",
      "title": "DatoCMS & Astro",
      "summary": "**DatoCMS & Astro Integration** Astro components are integrated with DatoCMS to fetch and display content data from a headless CMS in an Astro project. **Key Features and APIs** * `DATOCMS_API_KEY` environment variable for API key management * `env.d.ts` file for TypeScript support and type declaration * `Steps` and `FileTree` components from `@astrojs/starlight/components` * `getStaticPaths` and `Astro.props` for content fetching and rendering **Implementation Details and Use Cases** * Create a `.env` file in the project root to store the DatoCMS API key * Declare the `DATOCMS_API_KEY` environment variable in `env.d.ts` for TypeScript support * Create a Model in DatoCMS for content management * Fetch and display content data using Astro components and DatoCMS API",
      "url": "/en/guides/cms/datocms/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "datocms",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/cms/decap-cms",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/decap-cms.mdx",
      "title": "Decap CMS & Astro",
      "summary": "**Decap CMS & Astro** Decap CMS is a Git-based content management system that integrates with Astro, enabling image optimization and content collections. It adds a route to your project for authorized users to manage content directly from the deployed website, committing changes to your Astro project's source repository. **Key Features and APIs** * `npm install decap-cms-app` or `yarn add decap-cms-app` for installation * `` for manual import * `config.yml` configuration file for content collections and schema definition * `public/admin/` folder for static admin content * `getStaticPaths` and `Astro.props` for Astro integration **Implementation Details and Use Cases** Decap CMS is designed for Astro projects, allowing users to manage content directly from the deployed website. It supports content collections and schema definition through `config.yml`. The `public/admin/` folder is used for static admin content, and the `getStaticPaths` and `Astro.props` APIs are used for Astro integration.",
      "url": "/en/guides/cms/decap-cms/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "decap",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/deploy/index",
      "language": "en",
      "filePath": "src/content/docs/en/guides/deploy/index.mdx",
      "title": "Deploy your Astro Site",
      "summary": "**Deploying Astro Sites** Astro components are designed to be easily deployable to the web using various deployment services and continuous integration/continuous deployment (CI/CD) pipelines. Key features include: * Integration with popular deployment services such as Netlify and Vercel * Support for continuous deployment using Git providers like GitHub, GitLab, and Bitbucket * Automatic detection of Astro projects and configuration of build and deployment settings Implementation details include: * Using the `astro build` command or `npm run build` to build the site * Publishing the site to a `dist` directory * Configuring deployment settings in the host's dashboard or CLI Use cases include: * Deploying Astro sites to custom domains or subdomains * Integrating with CI/CD pipelines for automated testing and deployment * Using deployment services for features like SSL encryption and caching.",
      "url": "/en/guides/deploy/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site"
      ],
      "type": "guide"
    },
    {
      "id": "guides/deploy/aws",
      "language": "en",
      "filePath": "src/content/docs/en/guides/deploy/aws.mdx",
      "title": "Deploy your Astro Site to AWS",
      "summary": "**Deploying Astro Sites to AWS** Astro sites can be deployed to AWS using AWS Amplify, S3 static website hosting, and CloudFront. **Key Features and APIs** * `amplify hosting` CLI command for creating and managing Amplify Hosting projects * `amplify connect` command for connecting repositories to Amplify * `amplify update` command for modifying build settings * `pnpm` and `npm` package managers for managing dependencies * `S3 static website hosting` for hosting static sites * `CloudFront` for distributing static sites globally **Implementation Details and Use Cases** * Create a new Amplify Hosting project using the `amplify hosting` CLI command * Connect your repository to Amplify using the `amplify connect` command * Modify your build settings to match your project's build process using the `amplify update` command * Use `pnpm` or `npm` to manage dependencies and build your Astro site * Host your static site on S3 and distribute it globally using CloudFront",
      "url": "/en/guides/deploy/aws/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/flightcontrol",
      "language": "en",
      "filePath": "src/content/docs/en/guides/deploy/flightcontrol.mdx",
      "title": "Deploy your Astro Site to AWS with Flightcontrol",
      "summary": "**Deploying Astro Sites to AWS with Flightcontrol** Astro sites can be deployed to AWS using Flightcontrol, a fully-automated deployment tool, supporting both static and Server-Side Rendering (SSR) Astro sites. Key features include: * Integration with GitHub for repository connection * Support for GUI and infrastructure-as-code (flightcontrol.json) configurations * Configuration options for Astro Static and Astro SSR presets * Automated deployment to AWS with optional SSR setup using the `@astrojs/node` adapter. Implementation details involve creating a Flightcontrol account, connecting a GitHub repository, selecting a configuration type, and adjusting settings as needed.",
      "url": "/en/guides/deploy/flightcontrol/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "with"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/sst",
      "language": "en",
      "filePath": "src/content/docs/en/guides/deploy/sst.mdx",
      "title": "Deploy your Astro Site to AWS with SST",
      "summary": "**Deploying Astro Sites to AWS with SST** Astro sites can be deployed to AWS using SST, an open-source framework for deploying modern full-stack applications with SSG and SSR support. Key features include automatic detection of Astro projects, type-safe integration with SST components, and support for additional components like cron jobs, Buckets, and Queues. The deployment process involves initializing an SST project, configuring SST components in `sst.config.ts`, and accessing linked resources in `.astro` files.",
      "url": "/en/guides/deploy/sst/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "with"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/azion",
      "language": "en",
      "filePath": "src/content/docs/en/guides/deploy/azion.mdx",
      "title": "Deploy your Astro Site to Azion",
      "summary": "**Deploying Astro Sites to Azion** Astro components are deployable to Azion, a platform for frontend developers to collaborate and deploy static (JAMstack) and SSR websites, using the Azion CLI or Azion Console Dashboard. **Key Features and APIs** * `azion deploy` command for deploying Astro sites using the Azion CLI * Azion Console Dashboard for manual deployment * GitHub repository integration for importing code * Framework preset selection (e.g., `Astro`) for build settings * Root Directory and Install Command configuration for deployment **Implementation Details and Use Cases** * Deploying Astro sites to Azion using the Azion CLI or Azion Console Dashboard * Integrating GitHub repositories for code import * Configuring build settings for static site generation and deployment * Monitoring deployment using Azion Real-Time Metrics",
      "url": "/en/guides/deploy/azion/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "azion"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/clever-cloud",
      "language": "en",
      "filePath": "src/content/docs/en/guides/deploy/clever-cloud.mdx",
      "title": "Deploy your Astro Site to Clever Cloud",
      "summary": "**Deploying Astro Sites to Clever Cloud** Astro components are deployable to Clever Cloud, a European cloud platform, using automated, scalable services. Key features include support for both static and on-demand rendered Astro projects, with options to deploy as a static application or a Node.js application. Clever Cloud provides a console-based deployment process, allowing users to create new applications, configure instance sizes, and set up scalability options. **APIs and Methods** * `getStaticPaths` * `Astro.props` * `start` script for on-demand Node.js applications * Environment variables for Node.js applications **Implementation Details** * Project configuration for static and on-demand rendered Astro projects * Post-build hook for static applications * Manual configuration in `package.json` for Node.js applications * Instance size and scalability options in Clever Cloud console **Use Cases** * Deploying fully static Astro projects * Deploying on-demand rendered Astro projects * Configuring instance sizes and scalability options in Clever Cloud console",
      "url": "/en/guides/deploy/clever-cloud/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "clever"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/cloudflare",
      "language": "en",
      "filePath": "src/content/docs/en/guides/deploy/cloudflare.mdx",
      "title": "Deploy your Astro Site to Cloudflare",
      "summary": "**Deploying Astro Sites to Cloudflare** Astro sites can be deployed to Cloudflare using Cloudflare Workers or Cloudflare Pages, enabling full-stack application deployment and on-demand rendered sites. **Key Features and APIs** * `wrangler CLI` for deploying with Cloudflare Workers * `@astrojs/cloudflare` adapter for on-demand rendering * `astro.config.mjs` file modifications for Cloudflare integration * `.assetsignore` file for excluding worker files **Implementation Details and Use Cases** * Deploy full-stack applications and on-demand rendered sites to Cloudflare Workers or Cloudflare Pages * Use Wrangler CLI for deployment with Cloudflare Workers * Utilize `@astrojs/cloudflare` adapter for on-demand rendering * Modify `astro.config.mjs` file for Cloudflare integration * Create `.assetsignore` file to exclude worker files",
      "url": "/en/guides/deploy/cloudflare/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "cloudflare"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/fleek",
      "language": "en",
      "filePath": "src/content/docs/en/guides/deploy/fleek.mdx",
      "title": "Deploy your Astro Site to Fleek",
      "summary": "**Deploying Astro Sites to Fleek** Astro sites can be deployed to Fleek's edge-optimized decentralized network using the Fleek UI or CLI. **Key Features and APIs** * `fleek login`: logs in to the Fleek account from the terminal * `npm run build`: generates static files in the `dist/` directory * `fleek sites init`: initializes the project and generates a configuration file * `fleek sites deploy`: deploys the site to Fleek **Implementation Details and Use Cases** * Deploying a static Astro site to Fleek using the Fleek UI involves creating a Fleek account, pushing code to a Git repository, importing the project into Fleek, and configuring settings. * Deploying using the Fleek CLI involves installing the CLI, logging in to the account, running the build command, initializing the project, and deploying the site. * Fleek supports internationalization and provides a decentralized network for hosting static sites.",
      "url": "/en/guides/deploy/fleek/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "fleek"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/flyio",
      "language": "en",
      "filePath": "src/content/docs/en/guides/deploy/flyio.mdx",
      "title": "Deploy your Astro Site to Fly.io",
      "summary": "**Deploying Astro Sites to Fly.io** Astro components are deployable to Fly.io, a platform for running full stack apps and databases close to users, using the Fly.io CLI tool `flyctl`. **Key Features and APIs** * Supports static site deployment with no extra configuration * Enables on-demand rendering with the Node.js adapter * Uses `fly launch` command to detect Astro, configure settings, build image, and deploy to Fly.io * Generates Dockerfile and `fly.toml` file for pages rendered on demand * Integrates with `dockerfile` generator for custom Dockerfile creation **Implementation Details and Use Cases** * Deploy Astro projects as static sites or server-side rendered sites (SSR) * Use `fly launch` command to automate deployment process * Generate Dockerfile and `fly.toml` file for on-demand rendering * Integrate with Fly.io CLI tool `flyctl` for app management",
      "url": "/en/guides/deploy/flyio/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "fly.io"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/github",
      "language": "en",
      "filePath": "src/content/docs/en/guides/deploy/github.mdx",
      "title": "Deploy your Astro Site to GitHub Pages",
      "summary": "**Deploying Astro Sites to GitHub Pages** Astro components are used to deploy Astro sites to GitHub Pages using GitHub Actions for automated build and deployment. Key features include the `withastro/action` package for streamlined configuration and the `.nojekyll` file to prevent Jekyll processing on GitHub Pages. **APIs and Methods** * `withastro/action` package for GitHub Actions deployment * `.nojekyll` file to disable Jekyll processing * `site` and `base` options in `astro.config.mjs` for customizing deployment **Implementation Details and Use Cases** * Add an empty `.nojekyll` file to the `public/` directory to prevent Jekyll processing * Set `site` and `base` options in `astro.config.mjs` for customizing deployment to a `github.io` URL * Use GitHub Actions for automated build and deployment with the `withastro/action` package",
      "url": "/en/guides/deploy/github/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "github"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/gitlab",
      "language": "en",
      "filePath": "src/content/docs/en/guides/deploy/gitlab.mdx",
      "title": "Deploy your Astro Site to GitLab Pages",
      "summary": "**Deploying Astro Sites to GitLab Pages** Astro components are used to deploy Astro sites to the web using GitLab Pages, a feature of GitLab that allows hosting static websites for projects, groups, or user accounts. Key features and APIs include: * `site` and `base` options in `astro.config.mjs` for configuring site and base URLs * `outDir` and `publicDir` options for specifying output and public directories * GitLab CI/CD integration for automated building and deployment Implementation details include: * Setting up `site` and `base` options in `astro.config.mjs` with specific values for GitLab Pages * Configuring `outDir` and `publicDir` options for output and public directories * Using GitLab CI/CD to automate building and deployment of Astro sites Use cases include: * Hosting Astro sites for GitLab projects, groups, or user accounts * Configuring custom domains for Astro sites on GitLab Pages * Automating deployment of Astro sites using GitLab CI/CD",
      "url": "/en/guides/deploy/gitlab/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "gitlab"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/google-cloud",
      "language": "en",
      "filePath": "src/content/docs/en/guides/deploy/google-cloud.mdx",
      "title": "Deploy your Astro Site to Google Cloud",
      "summary": "**Deploying Astro Sites to Google Cloud** Astro sites can be deployed to Google Cloud using Cloud Storage for static sites or Cloud Run for server-side rendering (SSR) and static sites. **Key Features and APIs** * `dist` folder upload to Cloud Storage * Cloud Build integration for automated uploads * Cloud Run API for serverless deployment * Dockerfile creation for containerization * Artifact Registry for image storage and management **Implementation Details and Use Cases** * Deploy static Astro sites to Cloud Storage using Cloud Build and public access permissions * Deploy SSR and static Astro sites to Cloud Run using a Dockerfile and Artifact Registry * Use Cloud Run API to enable serverless deployment and scaling",
      "url": "/en/guides/deploy/google-cloud/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "google"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/google-firebase",
      "language": "en",
      "filePath": "src/content/docs/en/guides/deploy/google-firebase.mdx",
      "title": "Deploy your Astro Site to Google’s Firebase Hosting",
      "summary": "**Deploying Astro Sites to Google's Firebase Hosting** Astro sites can be deployed to Google's Firebase Hosting as static sites or server-side rendered (SSR) sites using the Firebase CLI and Node.js adapter. **Key Features and APIs:** * Firebase CLI installation and authentication * Static site deployment without extra configuration * SSR deployment with Node.js adapter and Blaze plan * Support for internationalization **Implementation Details and Use Cases:** * Static site deployment: default Astro project configuration * SSR deployment: requires Node.js adapter and Blaze plan * Firebase CLI installation: npm, pnpm, or yarn package managers supported",
      "url": "/en/guides/deploy/google-firebase/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "google’s"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/heroku",
      "language": "en",
      "filePath": "src/content/docs/en/guides/deploy/heroku.mdx",
      "title": "Deploy your Astro Site to Heroku",
      "summary": "**Deploying Astro Sites to Heroku** Astro sites can be deployed to Heroku using the Heroku CLI and a `static.json` configuration file. Key features include: * Using the Heroku CLI to create and manage Heroku apps * Configuring the `static.json` file to specify the root directory of the Astro site * Setting up the Heroku git remote and buildpack for static sites * Deploying the site using `git push heroku master` and opening the Heroku app in a browser using `heroku open` Implementation details include using the `heroku-buildpack-static` buildpack and configuring the `static.json` file to specify the root directory of the Astro site. Use cases include deploying Astro sites to Heroku for production and development environments.",
      "url": "/en/guides/deploy/heroku/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "heroku"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/kinsta",
      "language": "en",
      "filePath": "src/content/docs/en/guides/deploy/kinsta.mdx",
      "title": "Deploy your Astro Site to Kinsta Application Hosting",
      "summary": "**Deploying Astro Sites to Kinsta Application Hosting** Astro sites can be deployed to Kinsta Application Hosting using a combination of Astro's built-in features and Kinsta's cloud hosting capabilities. **Key Features and APIs** * `package.json` configuration: `name` field, `build` script, and `start` script setup * `serve` package installation for static hosting * `@astrojs/node` package installation for Server-Side Rendering (SSR) * `astro.config.mjs` configuration for SSR with `host: true` **Implementation Details and Use Cases** * Static hosting: use `serve` package to serve Astro site from `dist/` directory * SSR: use `@astrojs/node` package to run Astro site on Kinsta's cloud hosting * Example projects: Kinsta Application Hosting Starter project for Astro and Astro SSR",
      "url": "/en/guides/deploy/kinsta/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "kinsta"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/microsoft-azure",
      "language": "en",
      "filePath": "src/content/docs/en/guides/deploy/microsoft-azure.mdx",
      "title": "Deploy your Astro Site to Microsoft Azure",
      "summary": "**Deploying Astro Sites to Microsoft Azure** Astro sites can be deployed to Microsoft Azure using the Static Web Apps service, enabling cloud-hosted web applications with internationalization support. Key features and APIs include: * Integration with Azure Static Web Apps service * GitHub Action deployment using `.github` folder * Visual Studio Code extension for Azure Static Web Apps * Support for custom framework presets, including Astro Implementation details include: * Designating Azure subscription key and app name * Choosing framework preset and app root * Configuring GitHub Action for deployment * Viewing app progress in Azure Static Web Apps extension and GitHub Actions tab",
      "url": "/en/guides/deploy/microsoft-azure/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "microsoft"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/netlify",
      "language": "en",
      "filePath": "src/content/docs/en/guides/deploy/netlify.mdx",
      "title": "Deploy your Astro Site to Netlify",
      "summary": "Here is the technical documentation summary: **Deploying Astro Sites to Netlify** Astro sites can be deployed to Netlify as static sites, server-rendered sites, or edge-rendered sites using the Netlify adapter. The deployment process can be done through the Netlify website UI or using Netlify's CLI (command line interface) with the `npx astro add netlify` command. The Netlify adapter can be installed manually or using the `astro add` command, and supports deploying Astro middleware using Netlify's Edge Functions.",
      "url": "/en/guides/deploy/netlify/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "netlify"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/render",
      "language": "en",
      "filePath": "src/content/docs/en/guides/deploy/render.mdx",
      "title": "Deploy your Astro Site to Render",
      "summary": "**Deploying Astro Sites to Render** Astro components are deployable to Render, a service providing free TLS certificates, global CDN, DDoS protection, private networks, and auto deploys from Git. Key features include connecting GitHub or GitLab repositories, specifying build commands (`npm run build`), and publishing directories (`dist` or `dist/client`), with support for static sites and on-demand rendered pages. Implementation involves creating a Render account, connecting a repository, configuring build settings, and creating a static site, with use cases including deploying Astro projects to a global CDN with auto deploys from Git.",
      "url": "/en/guides/deploy/render/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "render"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/stormkit",
      "language": "en",
      "filePath": "src/content/docs/en/guides/deploy/stormkit.mdx",
      "title": "Deploy your Astro Site to Stormkit",
      "summary": "Here is the technical documentation summary: Astro components are deployable to Stormkit, a deployment platform for static websites, SPAs, and serverless functions, using the Astrojs Starlight components and Steps API. Key features include importing projects from supported Git providers, verifying build commands in Stormkit configuration, and deploying sites using the \"Deploy Now\" button. Implementation details involve using Astrojs Starlight components, such as Steps, and leveraging Stormkit's CI capabilities to run custom build commands.",
      "url": "/en/guides/deploy/stormkit/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "stormkit"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/surge",
      "language": "en",
      "filePath": "src/content/docs/en/guides/deploy/surge.mdx",
      "title": "Deploy your Astro Site to Surge",
      "summary": "Astro components are deployable to the web using Surge, a single-command web publishing platform. Key features include integration with the Surge CLI, Astro's build process, and support for custom domains. The deployment process involves installing the Surge CLI globally, building the Astro site using `npm run build`, and deploying to Surge using `surge dist`.",
      "url": "/en/guides/deploy/surge/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "surge"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/vercel",
      "language": "en",
      "filePath": "src/content/docs/en/guides/deploy/vercel.mdx",
      "title": "Deploy your Astro Site to Vercel",
      "summary": "**Deploying Astro Sites to Vercel** Astro components are deployable to Vercel's global edge network with zero configuration using the Vercel adapter. **Key Features and APIs:** * `astro add vercel` command for installing the Vercel adapter * `astro.config.mjs` file configuration for on-demand rendering * Vercel CLI (command line interface) for deployment * Website UI deployment through Git repository import **Implementation Details and Use Cases:** * Static site deployment with zero configuration * On-demand rendering with Vercel adapter installation * Deployment through Vercel CLI or website UI * Integration with Astro middleware using Vercel Edge Functions",
      "url": "/en/guides/deploy/vercel/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "vercel"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/zeabur",
      "language": "en",
      "filePath": "src/content/docs/en/guides/deploy/zeabur.mdx",
      "title": "Deploy your Astro Site to Zeabur",
      "summary": "**Deploying Astro Sites to Zeabur** Astro sites can be deployed to Zeabur as both static and server-side rendered (SSR) applications. To deploy a static Astro site, no extra configuration is required. For SSR, install the `@zeabur/astro-adapter` package and add two lines to the `astro.config.mjs` file to enable the adapter. **Key Features and APIs:** * `@zeabur/astro-adapter` package for SSR support * `astro.config.mjs` file configuration for adapter setup * `defineConfig` function from `astro/config` for project configuration * `output` and `adapter` properties for configuring SSR output **Implementation Details and Use Cases:** * Static Astro sites can be deployed directly to Zeabur without additional configuration * SSR Astro sites require installation of `@zeabur/astro-adapter` and configuration of `astro.config.mjs` * Deployment to Zeabur can be automated through GitHub integration and subsequent pushes to branches will generate new builds.",
      "url": "/en/guides/deploy/zeabur/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "zeabur"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/zerops",
      "language": "en",
      "filePath": "src/content/docs/en/guides/deploy/zerops.mdx",
      "title": "Deploy your Astro Site to Zerops",
      "summary": "**Deploying Astro Sites to Zerops** Astro components are deployable to Zerops, a dev-first cloud platform, using a `zerops.yml` configuration file. Key features include: * Creating a project and service for Astro Static sites using `Project add` wizard or YAML import * Deploying Astro Static sites with `zerops.yml` configuration, specifying build and deploy commands * Support for Static and SSR Astro sites on Zerops Implementation details include: * Using `zerops.yml` to define build and deploy pipeline for Astro sites * Configuring Zerops services for Astro Static and SSR sites * Integrating with Zerops project and service management Use cases include: * Deploying Astro Static sites to Zerops using `zerops.yml` configuration * Creating and managing Zerops projects and services for Astro sites * Running Astro SSR sites on Zerops using Node.js runtime.",
      "url": "/en/guides/deploy/zerops/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "zerops"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/buddy",
      "language": "en",
      "filePath": "src/content/docs/en/guides/deploy/buddy.mdx",
      "title": "Deploy your Astro Site with Buddy",
      "summary": "**Deploying Astro Sites with Buddy** Astro sites can be deployed to the web using Buddy, a CI/CD solution that manages the build process and delivers the result to various deploy targets. Key features include integrating with Node.js actions, executing `npm install` and `npm run build` commands, and configuring deployment actions with a source path set to `dist`. Buddy supports deployment to FTP servers, cloud hosting providers, and more, utilizing its actions catalog for customizable pipeline setup.",
      "url": "/en/guides/deploy/buddy/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "with"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/cleavr",
      "language": "en",
      "filePath": "src/content/docs/en/guides/deploy/cleavr.mdx",
      "title": "Deploy your Astro Site with Cleavr",
      "summary": "**Deploying Astro Sites with Cleavr** Astro sites can be deployed to a Virtual Private Server (VPS) using Cleavr, a server and app deployment management tool, by following a series of steps to add and configure the site. Key features and APIs include: * `Add Site` functionality to create a new application instance * Support for NodeJS Static and NodeJS SSR app types * Configuration options for Artifact Folder, Entry Point, and VC Profile * Deployment management through the Deployments tab Implementation details include: * Setting up a Cleavr account and server on a VPS provider * Configuring site details, such as domain name and app type * Selecting the VC Profile, Repo, and Branch for the Astro project * Making additional configurations as necessary for the project Use cases include: * Deploying Astro sites to a VPS server using Cleavr * Managing deployments and configurations through the Cleavr interface",
      "url": "/en/guides/deploy/cleavr/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "with"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/cloudray",
      "language": "en",
      "filePath": "src/content/docs/en/guides/deploy/cloudray.mdx",
      "title": "Deploy your Astro Site with CloudRay",
      "summary": "**Deploying Astro Sites with CloudRay** CloudRay is a centralized platform for managing servers, organizing Bash scripts, and automating deployment tasks across virtual machines and cloud servers. To deploy an Astro project, users can leverage CloudRay's automation tools to run deployment scripts on their own infrastructure (e.g., Ubuntu servers) using a connected agent. **Key Features and APIs** * CloudRay Agent installation for secure remote automation * Bash script writing for cloning Astro repos, installing dependencies, building sites, and configuring web servers * CloudRay's variable groups for defining repo-specific values * Runlog interface for executing scripts and monitoring deployments in real-time * Integration with Astro's `getStaticPaths` and `Astro.props` APIs **Implementation Details and Use Cases** * Deploying Astro sites on Ubuntu servers using CloudRay's automation tools * Writing reusable Bash scripts for Astro deployment and configuration * Using CloudRay's variable groups to define repo-specific values and automate deployment tasks * Monitoring deployments in real-time using CloudRay's Runlog interface",
      "url": "/en/guides/deploy/cloudray/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "with"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/deno",
      "language": "en",
      "filePath": "src/content/docs/en/guides/deploy/deno.mdx",
      "title": "Deploy your Astro Site with Deno",
      "summary": "Here is the technical documentation summary: **Deploying Astro Sites with Deno** Astro components are deployable as static or on-demand rendered sites using Deno, a JavaScript runtime, on your own server or Deno Deploy, a distributed system that runs JavaScript, TypeScript, and WebAssembly at the edge. Key features include: * Using the `@deno/astro-adapter` adapter to enable on-demand rendering * Configuring `astro.config.mjs` with the `output` and `adapter` settings * Updating `package.json` with a custom `preview` script Implementation details include installing the `@deno/astro-adapter` adapter using npm, pnpm, or yarn, and updating the `astro.config.mjs` file with the `deno()` adapter function. Use cases include deploying static or on-demand rendered Astro sites to Deno Deploy or your own server.",
      "url": "/en/guides/deploy/deno/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "with"
      ],
      "type": "deploy"
    },
    {
      "id": "tutorial/1-setup/5",
      "language": "en",
      "filePath": "src/content/docs/en/tutorial/1-setup/5.mdx",
      "title": "Deploy your site to the web",
      "summary": "**Deploying Astro Sites to the Web** Astro components are used to create interactive tutorials and guides, such as the Checklist, Box, MultipleChoice, Option, and PreCheck components, which are imported and used in the tutorial. Key features and APIs include: * Importing Astro components (e.g., Checklist, Box, MultipleChoice) * Using Netlify's API to create a new site and deploy an Astro project * Utilizing Netlify's site settings and deployment features * Changing project names and updating URLs * Visiting deployed websites using generated URLs Implementation details include using Netlify's authentication and GitHub integration to connect Astro projects to the platform, and utilizing Astro components to create interactive tutorials. Use cases include deploying Astro sites to the web using Netlify, and customizing project settings and URLs.",
      "url": "/en/tutorial/1-setup/5/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "1 setup",
        "deploy",
        "your",
        "site"
      ],
      "type": "tutorial"
    },
    {
      "id": "guides/dev-toolbar",
      "language": "en",
      "filePath": "src/content/docs/en/guides/dev-toolbar.mdx",
      "title": "Dev toolbar",
      "summary": "**Dev Toolbar** The Dev Toolbar is a debugging and inspection tool included in Astro, providing a set of built-in apps and APIs for development purposes only. It includes features such as the Astro Menu, Inspect, and Audit apps, which offer one-click access to project information, island properties, and performance/accessibility audits. The Dev Toolbar API allows developers to extend and customize the toolbar with custom apps.",
      "url": "/en/guides/dev-toolbar/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "toolbar"
      ],
      "type": "guide"
    },
    {
      "id": "reference/dev-toolbar-app-reference",
      "language": "en",
      "filePath": "src/content/docs/en/reference/dev-toolbar-app-reference.mdx",
      "title": "Dev Toolbar App API",
      "summary": "Here is the technical documentation summary: The Astro Dev Toolbar App API allows you to create Astro Integrations that add apps to the Astro Dev Toolbar, enabling new features and integrations with third-party services. This is achieved through the `addDevToolbarApp()` function, which is available in the `astro:config:setup` hook, and requires the `id`, `name`, `icon`, and `entrypoint` properties to define the toolbar app. The `addDevToolbarApp()` function takes an object with these properties, including `id` (a unique identifier), `name` (a human-readable name), `icon` (an icon from the icon list or SVG markup), and `entrypoint` (the path to the file).",
      "url": "/en/reference/dev-toolbar-app-reference/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "toolbar"
      ],
      "type": "guide"
    },
    {
      "id": "develop-and-build",
      "language": "en",
      "filePath": "src/content/docs/en/develop-and-build.mdx",
      "title": "Develop and build",
      "summary": "**Develop and build with Astro** Astro components are imported from `@astrojs/starlight/components` and `~/components/ReadMore.astro` to create a new project. The `astro dev` CLI command starts the local development server, serving the project on `http://localhost:4321/`. The dev server listens for live file changes in the `src/` directory, updating the site preview as changes are made.",
      "url": "/en/develop-and-build/",
      "keywords": [
        "content",
        "docs",
        "develop",
        "build"
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/directus",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/directus.mdx",
      "title": "Directus & Astro",
      "summary": "Directus & Astro are integrated to enable content management for Astro projects, utilizing Directus as a backend-as-a-service to host data and content. Key features include: * Utilizing Directus APIs to fetch and manage content * Integration with Astro's `getStaticPaths` and `Astro.props` to enable server-side rendering and client-side rendering * Implementation details involve setting up Directus as a backend service and configuring Astro to interact with it * Use cases include building blogs, portfolios, and other content-driven websites with Astro and Directus. Keywords: Directus, Astro, CMS, backend-as-a-service, getStaticPaths, Astro.props, server-side rendering, client-side rendering.",
      "url": "/en/guides/cms/directus/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "directus",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/cms/drupal",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/drupal.mdx",
      "title": "Drupal & Astro",
      "summary": "**Drupal & Astro Integration** Astro components are designed to fetch content from a Drupal CMS using the JSON:API module, enabling internationalization and seamless content management. Key features include: * `getStaticPaths` API for fetching Drupal content * `Astro.props` for accessing Drupal data * Integration with `@astrojs/starlight/components` for rendering content Implementation details involve installing the JSON:API module in Drupal, setting the Drupal URL in the `.env` file, and configuring credentials for authentication. Use cases include fetching and rendering Drupal content in Astro projects, enabling internationalization and content management.",
      "url": "/en/guides/cms/drupal/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "drupal",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "reference/errors/duplicate-content-entry-slug-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/duplicate-content-entry-slug-error.mdx",
      "title": "Duplicate content entry slug.",
      "summary": "**Duplicate Content Entry Slug** Duplicate content entry slug is a critical error that occurs when multiple entries in a content collection share the same slug, violating the uniqueness requirement. **Key Features and APIs:** * `slug` frontmatter property: must be unique across all entries in a collection * Error message: \"COLLECTION_NAME contains multiple entries with the same slug: SLUG. Slugs must be unique.\" * Implementation detail: Astro's content collection validation checks for duplicate slugs **Use Cases and Implementation:** * Ensure unique slugs for content entries in collections to prevent errors and inconsistencies * Use Astro's built-in validation to detect and prevent duplicate slugs * Update frontmatter properties to ensure unique slugs for each entry in a collection",
      "url": "/en/reference/errors/duplicate-content-entry-slug-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "duplicate",
        "entry",
        "slug."
      ],
      "type": "guide"
    },
    {
      "id": "recipes/dynamically-importing-images",
      "language": "en",
      "filePath": "src/content/docs/en/recipes/dynamically-importing-images.mdx",
      "title": "Dynamically import images",
      "summary": "**Dynamically Import Images using Vite's import.meta.glob Function** Astro components are designed to dynamically import images using Vite's `import.meta.glob` function, allowing for flexible and scalable image management. **Key Features and APIs:** * `import.meta.glob`: Returns an object of all image paths inside the `assets` folder. * `Astro.props`: Specifies the props that the component will receive, including `imagePath`, `altText`, `name`, and `age`. * `Image` component: Displays the dynamically imported image. **Implementation Details and Use Cases:** * Create a new `assets` folder under the `src` directory and add images inside. * Use `import.meta.glob` to dynamically import image paths. * Define props for the component using `Astro.props`. * Use the `Image` component to display the dynamically imported image. **Technical Keywords:** Astro, Vite, import.meta.glob, dynamic image import, image management, scalable image loading.",
      "url": "/en/recipes/dynamically-importing-images/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "dynamically",
        "import",
        "images"
      ],
      "type": "recipe"
    },
    {
      "id": "guides/ecommerce",
      "language": "en",
      "filePath": "src/content/docs/en/guides/ecommerce.mdx",
      "title": "E-commerce",
      "summary": "Astro components are designed to enable e-commerce functionality on Astro sites, offering various payment processing options, including checkout links, hosted payment pages, and storefronts using payment service APIs. Key features include payment processing overlays, such as Lemon Squeezy and Paddle, which can be integrated as scripts, buttons, or external links, providing basic customization and site branding. The Astro API provides methods like `Astro.props` to access component props and `getStaticPaths` to generate static paths for e-commerce routes.",
      "url": "/en/guides/ecommerce/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "e-commerce"
      ],
      "type": "guide"
    },
    {
      "id": "editor-setup",
      "language": "en",
      "filePath": "src/content/docs/en/editor-setup.mdx",
      "title": "Editor setup",
      "summary": "**Astro Editor Setup** Astro components are customizable code editor integrations that improve the developer experience and unlock new features for Astro projects. Key features include: * Syntax highlighting for `.astro` files * TypeScript type information for `.astro` files * VS Code Intellisense for code completion, hints, and more * Astro extensions for VS Code, Zed, and JetBrains IDEs (Webstorm) Implementation details include installing the Astro VS Code Extension, Astro extension in Zed, or the official plugin in JetBrains IDEs. Use cases include setting up TypeScript in Astro projects.",
      "url": "/en/editor-setup/",
      "keywords": [
        "content",
        "docs",
        "editor",
        "setup"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/missing-middleware-for-internationalization",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/missing-middleware-for-internationalization.mdx",
      "title": "Enabled manual internationalization routing without having a middleware.",
      "summary": "**Astro components are designed to handle internationalization routing with manual configuration.** **Key features include:** * Manual internationalization routing enabled through `i18n.routing: 'manual'` configuration setting * Astro throws an error if manual routing is enabled without a provided middleware file * Required implementation of i18n middleware file for manual routing functionality **Implementation details and use cases:** * Astro.props API can be used to access and manipulate internationalized content * getStaticPaths method can be used to generate static paths for internationalized routes * Middleware file implementation is necessary for manual internationalization routing to function correctly",
      "url": "/en/reference/errors/missing-middleware-for-internationalization/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "enabled",
        "manual",
        "internationalization",
        "routing"
      ],
      "type": "guide"
    },
    {
      "id": "guides/endpoints",
      "language": "en",
      "filePath": "src/content/docs/en/guides/endpoints.mdx",
      "title": "Endpoints",
      "summary": "**Endpoints** Astro components are used to create custom endpoints that serve any kind of data, including images, RSS documents, and API routes. **Key Features** * Define custom endpoints in `.js` or `.ts` files in the `/pages` directory * Export a `GET` function (optionally `async`) that receives a context object with properties similar to the `Astro` global * Return a `Response` object with a `name` and `url` to generate static files or live server endpoints * Support for binary data output, such as images, using `arrayBuffer()` method * Type-safe endpoint functions using TypeScript **Implementation Details** * Statically-generated sites call custom endpoints at build time to produce static files * Opt-in to Server-Side Rendering (SSR) mode to turn custom endpoints into live server endpoints * Additional features available for SSR endpoints, including support for dynamic data and caching",
      "url": "/en/guides/endpoints/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "endpoints"
      ],
      "type": "guide"
    },
    {
      "id": "reference/modules/astro-env",
      "language": "en",
      "filePath": "src/content/docs/en/reference/modules/astro-env.mdx",
      "title": "Environment Variables API Reference",
      "summary": "**Environment Variables API Reference** The `astro:env` API provides a type-safe schema for environment variables, allowing configuration of server and client availability, data type, and additional properties. It offers a `getSecret()` helper function for retrieving raw environment variable values by key, and is recommended for retrieving environment variables programmatically to ensure adapter-agnostic implementation.",
      "url": "/en/reference/modules/astro-env/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "modules",
        "environment",
        "variables"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/live-content-config-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/live-content-config-error.mdx",
      "title": "Error in live content config.",
      "summary": "**Live Content Config Error Handling** Live content config errors occur when the schema is a function for live collections, violating the requirement for a schema object. This error is typically encountered in the live content config file, and is resolved by replacing the function schema with a schema object. The error message provides a clear indication of the issue, directing users to check their collection definitions.",
      "url": "/en/reference/errors/live-content-config-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "error",
        "live",
        "config."
      ],
      "type": "guide"
    },
    {
      "id": "reference/error-reference",
      "language": "en",
      "filePath": "src/content/docs/en/reference/error-reference.mdx",
      "title": "Error reference",
      "summary": "**Error Reference Documentation** Astro components are designed to handle various errors that may occur during development and runtime, providing a comprehensive list of error types and their descriptions. Key features include: * **Error types**: Astro Errors, such as UnknownCompilerError, ClientAddressNotAvailable, and NoMatchingStaticPathFound, each with a detailed description and link to further documentation. * **APIs and methods**: getStaticPaths, Astro.props, and clientAddress are used to resolve errors and ensure proper functionality. * **Implementation details**: Error handling is implemented using a combination of Astro's built-in error types and custom error handling mechanisms. * **Use cases**: Error reference is useful for developers to troubleshoot and resolve issues during development and runtime, ensuring a smooth user experience. Technical keywords: Astro, error handling, getStaticPaths, clientAddress, UnknownCompilerError, ClientAddressNotAvailable, NoMatchingStaticPathFound.",
      "url": "/en/reference/error-reference/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "error"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/invalid-image-service",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/invalid-image-service.mdx",
      "title": "Error while loading image service.",
      "summary": "**InvalidImageService Error** InvalidImageService is an error that occurs when there is an issue loading the configured image service. This can be caused by factors such as an incorrectly exported object or an invalid path. The error is resolved by verifying the image service configuration and ensuring it exports a compatible object in its default export. **Key Features and APIs:** * `InvalidImageService` error object * Image Service API reference: [Image Service API](/en/reference/image-service-reference/) **Implementation Details:** * Error loading configured image service * Potential causes: incorrect export, invalid path * Resolution: verify image service configuration and export **Use Cases:** * Troubleshooting image service issues * Verifying image service configuration * Resolving InvalidImageService errors",
      "url": "/en/reference/errors/invalid-image-service/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "error",
        "while",
        "loading",
        "image"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/expected-not-esmimage",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/expected-not-esmimage.mdx",
      "title": "Expected image options, not an ESM-imported image.",
      "summary": "**ExpectedNotESMImage**: An ESM-imported image cannot be passed directly to `getImage()`. Instead, pass an object with the image in the `src` property, using the `getImage()` method with an object containing the `src` property, such as `await getImage({ src: myImage });`. This is a critical implementation detail for Astro image optimization, particularly when working with ESM-imported images.",
      "url": "/en/reference/errors/expected-not-esmimage/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "expected",
        "image",
        "options,",
        "esm-imported"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/expected-image-options",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/expected-image-options.mdx",
      "title": "Expected image options.",
      "summary": "**ExpectedImageOptions**: Astro components expect `getImage()` parameter to be an object, received `OPTIONS`. The `getImage()` method requires an object with properties such as `src`, `width`, and `height` to optimize images. This error typically occurs when passing parameters directly instead of wrapping them in an object.",
      "url": "/en/reference/errors/expected-image-options/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "expected",
        "image",
        "options."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/expected-image",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/expected-image.mdx",
      "title": "Expected src to be an image.",
      "summary": "**ExpectedImage**: Expected `src` property for `getImage` or `` to be either an ESM imported image or a string with the path of a remote image. The `src` attribute must be a valid image, such as an imported image (`import myImage from \"../assets/my_image.png\";`) or a string (`src=\"https://example.com/logo.png\"`). This error typically occurs when the `src` value is undefined.",
      "url": "/en/reference/errors/expected-image/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "expected",
        "image."
      ],
      "type": "guide"
    },
    {
      "id": "reference/experimental-flags/client-prerender",
      "language": "en",
      "filePath": "src/content/docs/en/reference/experimental-flags/client-prerender.mdx",
      "title": "Experimental client prerendering",
      "summary": "**Experimental Client Prerendering** Enables pre-rendering of prefetched pages on the client in supported browsers using the Speculation Rules Web API, enhancing the default `prefetch` behavior globally to prerender links on the client. This feature requires browser support and may pose risks when prerendering on the client. Enable client-side prerendering in `astro.config.mjs` along with `prefetch` configuration options, and use the `data-astro-prefetch` attribute on `` links to opt in to prefetching.",
      "url": "/en/reference/experimental-flags/client-prerender/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "experimental flags",
        "experimental",
        "client",
        "prerendering"
      ],
      "type": "guide"
    },
    {
      "id": "reference/experimental-flags/csp",
      "language": "en",
      "filePath": "src/content/docs/en/reference/experimental-flags/csp.mdx",
      "title": "Experimental Content Security Policy (CSP)",
      "summary": "**Experimental Content Security Policy (CSP)** Astro components are enabled with support for Content Security Policy (CSP) to minimize security threats by controlling resource loading, providing protection against cross-site scripting (XSS) attacks. This feature adds security to Astro's handling of processed and bundled scripts and styles by default, allowing configuration of content types, and supports hashes for external and inline scripts. It is not supported in dev mode, but can be tested in build and preview modes.",
      "url": "/en/reference/experimental-flags/csp/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "experimental flags",
        "experimental",
        "security",
        "policy",
        "(csp)"
      ],
      "type": "guide"
    },
    {
      "id": "reference/experimental-flags/fonts",
      "language": "en",
      "filePath": "src/content/docs/en/reference/experimental-flags/fonts.mdx",
      "title": "Experimental fonts API",
      "summary": "**Experimental Fonts API** The Experimental Fonts API allows you to use fonts from your filesystem and various font providers through a unified, fully customizable, and type-safe API. This API enables automatic web font optimizations, including preload links, optimized fallbacks, and opinionated defaults, to keep your site performant. To use this feature, configure an `experimental.fonts` object with at least one font and add the `` component and site-wide styling in your ``.",
      "url": "/en/reference/experimental-flags/fonts/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "experimental flags",
        "experimental",
        "fonts"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/experimental-fonts-not-enabled",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/experimental-fonts-not-enabled.mdx",
      "title": "Experimental fonts are not enabled",
      "summary": "**ExperimentalFontsNotEnabled**: The Font component is used but experimental fonts have not been registered in the Astro config. This error occurs when the `Font` component is utilized, but the experimental font registration is missing in the `astro.config.js` file. To resolve this, register experimental fonts in the config using the `experimentalFonts` API.",
      "url": "/en/reference/errors/experimental-fonts-not-enabled/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "experimental",
        "fonts",
        "enabled"
      ],
      "type": "guide"
    },
    {
      "id": "reference/experimental-flags/content-intellisense",
      "language": "en",
      "filePath": "src/content/docs/en/reference/experimental-flags/content-intellisense.mdx",
      "title": "Experimental Intellisense for content collections",
      "summary": "**Experimental Intellisense for Content Collections** Astro components are enabled with Intellisense features for content collection entries in compatible editors through the `contentIntellisense` experimental feature. This feature generates and adds JSON schemas to the `.astro` directory, utilizing the Astro language server to provide Intellisense inside content files (.md, .mdx, .mdoc). The feature is enabled by setting `contentIntellisense: true` in the Astro configuration file.",
      "url": "/en/reference/experimental-flags/content-intellisense/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "experimental flags",
        "experimental",
        "intellisense",
        "collections"
      ],
      "type": "guide"
    },
    {
      "id": "reference/experimental-flags/live-content-collections",
      "language": "en",
      "filePath": "src/content/docs/en/reference/experimental-flags/live-content-collections.mdx",
      "title": "Experimental live content collections",
      "summary": "**Experimental Live Content Collections** Astro components are designed to support live content collections, a new type of content collection that fetches data at runtime rather than build time, enabling access to frequently updated data from CMSs, APIs, databases, or other sources using a unified API. **Key Features and APIs** * `experimental.liveContentCollections` flag in `astro.config.mjs` to enable the feature * `defineLiveCollection()` function from `astro:content` module to define live collections with a live loader and optional schema * `getLiveCollection()` and `getLiveEntry()` functions to access live data * Support for on-demand rendering and adapters for live content collections **Implementation Details and Use Cases** * Create a new `src/live.config.ts` file to define live collections with a live loader and optionally a schema * Use the `defineLiveCollection()` function to create a live collection with a loader and schema * Access live data using the `getLiveCollection()` and `getLiveEntry()` functions * Use with on-demand rendering and adapters for live content collections",
      "url": "/en/reference/experimental-flags/live-content-collections/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "experimental flags",
        "experimental",
        "live",
        "collections"
      ],
      "type": "guide"
    },
    {
      "id": "reference/experimental-flags/heading-id-compat",
      "language": "en",
      "filePath": "src/content/docs/en/reference/experimental-flags/heading-id-compat.mdx",
      "title": "Experimental Markdown heading ID compatibility",
      "summary": "**Astro components are designed to generate Markdown heading IDs compatible with common platforms like GitHub and npm.** **Key features and APIs:** * `experimental.headingIdCompat` flag: a boolean value that enables heading ID compatibility * `defineConfig` function: used to set the `experimental.headingIdCompat` flag to `true` in Astro configuration * `github-slugger` package: used by Astro to convert Markdown heading text to a slug for ID generation * `rehypeHeadingIds` plugin: compatible with `experimental.headingIdCompat` flag **Implementation details and use cases:** * Enables retention of trailing hyphens on Markdown heading IDs for special characters * Requires no specific usage, only affects Astro's ID generation for Markdown headings * Compatible with platforms like GitHub and npm * Future major version will switch to compatible ID style by default, but can be opted in early using the `experimental.headingIdCompat` flag.",
      "url": "/en/reference/experimental-flags/heading-id-compat/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "experimental flags",
        "experimental",
        "markdown",
        "heading",
        "compatibility"
      ],
      "type": "guide"
    },
    {
      "id": "reference/experimental-flags/preserve-scripts-order",
      "language": "en",
      "filePath": "src/content/docs/en/reference/experimental-flags/preserve-scripts-order.mdx",
      "title": "Experimental preserve scripts order",
      "summary": "**Experimental preserve scripts order** Astro components are enhanced with the `experimental.preserveScriptOrder` feature flag, which preserves the order of `` and `` tags in the source code when rendering multiple tags on the same page. This feature uses the `experimental.preserveScriptOrder` API, which is enabled by setting `preserveScriptOrder: true` in the Astro config. The `preserveScriptOrder` method is not explicitly called, but rather affects the rendering of `` and `` tags.",
      "url": "/en/reference/experimental-flags/preserve-scripts-order/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "experimental flags",
        "experimental",
        "preserve",
        "scripts",
        "order"
      ],
      "type": "guide"
    },
    {
      "id": "reference/experimental-flags/raw-env-values",
      "language": "en",
      "filePath": "src/content/docs/en/reference/experimental-flags/raw-env-values.mdx",
      "title": "Experimental raw environment variables values",
      "summary": "**Astro allows you to configure a type-safe schema for your environment variables and converts variables imported via `astro:env` into the expected type.** **Features:** * `experimental.rawEnvValues` flag to disable coercion of `import.meta.env` values * Type-safe schema for environment variables * Conversion of variables imported via `astro:env` into expected type * Coercion of `import.meta.env` values can be disabled using `experimental.rawEnvValues` flag **Implementation Details:** * Set `experimental.rawEnvValues` flag to `true` in `astro.config.mjs` to disable coercion * Use `import.meta.env` values without coercion by enabling `experimental.rawEnvValues` flag **Use Cases:** * Disable coercion of `import.meta.env` values for type-safe environment variables * Align `import.meta.env` behavior with Vite * Update project code to apply coercion manually if necessary",
      "url": "/en/reference/experimental-flags/raw-env-values/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "experimental flags",
        "experimental",
        "environment",
        "variables",
        "values"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/generate-content-types-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/generate-content-types-error.mdx",
      "title": "Failed to generate content types.",
      "summary": "**Astro content generation failed due to synchronization error** The `astro sync` command failed to generate content collection types, resulting in a `GenerateContentTypesError`. This error occurs when the `astro sync` command encounters an issue while processing content collection types, typically due to invalid or missing configuration. The error message provides details on the specific issue, such as `ERROR_MESSAGE`.",
      "url": "/en/reference/errors/generate-content-types-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "failed",
        "generate",
        "types."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/markdown-frontmatter-parse-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/markdown-frontmatter-parse-error.mdx",
      "title": "Failed to parse Markdown frontmatter.",
      "summary": "**Astro Markdown Frontmatter Parser** Astro components are designed to parse Markdown frontmatter, but may fail due to syntax errors such as missing colons or end quotes. The parser uses APIs like `Astro.props` to extract metadata, but may throw errors like \"can not read an implicit mapping pair\" or \"unexpected end of the stream within a double quoted scalar\". Implementation details involve using methods like `getStaticPaths` to handle frontmatter parsing, and use cases include troubleshooting syntax errors in Markdown files.",
      "url": "/en/reference/errors/markdown-frontmatter-parse-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "failed",
        "parse",
        "markdown",
        "frontmatter."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/failed-to-fetch-remote-image-dimensions",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/failed-to-fetch-remote-image-dimensions.mdx",
      "title": "Failed to retrieve remote image dimensions",
      "summary": "**Failed to retrieve remote image dimensions** Astro components fail to retrieve remote image dimensions due to incorrect URLs or attempting to infer sizes of images in the public folder, which is not possible. This is typically caused by an incorrect URL or attempting to infer the size of an image in the public folder. The `getImageDimensions` API is used to retrieve image dimensions, but it requires a valid URL and may return an error if the image is not accessible.",
      "url": "/en/reference/errors/failed-to-fetch-remote-image-dimensions/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "failed",
        "retrieve",
        "remote",
        "image"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/file-parser-not-found",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/file-parser-not-found.mdx",
      "title": "File parser not found",
      "summary": "**File Loader Error Handling** The `file` loader in Astro components is used to load and parse files, but it requires a custom parser function to be passed to it, such as `csv` or `csv-parse`, to determine the file type and create a collection. **Key Features and APIs:** * `file` loader requires a custom parser function (e.g. `csv`, `csv-parse`) * `parser` function is passed to the `file` loader to determine file type and create collection * Use cases: loading and parsing CSV files, other file types require custom parser implementation **Implementation Details:** * Pass a parser function to the `file` loader to resolve the `FileParserNotFound` error * Refer to the Astro documentation for guides on passing a `parser` function to the `file` loader",
      "url": "/en/reference/errors/file-parser-not-found/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "file",
        "parser",
        "found"
      ],
      "type": "guide"
    },
    {
      "id": "guides/backend/google-firebase",
      "language": "en",
      "filePath": "src/content/docs/en/guides/backend/google-firebase.mdx",
      "title": "Firebase & Astro",
      "summary": "**Firebase & Astro Integration** Firebase & Astro components are a set of APIs and methods that enable integration with the Firebase app development platform, providing a NoSQL database, authentication, real-time subscriptions, functions, and storage. Key features include: * `firebase.initializeApp()` method for initializing Firebase in Astro * `firebase.auth()` method for authentication and user management * `firebase.firestore()` method for interacting with the NoSQL database * `firebase.functions()` method for serverless functions and cloud hosting * Environment variables `FIREBASE_PRIVATE_KEY_ID`, `FIREBASE_PRIVATE_KEY`, and others for configuration Implementation details include creating an `.env` file with Firebase credentials and configuring IntelliSense with `env.d.ts`. Use cases include building server-side rendered applications with on-demand rendering enabled and integrating Firebase services such as authentication, database, and functions.",
      "url": "/en/guides/backend/google-firebase/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "backend",
        "firebase",
        "astro"
      ],
      "type": "backend"
    },
    {
      "id": "guides/cms/flotiq",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/flotiq.mdx",
      "title": "Flotiq & Astro",
      "summary": "Here is the technical documentation summary: **Flotiq & Astro Integration** Flotiq & Astro components are designed to enable seamless content management and delivery for Astro projects using Flotiq's headless CMS API. Key features include: * Integration with Astro's `getStaticPaths` and `Astro.props` APIs * Support for REST and GraphQL-based APIs * Implementation details include setting up environment variables, defining content types in Flotiq, and creating content objects Use cases include displaying dynamic content on static sites, mobile applications, and web applications, with internationalization support.",
      "url": "/en/guides/cms/flotiq/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "flotiq",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "reference/errors/font-family-not-found",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/font-family-not-found.mdx",
      "title": "Font family not found",
      "summary": "**Font Family Not Found Error** Font family not found errors occur when the Font component is unable to locate the specified font family. This issue can be resolved by ensuring the font family is properly imported and registered in the Astro project. The error can be mitigated by using the `Font.load()` method to dynamically load the font family, or by using the `Font.fallback()` method to specify a fallback font family.",
      "url": "/en/reference/errors/font-family-not-found/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "font",
        "family",
        "found"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/forbidden-rewrite",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/forbidden-rewrite.mdx",
      "title": "Forbidden rewrite to a static route.",
      "summary": "**Forbidden Rewrite to Static Route** Astro components are restricted from rewriting on-demand routes to static routes when using the \"server\" output, due to prerendered component compilation to HTML files. Specifically, `Astro.rewrite()` is forbidden for rewriting on-demand routes with static routes when the output is set to `\"server\"`. This is because prerendered components are compiled to HTML files, which cannot be retrieved at runtime by Astro.",
      "url": "/en/reference/errors/forbidden-rewrite/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "forbidden",
        "rewrite",
        "static",
        "route."
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/frontmatter-cms",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/frontmatter-cms.mdx",
      "title": "Front Matter CMS & Astro",
      "summary": "Here is the technical documentation summary: **Front Matter CMS & Astro** Front Matter CMS integrates with Astro to enable content management within the editor, supporting internationalization. Key features include: * **Front Matter CMS extension**: Installable in Visual Studio Code and other editors, providing a panel for project initialization and content management. * **Project initialization**: Register content folders, such as `src/content/blog`, to enable Front Matter CMS to find and create content. * **APIs and methods**: Utilize Astro's `getStaticPaths` and `Astro.props` to manage content and metadata. Implementation details and use cases include integrating Front Matter CMS with Astro projects, registering content folders, and utilizing APIs and methods for content management.",
      "url": "/en/guides/cms/frontmatter-cms/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "front",
        "matter",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/framework-components",
      "language": "en",
      "filePath": "src/content/docs/en/guides/framework-components.mdx",
      "title": "Front-end frameworks",
      "summary": "**Front-end frameworks** Astro components are a collection of UI frameworks, including React, Preact, Svelte, Vue, SolidJS, and AlpineJS, that can be used to build Astro websites without sacrificing performance. Key features include official integrations, community-maintained framework integrations, and the ability to use framework components in Astro pages, layouts, and components using APIs such as `import` and JSX-like expressions.",
      "url": "/en/guides/framework-components/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "front-end",
        "frameworks"
      ],
      "type": "guide"
    },
    {
      "id": "tutorial/5-astro-api/2",
      "language": "en",
      "filePath": "src/content/docs/en/tutorial/5-astro-api/2.mdx",
      "title": "Generate tag pages",
      "summary": "**Generate tag pages** Astro components are used to dynamically create tag pages using the `getStaticPaths` function, which returns an array of page routes. This function is implemented in `.astro` files that export `getStaticPaths`, allowing for the creation of entire sets of pages dynamically. The `getStaticPaths` function is used in conjunction with Astro's `params` object to generate pages for specific tags, such as `astro`, `successes`, and `community`.",
      "url": "/en/tutorial/5-astro-api/2/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "5 astro api",
        "generate",
        "pages"
      ],
      "type": "tutorial"
    },
    {
      "id": "reference/errors/get-static-paths-removed-rsshelper",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/get-static-paths-removed-rsshelper.mdx",
      "title": "getStaticPaths RSS helper is not available anymore.",
      "summary": "**getStaticPaths RSS Helper Removal** The `getStaticPaths` function no longer exposes an RSS helper for generating a RSS feed, which was deprecated since Astro 4.0. Instead, use the `@astrojs/rss` package for RSS integration.",
      "url": "/en/reference/errors/get-static-paths-removed-rsshelper/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "getstaticpaths",
        "helper",
        "available",
        "anymore."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/get-static-paths-required",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/get-static-paths-required.mdx",
      "title": "getStaticPaths() function required for dynamic routes.",
      "summary": "**getStaticPaths() function required for dynamic routes.** The `getStaticPaths()` function is a required export for dynamic routes, returning the different paths to generate at build time in Static Mode. This function must be implemented to determine routes at build time, ensuring server-side rendering and on-demand rendering functionality.",
      "url": "/en/reference/errors/get-static-paths-required/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "getstaticpaths()",
        "function",
        "required",
        "dynamic"
      ],
      "type": "guide"
    },
    {
      "id": "getting-started",
      "language": "en",
      "filePath": "src/content/docs/en/getting-started.mdx",
      "title": "Getting started",
      "summary": "Astro components are reusable UI elements that can be used to build web applications, leveraging the Astro framework's Islands architecture and template syntax. Key features include Astro.props, getStaticPaths, and Astro components, which enable developers to create dynamic and optimized content-driven websites. Implementation details involve importing and using Astro components, such as CardGrid, Card, ListCard, and SplitCard, to build custom UI elements and layouts. Use cases include building blogs, portfolios, docs, landing pages, SaaS, marketing, ecommerce sites, and more, with Astro's extensive guides, resources, and API references.",
      "url": "/en/getting-started/",
      "keywords": [
        "content",
        "docs",
        "getting",
        "started"
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/ghost",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/ghost.mdx",
      "title": "Ghost & Astro",
      "summary": "**Ghost & Astro Integration** Ghost & Astro components are used to fetch and display content from a Ghost CMS instance within an Astro project, enabling seamless integration of headless content management. Key features include: * `@tryghost/content-api` wrapper for interacting with the Ghost Content API * Environment variable support for storing API keys (e.g., `CONTENT_API_KEY`) * TypeScript support via `env.d.ts` file for IntelliSense and type checking * Installation of dependencies via npm or yarn Implementation details involve setting up credentials in an `.env` file, installing the `@tryghost/content-api` package, and utilizing the `CONTENT_API_KEY` environment variable to authenticate API requests. Use cases include building custom Astro components that fetch and display Ghost content, such as blog posts, authors, or tags.",
      "url": "/en/guides/cms/ghost/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "ghost",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/cms/gitcms",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/gitcms.mdx",
      "title": "GitCMS & Astro",
      "summary": "**GitCMS & Astro Integration** GitCMS & Astro components are a seamless integration of a Git-based headless CMS into Astro projects, enabling a Notion-like markdown editing experience for content management. Key features include Astro.props, getStaticPaths, and Astro components for rendering GitCMS data, with implementation details and use cases outlined in official resources. This integration supports internationalization and is ready for production use.",
      "url": "/en/guides/cms/gitcms/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "gitcms",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "reference/errors/file-glob-not-supported",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/file-glob-not-supported.mdx",
      "title": "Glob patterns are not supported in the file loader",
      "summary": "**FileGlobNotSupported**: The `file` loader in Astro does not support glob patterns, requiring a single local file to be passed. Use the built-in `glob` loader to create entries from patterns of multiple local files. Implement the `glob` loader instead of the `file` loader for glob pattern support.",
      "url": "/en/reference/errors/file-glob-not-supported/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "glob",
        "patterns",
        "supported",
        "file"
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/hashnode",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/hashnode.mdx",
      "title": "Hashnode & Astro",
      "summary": "**Hashnode & Astro Integration** Hashnode & Astro components are used to integrate Hashnode as a CMS with Astro projects, enabling the creation of blogs and publications. **Key Features and APIs** * Utilizes the Hashnode Public API, a GraphQL API, to interact with Hashnode data * Leverages `graphql-request`, a minimal GraphQL client, to fetch data in Astro projects * Includes `getStaticPaths` and `Astro.props` for dynamic routing and data fetching * Implements internationalization (i18n) support **Implementation Details and Use Cases** * Requires an Astro project and a Hashnode site to get started * Installs `graphql-request` package using npm, pnpm, or yarn * Fetches site data using `graphql-request` and creates dynamic pages for individual posts * Suitable for creating blogs and publications with Astro and Hashnode integration.",
      "url": "/en/guides/cms/hashnode/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "hashnode",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/cms/statamic",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/statamic.mdx",
      "title": "Headless Statamic & Astro",
      "summary": "**Headless Statamic & Astro Integration** Astro components are integrated with Statamic, a modern, flat-file CMS, to enable dynamic website and application creation, and intuitive content management for editors. Key features include: * Utilizing Statamic's built-in REST API and GraphQL API to connect data to Astro * Enabling REST API and GraphQL API in Statamic Pro version * Fetching data from Statamic site's REST API URL (e.g., `https://[YOUR-SITE]/api/`) * Using Astro's `fetch` API to retrieve data from Statamic API Implementation details include: * Adding `STATAMIC_API_ENABLED=true` or `STATAMIC_GRAPHQL_ENABLED=true` in the `.env` file * Enabling required resources in the API configuration file * Using `127.0.0.1` instead of `localhost` when fetching the API on local machine Use cases include: * Creating dynamic websites and applications with Statamic as a CMS * Integrating Statamic content with Astro components * Utilizing Statamic's REST API and GraphQL API to fetch data in Astro",
      "url": "/en/guides/cms/statamic/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "headless",
        "statamic",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/cms/wordpress",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/wordpress.mdx",
      "title": "Headless WordPress & Astro",
      "summary": "**Headless WordPress & Astro** Astro components are designed to integrate with WordPress as a headless CMS, providing a content management system for Astro projects. **Key Features and APIs:** * Utilize the WordPress REST API to fetch data from WordPress sites * Optional installation of WPGraphQL or Gato GraphQL for GraphQL support * Astro components can render WordPress data using `set:html={}` directive * Support for internationalization (i18n) ready **Implementation Details and Use Cases:** * Fetch WordPress data through the site's unique REST API URL and content route (e.g., `posts`) * Render data properties using Astro's `set:html={}` directive * Optional authentication for data modification and site settings * Compatible with Astro projects and WordPress sites with REST API enabled",
      "url": "/en/guides/cms/wordpress/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "headless",
        "wordpress",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/cms/hygraph",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/hygraph.mdx",
      "title": "Hygraph & Astro",
      "summary": "**Hygraph & Astro Integration** Hygraph & Astro components are used to fetch and render content from a Hygraph CMS project in an Astro application. **Key Features and APIs** * Expose a GraphQL endpoint for fetching content using the `HYGRAPH_ENDPOINT` environment variable * Use `HYGRAPH_ENDPOINT` to fetch data from Hygraph project, e.g., `blogPosts` content type with `title` field * Implement `env.d.ts` file for IntelliSense support with `ImportMetaEnv` interface **Implementation Details and Use Cases** * Create a `.env` file in the root directory with `HYGRAPH_ENDPOINT` variable * Configure `env.d.ts` file in `src/` directory for IntelliSense support * Use `HYGRAPH_ENDPOINT` to fetch data from Hygraph project in Astro components",
      "url": "/en/guides/cms/hygraph/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "hygraph",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "reference/errors/i18n-not-enabled",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/i18n-not-enabled.mdx",
      "title": "i18n Not Enabled",
      "summary": "**Astro components are unable to use the `astro:i18n` module without enabling internationalization (i18n) in the Astro config.** **Key features and APIs:** * `astro:i18n` module requires i18n to be enabled in the Astro config * `i18n` configuration object with `locales` and `defaultLocale` properties * `locales` array specifies supported locales (e.g., `['en', 'fr']`) * `defaultLocale` specifies the default locale (e.g., `'en'`) **Implementation details and use cases:** * Enable i18n in Astro config by adding `i18n` object with `locales` and `defaultLocale` properties * Use `i18n` configuration to support multiple locales and default locale * Refer to Astro's Internationalization guide for more information on i18n support **Searchable technical keywords:** Astro, i18n, internationalization, locales, defaultLocale, configuration, module.",
      "url": "/en/reference/errors/i18n-not-enabled/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "i18n",
        "enabled"
      ],
      "type": "guide"
    },
    {
      "id": "reference/modules/astro-assets",
      "language": "en",
      "filePath": "src/content/docs/en/reference/modules/astro-assets.mdx",
      "title": "Image and Assets API Reference",
      "summary": "**Image and Assets API Reference** Astro provides built-in components and helper functions for optimizing and displaying images, including the `` component for optimizing and transforming images, and the `getImage` function for inferring remote image sizes. **Key Features and APIs** * `` component with properties `src`, `alt`, and responsive image properties * `getImage` function for inferring remote image sizes * `inferRemoteSize` function for inferring remote image sizes * `Picture` component for wrapping `` with a `` element **Implementation Details and Use Cases** The `` component optimizes and transforms images, and can be used to create responsive images that adjust based on container or device screen size and resolution. The `getImage` function can be used to infer remote image sizes, and the `inferRemoteSize` function can be used to infer remote image sizes. The `Picture` component can be used to wrap the `` component with a `` element.",
      "url": "/en/reference/modules/astro-assets/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "modules",
        "image",
        "assets"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/image-missing-alt",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/image-missing-alt.mdx",
      "title": "Image missing required alt property.",
      "summary": "**Image Component Requirements** The Image component in Astro requires a specified `alt` property to ensure image accessibility, providing descriptive text for screen readers and assistive technologies. The `alt` property must be set to a non-empty string, or `alt=\"\"` if the image is purely decorative. This requirement is critical for ensuring compliance with accessibility standards.",
      "url": "/en/reference/errors/image-missing-alt/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "image",
        "missing",
        "required",
        "property."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/image-not-found",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/image-not-found.mdx",
      "title": "Image not found.",
      "summary": "**ImageNotFound Component** The ImageNotFound component is a built-in Astro component that displays an error message when an image cannot be found. It provides a simple way to handle image loading failures and offers a customizable error message. The component can be used in conjunction with Astro's image handling features, such as `Astro.props` and `getStaticPaths`, to ensure seamless image loading and error handling.",
      "url": "/en/reference/errors/image-not-found/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "image",
        "found."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/markdown-image-not-found",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/markdown-image-not-found.mdx",
      "title": "Image not found.",
      "summary": "**ImageNotFound Error** Astro components are designed to handle image loading and display errors, providing a `ImageNotFound` error when an image cannot be found at the specified path. Key features include: * `ImageNotFound` error handling * Astro.props API for accessing image metadata * Implementation details involve checking image paths and handling relative paths in Markdown content Use cases include: * Handling image loading errors in Markdown content * Displaying alternative content when an image is not found * Integrating with Astro's image handling features for seamless error handling.",
      "url": "/en/reference/errors/markdown-image-not-found/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "image",
        "found."
      ],
      "type": "guide"
    },
    {
      "id": "reference/image-service-reference",
      "language": "en",
      "filePath": "src/content/docs/en/reference/image-service-reference.mdx",
      "title": "Image Service API",
      "summary": "**Image Service API Summary** The Image Service API is designed to provide a standardized interface for image optimization services to integrate with Astro, enabling easy image transformation and rendering. Key features include: * **Service definitions**: Exported default objects with required methods (hooks) for Local and External services. * **Local services**: Provide `transform()`, `getURL()`, and `parseURL()` methods for image transformations and endpoint usage. * **External services**: Offer `getURL()` method for remote URL image rendering and `validateOptions()` for option validation. Implementation details include: * **Local services**: Use libraries like Sharp, ImageMagick, or Squoosh for image transformations. * **External services**: Support services like Cloudinary, Vercel, or RIAPI-compliant servers. * **Service usage**: Integrate with Astro's image configuration and rendering pipeline. Technical keywords: Astro, Image Service API, Local services, External services, Image transformation, Rendering, Image optimization, RIAPI.",
      "url": "/en/reference/image-service-reference/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "image",
        "service"
      ],
      "type": "guide"
    },
    {
      "id": "guides/images",
      "language": "en",
      "filePath": "src/content/docs/en/guides/images.mdx",
      "title": "Images",
      "summary": "**Astro Images** Astro provides image management features, including image and picture components, Markdown image syntax processing, SVG components, and an image generating function to optimize and transform images. Additionally, Astro offers automatic resizing of responsive images and customizable responsive properties for individual image and picture components. Images can be stored in the `src/` directory for processing and bundling, or in the `public/` directory for serving as-is.",
      "url": "/en/guides/images/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "images"
      ],
      "type": "guide"
    },
    {
      "id": "guides/imports",
      "language": "en",
      "filePath": "src/content/docs/en/guides/imports.mdx",
      "title": "Imports reference",
      "summary": "**Astro imports reference** Astro supports importing various file types, including Astro components, Markdown, JavaScript, TypeScript, NPM packages, JSON, CSS, CSS modules, images, and assets, with zero configuration required. Import statements can be used anywhere in the project JavaScript, including frontmatter, and Astro will include a built, optimized copy of the static asset in the final build. Supported file types can be extended by integrating UI frameworks, MDX, or Markdoc.",
      "url": "/en/guides/imports/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "imports",
        "reference"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/missing-index-for-internationalization",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/missing-index-for-internationalization.mdx",
      "title": "Index page not found.",
      "summary": "**Astro components are used to render dynamic content and handle internationalization routing.** **Key features and APIs include:** * `i18n.routing.prefixDefaultLocale` configuration option * `MissingIndexForInternationalization` error message * `getStaticPaths` method for generating static paths * `Astro.props` API for accessing component props **Implementation details and use cases:** * An index page is required to create a redirect to the index URL of the default locale * Internationalization routing is enabled using `i18n.routing.prefixDefaultLocale` * `getStaticPaths` method is used to generate static paths for localized index pages **Searchable technical keywords:** Astro, internationalization, routing, getStaticPaths, Astro.props, i18n.routing.prefixDefaultLocale, MissingIndexForInternationalization.",
      "url": "/en/reference/errors/missing-index-for-internationalization/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "index",
        "page",
        "found."
      ],
      "type": "guide"
    },
    {
      "id": "install-and-setup",
      "language": "en",
      "filePath": "src/content/docs/en/install-and-setup.mdx",
      "title": "Install Astro",
      "summary": "**Astro Installation** Astro components are a set of reusable UI components for building web applications, including `Tabs`, `TabItem`, `FileTree`, `CardGrid`, `LinkCard`, and `Steps`, which can be imported from `@astrojs/starlight/components`. The `create astro` CLI command is used to start a new Astro project from scratch, allowing users to choose from official starter templates or existing themes and starters. Astro requires Node.js v18.20.8 or higher, and can be accessed through its command-line interface (CLI).",
      "url": "/en/install-and-setup/",
      "keywords": [
        "content",
        "docs",
        "install",
        "astro"
      ],
      "type": "guide"
    },
    {
      "id": "recipes/add-yaml-support",
      "language": "en",
      "filePath": "src/content/docs/en/recipes/add-yaml-support.mdx",
      "title": "Installing a Vite or Rollup plugin",
      "summary": "**Astro plugins are used to extend Astro's functionality by integrating third-party plugins, such as Rollup plugins, to enable features like importing YAML data.** **Key features and APIs include:** * `@rollup/plugin-yaml` plugin installation * Importing YAML data using `import` statements * Configuring Astro's Vite plugins array in `astro.config.mjs` * Adding type definitions for YAML data in `*.d.ts` files **Implementation details and use cases include:** * Installing `@rollup/plugin-yaml` using npm, pnpm, or yarn * Importing YAML data in Astro components * Adding type definitions for YAML data to enable editor type hints",
      "url": "/en/recipes/add-yaml-support/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "installing",
        "vite",
        "rollup",
        "plugin"
      ],
      "type": "recipe"
    },
    {
      "id": "guides/internationalization",
      "language": "en",
      "filePath": "src/content/docs/en/guides/internationalization.mdx",
      "title": "Internationalization (i18n) Routing",
      "summary": "**Astro components are designed to handle internationalization (i18n) routing for multi-language websites.** **Key features include:** * `getStaticPaths` API for generating URLs * `Astro.props` for accessing page props and verifying localized URLs * Support for configuring default language, relative page URLs, and preferred languages * Fallback languages for directing visitors to existing content * Middleware for implementing routing logic and verifying localized URLs **Implementation details include:** * Using a middleware function to implement routing logic * Specifying `locales` and `defaultLocale` in an `i18n` configuration object * Configuring routing and fallback behavior for desired URLs **Use cases include:** * Localizing website content for international audiences * Generating and verifying URLs for multi-language sites * Configuring default language and fallback languages for optimal user experience",
      "url": "/en/guides/internationalization/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "internationalization",
        "(i18n)",
        "routing"
      ],
      "type": "guide"
    },
    {
      "id": "reference/modules/astro-i18n",
      "language": "en",
      "filePath": "src/content/docs/en/reference/modules/astro-i18n.mdx",
      "title": "Internationalization API Reference",
      "summary": "**Internationalization API Reference** **Purpose:** The Internationalization API provides functions to create URLs using project-configured locales, enabling i18n routing. **Features:** * `getRelativeLocaleUrl()`: Retrieves a relative path for a locale, throwing an error if the locale doesn't exist. * `getAbsoluteLocaleUrl()`: Returns an absolute URL for a locale. * `getRelativeLocaleUrlList()`: Retrieves a list of relative paths for locales. * `getAbsoluteLocaleUrlList()`: Returns a list of absolute URLs for locales. * `getPathByLocale()`: Retrieves a path by locale. * `getLocaleByPath()`: Retrieves a locale by path. * `redirectToDefaultLocale()`: Redirects to the default locale. * `redirectToFallback()`: Redirects to the fallback locale. * `notFound()`: Returns a 404 response. * `middleware()`: Provides a middleware function for i18n routing. * `requestHasLocale()`: Checks if a request has a locale. **Implementation Details:** * The API functions take into account project configuration values, including `base`, `trailingSlash`, `build.format`, and `site`. * The returned URLs reflect the project's `i18n.routing` configuration. * The API is designed for use with Astro's i18n routing guide.",
      "url": "/en/reference/modules/astro-i18n/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "modules",
        "internationalization"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/invalid-component-args",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/invalid-component-args.mdx",
      "title": "Invalid component arguments.",
      "summary": "**Astro components are rendered using a specific syntax, and manual function calls are not supported.** **Key features and APIs:** * InvalidComponentArgs error messages * Component syntax `` for rendering * Destructuring syntax `{items.map(item => )}` for rendering with props **Implementation details and use cases:** * Use `` syntax for rendering Astro components * Avoid manual function calls like `Component()` or `{items.map(Component)}` * Use destructuring syntax to pass props to components, e.g. `{items.map(item => )}`",
      "url": "/en/reference/errors/invalid-component-args/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "invalid",
        "component",
        "arguments."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/invalid-content-entry-slug-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/invalid-content-entry-slug-error.mdx",
      "title": "Invalid content entry slug.",
      "summary": "**Invalid Content Entry Slug Error** Astro components are designed to handle content collection entry validation, specifically detecting invalid `slug` fields. The `slug` field must be a string when present, and Astro provides the `Astro.props` API to access and validate entry properties, including `slug`. This error occurs when a collection entry has an invalid `slug` value, which is critical for generating entry slugs.",
      "url": "/en/reference/errors/invalid-content-entry-slug-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "invalid",
        "entry",
        "slug."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/invalid-dynamic-route",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/invalid-dynamic-route.mdx",
      "title": "Invalid dynamic route.",
      "summary": "**InvalidDynamicRoute**: The INVALID_PARAM param for route ROUTE is invalid. Received **RECEIVED**. **Purpose**: Detects and reports invalid dynamic route parameters. **Features**: Identifies undefined parameters and missing rest parameters in dynamic routes. **APIs/Methods**: Not applicable. **Implementation**: Triggers when a dynamic route param is invalid, often caused by an `undefined` parameter or missing rest parameter. **Use Cases**: Dynamic routes, routing guides, error handling.",
      "url": "/en/reference/errors/invalid-dynamic-route/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "invalid",
        "dynamic",
        "route."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/invalid-get-static-paths-entry",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/invalid-get-static-paths-entry.mdx",
      "title": "Invalid entry inside getStaticPaths return value",
      "summary": "**getStaticPaths returns an array of objects, not an array of arrays** `getStaticPaths` expects an array of objects as its return value, but received an array of arrays. This error can be resolved by using the `flatMap()` or `flat()` method to flatten the array. For example, in a `pages/blog/[id].astro` file, the `getStaticPaths` function should return an array of objects, like this: `return [{ params: { slug: \"blog\" } }, { params: { slug: \"about\" } }];`.",
      "url": "/en/reference/errors/invalid-get-static-paths-entry/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "invalid",
        "entry",
        "inside",
        "getstaticpaths"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/env-invalid-variable",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/env-invalid-variable.mdx",
      "title": "Invalid Environment Variable",
      "summary": "**Invalid Environment Variable Error** `EnvInvalidVariable` error occurs when an environment variable does not match the data type and/or properties defined in `experimental.env.schema`. This error is triggered when the `KEY` does not match the expected `TYPE`. The error is critical and requires attention to resolve.",
      "url": "/en/reference/errors/env-invalid-variable/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "invalid",
        "environment",
        "variable"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/env-invalid-variables",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/env-invalid-variables.mdx",
      "title": "Invalid Environment Variables",
      "summary": "Astro components are used to render dynamic content and handle environment variables, but invalid environment variables defined in `env.schema` can cause errors. Invalid environment variables are detected when they do not match the data type and/or properties defined in `env.schema`, resulting in a critical error. The `env.schema` file is used to define the expected structure and types of environment variables, and Astro provides the `env` object to access these variables.",
      "url": "/en/reference/errors/env-invalid-variables/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "invalid",
        "environment",
        "variables"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/invalid-frontmatter-injection-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/invalid-frontmatter-injection-error.mdx",
      "title": "Invalid frontmatter injection.",
      "summary": "**InvalidFrontmatterInjectionError**: A remark or rehype plugin attempted to inject invalid frontmatter. This occurs when \"astro.frontmatter\" is set to `null`, `undefined`, or an invalid JSON object. Ensure \"astro.frontmatter\" is a valid JSON object to resolve the issue.",
      "url": "/en/reference/errors/invalid-frontmatter-injection-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "invalid",
        "frontmatter",
        "injection."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/invalid-glob",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/invalid-glob.mdx",
      "title": "Invalid glob pattern.",
      "summary": "**InvalidGlob Error** Astro components are unable to resolve invalid glob patterns, which must start with './', '../' or '/'. The error is triggered by the `InvalidGlob` component, which is caused by an invalid glob pattern in the Astro component, often due to a non-existent or incorrectly formatted file path. This can be resolved by correcting the glob pattern to a valid file path.",
      "url": "/en/reference/errors/invalid-glob/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "invalid",
        "glob",
        "pattern."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/invalid-prerender-export",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/invalid-prerender-export.mdx",
      "title": "Invalid prerender export.",
      "summary": "**Invalid Prerender Export** Astro components are restricted from using dynamic JavaScript in prerender exports, which must be statically analyzable. Specifically, prerender exports can only contain the exact `export const prerender = true` statement, and do not support variables, `let`, or `var` declarations. This restriction is enforced to ensure accurate static analysis and compilation of prerendered content.",
      "url": "/en/reference/errors/invalid-prerender-export/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "invalid",
        "prerender",
        "export."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/reserved-slot-name",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/reserved-slot-name.mdx",
      "title": "Invalid slot name.",
      "summary": "**Reserved Slot Names in Astro Components** Astro components are unable to create slots with names that conflict with internal reserved names, such as `SLOT_NAME`, due to being used internally. This is resolved by updating the slot name to a non-conflicting value. The `ReservedSlotName` error is triggered when attempting to create a slot with a reserved name, and can be resolved by updating the slot name using the `slot` attribute.",
      "url": "/en/reference/errors/reserved-slot-name/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "invalid",
        "slot",
        "name."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/only-response-can-be-returned",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/only-response-can-be-returned.mdx",
      "title": "Invalid type returned by Astro page.",
      "summary": "**Astro page return type validation** Astro components are designed to return a Response instance, which can be a plain Response object or an instance returned by Astro.redirect. The `return` statement in Astro files must yield a Response, such as `new Response(null, { status: 404, statusText: 'Not found' })` or `Astro.redirect('/login')`. This ensures that only valid Response instances are returned from Astro pages.",
      "url": "/en/reference/errors/only-response-can-be-returned/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "invalid",
        "type",
        "returned",
        "astro"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/get-entry-deprecation-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/get-entry-deprecation-error.mdx",
      "title": "Invalid use of getDataEntryById or getEntryBySlug function.",
      "summary": "**getEntry function is the recommended replacement for getDataEntryById and getEntryBySlug functions.** The `getEntry` function is used to query content layer collections, replacing the deprecated `getDataEntryById` and `getEntryBySlug` functions. This function is part of the Astro API, allowing developers to retrieve entries by ID or slug. Implementation details include using `getEntry` with the `collection` parameter to specify the collection to query. Use cases include retrieving entries for rendering in Astro components, such as the `DontEditWarning` component.",
      "url": "/en/reference/errors/get-entry-deprecation-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "invalid",
        "getdataentrybyid",
        "getentrybyslug",
        "function."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/get-static-paths-invalid-route-param",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/get-static-paths-invalid-route-param.mdx",
      "title": "Invalid value for getStaticPaths route parameter.",
      "summary": "**Astro components are designed to handle static site generation with routing, but may throw an error when getStaticPaths route parameter is invalid.** **Specifically, getStaticPaths route parameter must be undefined, a string, or a number, but received VALUE_TYPE (VALUE) instead.** **Implementation details and use cases include:** * Using `undefined` to represent a path with no parameters passed in the URL for routes with rest parameters. * Supported types for `params` in getStaticPaths include strings and numbers. * Refer to `getStaticPaths()` and `params` API documentation for more information.",
      "url": "/en/reference/errors/get-static-paths-invalid-route-param/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "invalid",
        "value",
        "getstaticpaths",
        "route"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/invalid-get-static-path-param",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/invalid-get-static-path-param.mdx",
      "title": "Invalid value returned by a getStaticPaths path.",
      "summary": "**Invalid value returned by a getStaticPaths path.** Astro components are designed to handle dynamic routes with `getStaticPaths`, which returns an array of objects containing `params` properties. However, an invalid value is returned when `params` is not an object, causing an error. This occurs when the `params` property in the `getStaticPaths` return value is not an object, violating the expected type.",
      "url": "/en/reference/errors/invalid-get-static-path-param/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "invalid",
        "value",
        "returned",
        "getstaticpaths"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/invalid-get-static-paths-return",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/invalid-get-static-paths-return.mdx",
      "title": "Invalid value returned by getStaticPaths.",
      "summary": "**getStaticPaths Functionality** Astro components are designed to handle server-side rendering and static site generation, with `getStaticPaths` being a critical function for pre-rendering pages at build time. This function returns an array of objects, where each object contains a `params` property, which is used to define the routes for a page. The `getStaticPaths` function must return an array, with each item being an object containing a `params` property, to ensure proper routing and static site generation. **Key Features and APIs** * `getStaticPaths` function returns an array of objects * Each object in the array must contain a `params` property * `params` property is used to define routes for a page * Implementation details: `getStaticPaths` must be an async function that returns an array of objects * Use cases: pre-rendering pages at build time, defining routes for a page **Technical Keywords** * `getStaticPaths` * `server-side rendering` * `static site generation` * `routing` * `params` property * `array` * `async function`",
      "url": "/en/reference/errors/invalid-get-static-paths-return/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "invalid",
        "value",
        "returned",
        "getstaticpaths."
      ],
      "type": "guide"
    },
    {
      "id": "concepts/islands",
      "language": "en",
      "filePath": "src/content/docs/en/concepts/islands.mdx",
      "title": "Islands architecture",
      "summary": "**Islands Architecture** Astro components are designed to implement Islands Architecture, a frontend pattern that renders static HTML with smaller \"islands\" of JavaScript added for interactivity and personalization. This approach avoids monolithic JavaScript payloads, improving page responsiveness. Key features include selective hydration, partial rendering, and strategic injection of dynamic regions. **Implementation Details** * Astro uses selective hydration to render HTML pages on the server and inject placeholders for dynamic regions. * Islands Architecture builds on the technique of partial or selective hydration. * Astro's Islands Architecture is designed to improve page-load performance by reducing client-side JavaScript usage. **APIs and Methods** * Astro's Islands Architecture is implemented using Astro.props and other APIs. * getStaticPaths is used to generate static HTML for the majority of the page. * IslandsDiagram and ReadMore components are examples of Astro components that utilize Islands Architecture. **Use Cases** * Islands Architecture is suitable for most web projects that require a balance between simplicity, power, and performance. * This approach is particularly effective for rendering complex, interactive components, such as image carousels, while keeping the rest of the page fast and responsive.",
      "url": "/en/concepts/islands/",
      "keywords": [
        "content",
        "docs",
        "concepts",
        "islands",
        "architecture"
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/keystatic",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/keystatic.mdx",
      "title": "Keystatic & Astro",
      "summary": "**Keystatic & Astro Integration** Keystatic & Astro components are used to add content to Astro projects using Keystatic as a headless CMS, enabling internationalization and content structuring. Key features include: * `getStaticPaths` API for generating static paths * `Astro.props` for accessing Keystatic content * Integration with Markdoc for content entries and React for the Keystatic Admin UI Dashboard * Support for GitHub syncing with write permissions required Implementation details include installing dependencies using `astro add` and `npm install`/`pnpm add` for Keystatic packages. Use cases include starting a new Astro + Keystatic project from scratch using the Keystatic CLI and deploying the project.",
      "url": "/en/guides/cms/keystatic/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "keystatic",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/cms/keystonejs",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/keystonejs.mdx",
      "title": "KeystoneJS & Astro",
      "summary": "KeystoneJS & Astro integrates KeystoneJS as a headless CMS to manage content in Astro projects, enabling schema-driven content modeling and API-based content retrieval. Key features include: * KeystoneJS schema definition for content modeling * Astro.props API for accessing KeystoneJS data * getStaticPaths method for server-side rendering with KeystoneJS data * Support for internationalization (i18n) and localization (L10n) Implementation involves setting up KeystoneJS as a CMS, defining a schema, and using Astro.props to access and render KeystoneJS data in Astro components. Use cases include building content-driven websites, blogs, and applications with KeystoneJS as a centralized content repository.",
      "url": "/en/guides/cms/keystonejs/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "keystonejs",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/cms/kontent-ai",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/kontent-ai.mdx",
      "title": "Kontent.ai & Astro",
      "summary": "**Kontent.ai & Astro Integration** Kontent.ai & Astro components are used to add content to Astro projects using Kontent.ai as a headless CMS, enabling internationalization and structured content management with AI capabilities. **Key Features and APIs** * `Kontent.ai TypeScript SDK` for connecting Kontent.ai projects to Astro applications * `Environment ID` and `Preview API key` for authentication * `.env` file for storing Kontent.ai credentials * `env.d.ts` file for TypeScript IntelliSense configuration * `ImportMetaEnv` interface for environment variable type checking **Implementation Details and Use Cases** * Connect Kontent.ai project to Astro application using Kontent.ai TypeScript SDK * Use environment variables to authenticate with Kontent.ai * Configure TypeScript IntelliSense for environment variables using `env.d.ts` file * Install Kontent.ai TypeScript SDK as a dependency in Astro project",
      "url": "/en/guides/cms/kontent-ai/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "kontent.ai",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "basics/layouts",
      "language": "en",
      "filePath": "src/content/docs/en/basics/layouts.mdx",
      "title": "Layouts",
      "summary": "**Layouts are Astro components used to provide a reusable UI structure, such as a page template, with features including page shells, slots, and support for props and imported components.** **Key features and APIs:** * Provides a page shell (``, ``, and `` tags) * Uses `` to specify where individual page content should be injected * Accepts props (`Astro.props`) * Can import and use other components * Can include UI frameworks components and client-side scripts * Can be used as partial UI templates or full page templates **Implementation details and use cases:** * Typically placed in a `src/layouts` directory for organization * Can be colocated with pages by prefixing layout names with `_` * Must have `` element as parent of all other elements if providing a full page shell",
      "url": "/en/basics/layouts/",
      "keywords": [
        "content",
        "docs",
        "basics",
        "layouts"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/config-legacy-key",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/config-legacy-key.mdx",
      "title": "Legacy configuration detected.",
      "summary": "**Legacy Configuration Detection** Astro components are designed to detect and handle legacy configuration options in configuration files, providing a seamless transition to modern configurations. Key features include the `ConfigLegacyKey` API, which outputs a warning message indicating the legacy configuration detected, and the `DontEditWarning` component, which displays a warning to users. Implementation details involve integrating the `ConfigLegacyKey` API with the `DontEditWarning` component to display the warning message. Use cases include migrating legacy configurations to modern configurations, ensuring a smooth transition for users.",
      "url": "/en/reference/errors/config-legacy-key/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "legacy",
        "configuration",
        "detected."
      ],
      "type": "guide"
    },
    {
      "id": "reference/legacy-flags",
      "language": "en",
      "filePath": "src/content/docs/en/reference/legacy-flags.mdx",
      "title": "Legacy flags",
      "summary": "**Legacy Flags** Legacy flags allow users to opt-in to deprecated or outdated behavior in Astro, enabling continued upgrade and new release adoption until full project code updates are feasible. **Features and APIs** * `legacy.collections`: a boolean flag (default: `false`) enabling legacy behavior for content collections (Astro v2-v4) * `astro.config.mjs` configuration option for enabling legacy collections * Limitations: + Legacy collections must be in `src/content/` directory + Legacy collections will not use `glob()` loader + Collections using Content Layer API are forbidden in `src/content/` **Implementation Details and Use Cases** * Enable legacy collections for content collections in Astro v2-v4 * Use `astro.config.mjs` to configure legacy behavior * Migrate to new Content Layer API for legacy collections by defining an empty collection in `src/content/config.ts`",
      "url": "/en/reference/legacy-flags/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "legacy",
        "flags"
      ],
      "type": "guide"
    },
    {
      "id": "guides/upgrade-to/v1",
      "language": "en",
      "filePath": "src/content/docs/en/guides/upgrade-to/v1.mdx",
      "title": "Legacy v0.x Upgrade Guide",
      "summary": "**Legacy v0.x Upgrade Guide** Astro components are designed to be upgraded through breaking changes in pre-v1 versions of Astro. **Key Features and APIs:** * `Astro.props` and `Astro.url` helpers for constructing canonical URLs * `Astro.url` helper for constructing URLs from the current page/request URL * `Vite 3` upgrade with handled changes and potential subtle differences * `Astro.canonicalURL` deprecated in favor of `Astro.url` helper **Implementation Details and Use Cases:** * Update Astro and integrations to the latest version using package managers (npm, pnpm, yarn) * Handle breaking changes in pre-v1 versions of Astro, including Vite 3 upgrade and deprecated `Astro.canonicalURL` API * Use `Astro.url` helper to construct canonical URLs from the current page/request URL",
      "url": "/en/guides/upgrade-to/v1/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "upgrade to",
        "legacy",
        "v0.x",
        "upgrade",
        "guide"
      ],
      "type": "guide"
    },
    {
      "id": "guides/integrations-guide/lit",
      "language": "en",
      "filePath": "src/content/docs/en/guides/integrations-guide/lit.mdx",
      "title": "Lit",
      "summary": "Lit components are used to extend Astro project support for custom elements, enabling on-demand rendering and client-side hydration. Key features include Astro.props, LitElement, and client-side hydration, with implementation details involving adding a client-side script tag and importing custom elements. This integration is deprecated in Astro 5.0, but can be maintained by using the last published version of `@astrojs/lit` as a starting point.",
      "url": "/en/guides/integrations-guide/lit/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/local-image-used-wrongly",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/local-image-used-wrongly.mdx",
      "title": "Local images must be imported.",
      "summary": "**Local Images Must Be Imported** Local images must be imported using the `import` statement or a URL, and cannot be referenced by a string filepath. This applies to `Image` and `getImage` components, which require a full image object or a URL as the `src` parameter. Use the `image()` schema helper for local images from content collections to resolve images correctly.",
      "url": "/en/reference/errors/local-image-used-wrongly/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "local",
        "images",
        "must",
        "imported."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/locals-reassigned",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/locals-reassigned.mdx",
      "title": "locals must not be reassigned.",
      "summary": "**LocalsMustNotBeReassigned**: Astro components enforce that `locals` cannot be reassigned directly, throwing an error when attempting to set a value as the `locals` field on the Astro global or context. **Key Features and APIs**: * `locals` field on Astro global or context cannot be reassigned * Error thrown when attempting to set a value as `locals` **Implementation Details and Use Cases**: * Implemented to prevent unintended modifications to component state * Use cases include preventing accidental reassignment of component data",
      "url": "/en/reference/errors/locals-reassigned/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "locals",
        "must",
        "reassigned."
      ],
      "type": "guide"
    },
    {
      "id": "tutorial/3-components/1",
      "language": "en",
      "filePath": "src/content/docs/en/tutorial/3-components/1.mdx",
      "title": "Make a reusable Navigation component",
      "summary": "**Reusable Navigation Component** Astro components are used to create reusable UI components that can be easily imported and used across multiple pages. **Key Features and APIs** * `Navigation.astro` file: a reusable Astro component for displaying navigation links * `import` statement: imports the `Navigation` component from `src/components/Navigation.astro` * `use` statement: uses the `Navigation` component in `index.astro` **Implementation Details and Use Cases** * Create a new `src/components/` folder to hold reusable Astro components * Create a new file `Navigation.astro` to define the navigation component * Import and use the `Navigation` component in other Astro files, such as `index.astro` * Replace existing navigation HTML link elements with the new reusable navigation component.",
      "url": "/en/tutorial/3-components/1/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "3 components",
        "make",
        "reusable",
        "navigation",
        "component"
      ],
      "type": "tutorial"
    },
    {
      "id": "guides/markdown-content",
      "language": "en",
      "filePath": "src/content/docs/en/guides/markdown-content.mdx",
      "title": "Markdown in Astro",
      "summary": "**Markdown in Astro** Astro components are designed to render Markdown files with frontmatter YAML or TOML properties, enabling content authors to write text-heavy content like blog posts and documentation. Key features include: * Support for GitHub Flavored Markdown * Frontmatter YAML or TOML properties for custom metadata * Local file imports using `import` statements or `import.meta.glob()` * Querying and rendering Markdown content from data fetched by content collections helper functions Implementation details include organizing Markdown files within the `src/` directory, with automatic generation of Markdown pages in `src/pages/`.",
      "url": "/en/guides/markdown-content/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "markdown",
        "astro"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/mdx-integration-missing-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/mdx-integration-missing-error.mdx",
      "title": "MDX integration missing.",
      "summary": "**Astro components are unable to render MDX files without the `@astrojs/mdx` integration installed.** **Key features and APIs:** * `@astrojs/mdx` integration required for MDX file rendering * `MdxIntegrationMissingError` raised when integration is not installed * `getStaticPaths` and `Astro.props` methods affected by missing integration **Implementation details and use cases:** * Ensure `@astrojs/mdx` is installed to render MDX files * Use `@astrojs/mdx` integration for internationalization and MDX file rendering * Refer to [MDX installation and usage](/en/guides/integrations-guide/mdx/) for setup instructions",
      "url": "/en/reference/errors/mdx-integration-missing-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "integration",
        "missing."
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/microcms",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/microcms.mdx",
      "title": "microCMS & Astro",
      "summary": "**microCMS & Astro Integration** microCMS & Astro components are used to add content to Astro projects using a headless CMS, enabling API-based content management and schema-driven content definition. Key features include Astro.props for accessing microCMS data, getStaticPaths for server-side rendering, and microCMS API integration for content management and schema definition. This integration is suitable for use cases such as building blogs, websites, and applications requiring dynamic content management.",
      "url": "/en/guides/cms/microcms/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "microcms",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/middleware",
      "language": "en",
      "filePath": "src/content/docs/en/guides/middleware.mdx",
      "title": "Middleware",
      "summary": "**Middleware** allows you to intercept requests and responses and inject behaviors dynamically every time a page or endpoint is about to be rendered, utilizing features like cookies and headers. This is achieved through the `onRequest()` function, which can be passed a `context` object and `next()` function, allowing you to mutate a `locals` object available in all Astro components and API endpoints. The `context` object includes information to be made available to other middleware, API routes, and `.astro` routes during the rendering process.",
      "url": "/en/guides/middleware/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "middleware"
      ],
      "type": "guide"
    },
    {
      "id": "reference/modules/astro-middleware",
      "language": "en",
      "filePath": "src/content/docs/en/reference/modules/astro-middleware.mdx",
      "title": "Middleware API Reference",
      "summary": "**Middleware API Reference** Middleware allows you to intercept requests and responses and inject behaviors dynamically every time a page or endpoint is about to be rendered. The Astro middleware API provides several features and utilities for implementing middleware, including `defineMiddleware()`, `sequence()`, `createContext()`, and `trySerializeLocals()`. **Key Features and APIs** * `defineMiddleware()`: a utility function for defining middleware with type safety * `sequence()`: a function for executing middleware functions in a specific order * `createContext()`: a low-level API for creating an `APIContext` to be passed to an Astro middleware `onRequest()` function * `trySerializeLocals()`: a low-level API for serializing values to strings **Implementation Details and Use Cases** Middleware can be used to implement features such as authentication, validation, and logging. The `sequence()` function can be used to chain multiple middleware functions together, while `createContext()` and `trySerializeLocals()` provide low-level APIs for working with Astro's middleware context.",
      "url": "/en/reference/modules/astro-middleware/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "modules",
        "middleware"
      ],
      "type": "guide"
    },
    {
      "id": "guides/migrate-to-astro/index",
      "language": "en",
      "filePath": "src/content/docs/en/guides/migrate-to-astro/index.mdx",
      "title": "Migrate an existing project to Astro",
      "summary": "**Astro components are a set of reusable UI elements that can be used to build fast, scalable, and maintainable web applications.** **Key features include:** * Integration with popular UI framework components, CSS stylesheets, and Markdown/MDX files * Support for content from headless CMSes and eCommerce shop carts * Complete control over project rendering with on-demand rendering capabilities * Astro Islands for efficient rendering of complex UI components **Implementation details:** * Use Astro's official and community integrations for UI framework components, CSS stylesheets, and Markdown/MDX files * Leverage Astro's on-demand rendering capabilities for dynamic apps and routes * Design in Astro Islands to optimize performance and scalability **Use cases:** * Migrate existing content-based sites like blogs, landing pages, marketing sites, and portfolios to Astro * Build fast and scalable web applications with Astro's reusable UI elements and on-demand rendering capabilities * Integrate Astro with popular headless CMSes and eCommerce shop carts for seamless content management",
      "url": "/en/guides/migrate-to-astro/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "migrate to astro",
        "migrate",
        "existing",
        "project",
        "astro"
      ],
      "type": "guide"
    },
    {
      "id": "guides/migrate-to-astro/from-create-react-app",
      "language": "en",
      "filePath": "src/content/docs/en/guides/migrate-to-astro/from-create-react-app.mdx",
      "title": "Migrating from Create React App (CRA)",
      "summary": "**Astro components are a powerful framework for building fast, scalable, and secure web applications, providing a seamless integration with React components and existing Create React App (CRA) projects.** **Key features include:** * Support for using React components inside Astro components, including entire React apps like CRA * Client directives for loading React apps * File-based routing with dynamic routes * Component-based markup structure * Similar syntax to JSX in `.astro` files **Implementation details and use cases:** * Importing and using React components in Astro components * Using client directives to load React apps * Converting CRA projects to Astro by adding the React integration and migrating to a combination of `.astro` and `.jsx` components.",
      "url": "/en/guides/migrate-to-astro/from-create-react-app/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "migrate to astro",
        "migration",
        "migrating",
        "from",
        "create"
      ],
      "type": "migration"
    },
    {
      "id": "guides/migrate-to-astro/from-docusaurus",
      "language": "en",
      "filePath": "src/content/docs/en/guides/migrate-to-astro/from-docusaurus.mdx",
      "title": "Migrating from Docusaurus",
      "summary": "**Migrating from Docusaurus** Astro components are modern, JavaScript-based site builders for content-driven websites, similar to Docusaurus, supporting MDX pages, file-based routing, and React components with JSX-like syntax. Key features include Astro.props, getStaticPaths, and Astro's JSX-like syntax, allowing for seamless integration with existing React components and dependencies. Astro also supports installing NPM packages and has official integrations for various frameworks, including React, Preact, and Vue.js.",
      "url": "/en/guides/migrate-to-astro/from-docusaurus/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "migrate to astro",
        "migration",
        "migrating",
        "from",
        "docusaurus"
      ],
      "type": "migration"
    },
    {
      "id": "guides/migrate-to-astro/from-eleventy",
      "language": "en",
      "filePath": "src/content/docs/en/guides/migrate-to-astro/from-eleventy.mdx",
      "title": "Migrating from Eleventy",
      "summary": "**Migrating from Eleventy** Astro components are a replacement for Eleventy templates, utilizing Astro layouts, pages, and components for page templating, and supporting inclusion of components from popular JS frameworks. Key features include Astro.props, Astro.getStaticPaths, and Astro.getStaticProps, which provide a more streamlined and efficient way to manage site metadata, routing, and data fetching. Astro's project structure, with a `src/` directory for querying and processing site metadata, and a `public/` folder for static assets, differs from Eleventy's approach.",
      "url": "/en/guides/migrate-to-astro/from-eleventy/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "migrate to astro",
        "migration",
        "migrating",
        "from",
        "eleventy"
      ],
      "type": "migration"
    },
    {
      "id": "guides/migrate-to-astro/from-gatsby",
      "language": "en",
      "filePath": "src/content/docs/en/guides/migrate-to-astro/from-gatsby.mdx",
      "title": "Migrating from Gatsby",
      "summary": "**Migrating from Gatsby to Astro** Astro components are reusable, server-side rendered, and statically generated UI components that can be written in a JSX-like syntax, similar to Gatsby. Key features include support for Markdown and MDX files, React component integration, and NPM package installation, with APIs such as `Astro.props` and `getStaticPaths` for page-level prerendering. Astro projects can be built as multi-page sites with a `index.astro` home page, using ESM imports for local file data, and differ from Gatsby projects in their component structure and file organization.",
      "url": "/en/guides/migrate-to-astro/from-gatsby/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "migrate to astro",
        "migration",
        "migrating",
        "from",
        "gatsby"
      ],
      "type": "migration"
    },
    {
      "id": "guides/migrate-to-astro/from-gitbook",
      "language": "en",
      "filePath": "src/content/docs/en/guides/migrate-to-astro/from-gitbook.mdx",
      "title": "Migrating from GitBook",
      "summary": "**Migrating from GitBook** Astro components are designed to support Markdown content, file-based routing, and customizable features, making it an ideal platform for migrating existing GitBook projects. Key similarities include support for Markdown and file-based routing, while differences include the use of a code editor and development environment, individual file storage, and optional Markdoc integration. To migrate, start with the official Starlight docs theme starter template or explore community docs themes in the Astro theme showcase.",
      "url": "/en/guides/migrate-to-astro/from-gitbook/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "migrate to astro",
        "migration",
        "migrating",
        "from",
        "gitbook"
      ],
      "type": "migration"
    },
    {
      "id": "guides/migrate-to-astro/from-gridsome",
      "language": "en",
      "filePath": "src/content/docs/en/guides/migrate-to-astro/from-gridsome.mdx",
      "title": "Migrating from Gridsome",
      "summary": "**Migrating from Gridsome** Astro components are a replacement for Gridsome's Vue-based single-page application (SPA) structure, utilizing `.astro` components for multi-page app building, with support for various frameworks and raw HTML templating. Key features include Astro.props, getStaticPaths, and integration with Vue components, NPM packages, and headless CMS, APIs, or Markdown files for data. Implementation details involve creating separate HTML pages, controlling page `` directly or in a layout component, and leveraging Astro's framework-agnostic architecture.",
      "url": "/en/guides/migrate-to-astro/from-gridsome/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "migrate to astro",
        "migration",
        "migrating",
        "from",
        "gridsome"
      ],
      "type": "migration"
    },
    {
      "id": "guides/migrate-to-astro/from-hugo",
      "language": "en",
      "filePath": "src/content/docs/en/guides/migrate-to-astro/from-hugo.mdx",
      "title": "Migrating from Hugo",
      "summary": "**Migrating from Hugo to Astro** Astro components are a superset of HTML, using JSX-like syntax for page templating, unlike Hugo's Go Templating. Key similarities include content-driven websites, Markdown authoring, and integrations with external packages. Key differences include Astro's component-based architecture, MDX integration for dynamic content, and support for other UI framework components.",
      "url": "/en/guides/migrate-to-astro/from-hugo/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "migrate to astro",
        "migration",
        "migrating",
        "from",
        "hugo"
      ],
      "type": "migration"
    },
    {
      "id": "guides/migrate-to-astro/from-jekyll",
      "language": "en",
      "filePath": "src/content/docs/en/guides/migrate-to-astro/from-jekyll.mdx",
      "title": "Migrating from Jekyll",
      "summary": "**Migrating from Jekyll** Astro components are a replacement for Jekyll's Liquid templates, utilizing JSX-like `.astro` files for templating and components. Key features include Astro.props, Astro components, and file-based routing, which can be used to create pages from blog posts. Astro provides a `src/pages/` directory for all pages and posts, similar to Jekyll's `_posts/` directory, but with additional support for layouts and components.",
      "url": "/en/guides/migrate-to-astro/from-jekyll/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "migrate to astro",
        "migration",
        "migrating",
        "from",
        "jekyll"
      ],
      "type": "migration"
    },
    {
      "id": "guides/migrate-to-astro/from-nextjs",
      "language": "en",
      "filePath": "src/content/docs/en/guides/migrate-to-astro/from-nextjs.mdx",
      "title": "Migrating from Next.js",
      "summary": "**Astro components are a set of reusable UI components that can be used to build fast, scalable, and secure websites and applications.** **Key features and APIs include:** * `getStaticPaths` for server-side rendering and static site generation * `Astro.props` for accessing component props and metadata * Support for React, Preact, and Solid integrations through official integrations and JSX/TSX file extensions * File-based routing with dynamic routes and specially named pages * Component-based architecture with code fences for JavaScript and HTML generation **Implementation details and use cases include:** * Using Astro's syntax, which is similar to JSX, for writing Astro components * Leveraging Astro's support for SSG and SSR with page-level prerendering * Utilizing Astro's official integrations for React, Preact, and Solid to reuse existing JSX components * Installing NPM packages, including React libraries, to work with existing dependencies",
      "url": "/en/guides/migrate-to-astro/from-nextjs/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "migrate to astro",
        "migration",
        "migrating",
        "from",
        "next.js"
      ],
      "type": "migration"
    },
    {
      "id": "guides/migrate-to-astro/from-nuxtjs",
      "language": "en",
      "filePath": "src/content/docs/en/guides/migrate-to-astro/from-nuxtjs.mdx",
      "title": "Migrating from NuxtJS",
      "summary": "**Migrating from NuxtJS** Astro components are a replacement for Nuxt's Vue-based SPA architecture, offering multi-page app support for various frameworks, including Vue.js, React, and Svelte. Key features include file-based routing, dynamic routes, and support for Vue components through official integrations. Astro's component-based structure and support for NPM packages allow for a seamless migration of existing Vue components and dependencies.",
      "url": "/en/guides/migrate-to-astro/from-nuxtjs/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "migrate to astro",
        "migration",
        "migrating",
        "from",
        "nuxtjs"
      ],
      "type": "migration"
    },
    {
      "id": "guides/migrate-to-astro/from-pelican",
      "language": "en",
      "filePath": "src/content/docs/en/guides/migrate-to-astro/from-pelican.mdx",
      "title": "Migrating from Pelican",
      "summary": "**Migrating from Pelican** Astro components are a superset of HTML, utilizing JSX-like syntax for templating, whereas Pelican uses HTML files and Jinja syntax. Astro supports creating pages from Markdown and MDX files, whereas Pelican supports Markdown and reStructured Text. Key similarities include built-in support for writing in Markdown and frontmatter YAML properties for page metadata. **Key APIs and Methods** * `Astro.props` for accessing page metadata * `getStaticPaths` for generating static site paths * `createPages` for creating pages from Markdown and MDX files **Implementation Details and Use Cases** * Use the official Starlight docs theme starter template or community themes for a smooth migration * Pass a `--template` argument to the Astro CLI for custom template generation * Utilize Astro's built-in support for Markdown and MDX files for content creation",
      "url": "/en/guides/migrate-to-astro/from-pelican/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "migrate to astro",
        "migration",
        "migrating",
        "from",
        "pelican"
      ],
      "type": "migration"
    },
    {
      "id": "guides/migrate-to-astro/from-sveltekit",
      "language": "en",
      "filePath": "src/content/docs/en/guides/migrate-to-astro/from-sveltekit.mdx",
      "title": "Migrating from SvelteKit",
      "summary": "**Migrating from SvelteKit** Astro components are a modern JavaScript static-site generator and server-side rendering framework, similar to SvelteKit, with key similarities including a `src/` folder for project files, file-based routing, and support for Svelte components and NPM packages. Astro allows for using Svelte UI components, headless CMS, APIs, or Markdown files for data, and supports multiple frameworks including React, Preact, Vue.js, Svelte, SolidJS, AlpineJS, and raw HTML templating. Astro sites are multi-page apps, whereas SvelteKit defaults to SPAs with server-side rendering, but can also create MPAs or mix techniques within an app.",
      "url": "/en/guides/migrate-to-astro/from-sveltekit/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "migrate to astro",
        "migration",
        "migrating",
        "from",
        "sveltekit"
      ],
      "type": "migration"
    },
    {
      "id": "guides/migrate-to-astro/from-vuepress",
      "language": "en",
      "filePath": "src/content/docs/en/guides/migrate-to-astro/from-vuepress.mdx",
      "title": "Migrating from VuePress",
      "summary": "**Astro components are modern, reusable UI elements for building static websites and web applications, designed for content-driven websites and supporting various frameworks and libraries.** **Key features and APIs include:** * `.astro` components for building pages, layouts, and UI elements * Support for Markdown files and `.mdx` files for content-driven websites * Integration with Vue components and NPM packages * Framework-agnostic support for React, Preact, Vue.js, Svelte, SolidJS, AlpineJS, and raw HTML templating * Layout templates using Astro components and HTML templating **Implementation details and use cases:** * Astro sites are multi-page apps built using `.astro` components, with support for file-based routing and content-driven websites * Astro can create pages from Markdown and MDX files, using an Astro layout component for wrapping * Astro supports installing NPM packages, including Vue packages, for writing Vue UI components and keeping existing Vue components and dependencies.",
      "url": "/en/guides/migrate-to-astro/from-vuepress/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "migrate to astro",
        "migration",
        "migrating",
        "from",
        "vuepress"
      ],
      "type": "migration"
    },
    {
      "id": "guides/migrate-to-astro/from-wordpress",
      "language": "en",
      "filePath": "src/content/docs/en/guides/migrate-to-astro/from-wordpress.mdx",
      "title": "Migrating from WordPress",
      "summary": "**Migrating from WordPress** Astro components are a replacement for WordPress plugins and themes, allowing for a more flexible and customizable content-driven website. Key features include Astro.props, getStaticPaths, and Astro components, which can be used to create custom blocks and layouts. Implementation details involve writing code in a code editor and development environment, using Markdown files for content, and leveraging Astro's integrations and themes.",
      "url": "/en/guides/migrate-to-astro/from-wordpress/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "migrate to astro",
        "migration",
        "migrating",
        "from",
        "wordpress"
      ],
      "type": "migration"
    },
    {
      "id": "reference/errors/no-client-only-hint",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/no-client-only-hint.mdx",
      "title": "Missing hint on client:only directive.",
      "summary": "**Astro components require a hint when using the `client:only` directive.** When using the `client:only` hydration strategy, Astro needs a hint to use the correct renderer, which is specified using the `client:only` directive with a value, such as ``. This hint is required to prevent errors like \"Unable to render `COMPONENT_NAME`\" and ensure correct rendering of client-only components.",
      "url": "/en/reference/errors/no-client-only-hint/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "missing",
        "hint",
        "client:only",
        "directive."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/missing-image-dimension",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/missing-image-dimension.mdx",
      "title": "Missing image dimensions",
      "summary": "Astro components require explicit width and height attributes for remote images to avoid cumulative layout shift (CLS). This can be achieved by specifying the dimensions or setting `inferSize` to `true` to fetch the original dimensions. The `width` and `height` properties are required for images in the public folder, and can be inferred for local images using the `inferSize` option.",
      "url": "/en/reference/errors/missing-image-dimension/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "missing",
        "image",
        "dimensions"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/get-static-paths-expected-params",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/get-static-paths-expected-params.mdx",
      "title": "Missing params property on getStaticPaths route.",
      "summary": "**Astro components are designed to handle server-side rendering and static site generation, but require a `params` property on `getStaticPaths` routes to specify path parameters.** **Key features and APIs include:** * `getStaticPaths` method to generate static routes * `params` property to specify path parameters * Implementation details involve returning an array of objects with `params` property from `getStaticPaths` function * Use cases include creating routes with dynamic parameters, such as `site.com/blog/1` **Technical keywords:** Astro, server-side rendering, static site generation, getStaticPaths, params property, path parameters.",
      "url": "/en/reference/errors/get-static-paths-expected-params/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "missing",
        "params",
        "property",
        "getstaticpaths"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/missing-media-query-directive",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/missing-media-query-directive.mdx",
      "title": "Missing value for client:media directive.",
      "summary": "**Missing value for client:media directive** The `client:media` directive requires a media query parameter, such as `(max-width: 600px)`, to be provided. This parameter is used to specify the media query for the directive. The `client:media` directive is used in Astro components, and its usage is documented in the Astro reference documentation.",
      "url": "/en/reference/errors/missing-media-query-directive/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "missing",
        "value",
        "client:media",
        "directive."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/server-only-module",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/server-only-module.mdx",
      "title": "Module is only available server-side",
      "summary": "**ServerOnlyModule**: The \"NAME\" module is only available server-side, utilizing Astro's server-side rendering capabilities. Key features include Astro components, server-only rendering, and internationalization support. The `ServerOnlyModule` can be implemented using Astro's built-in `ServerOnly` component, which enables server-side rendering of components, and can be used in conjunction with APIs such as `getStaticPaths` and `Astro.props` to manage data fetching and component props.",
      "url": "/en/reference/errors/server-only-module/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "module",
        "only",
        "available",
        "server-side"
      ],
      "type": "guide"
    },
    {
      "id": "guides/backend/sentry",
      "language": "en",
      "filePath": "src/content/docs/en/guides/backend/sentry.mdx",
      "title": "Monitor your Astro Site with Sentry",
      "summary": "**Astro components are integrated with Sentry for comprehensive application monitoring and error tracking.** **Key features and APIs include:** * Automatic error reporting and tracing data collection using the Sentry Astro SDK * Integration with Astro CLI for easy installation and configuration * Support for various package managers (npm, pnpm, yarn) * Configuration options for client key (DSN), project name, and auth token in `astro.config.mjs` file **Implementation details and use cases:** * Install Sentry SDK using `astro add @sentry/astro` command * Configure Sentry integration in `astro.config.mjs` file with client key, project name, and auth token * Use Sentry's Spotlight dev toolbar app for real-time error tracking and debugging during local development",
      "url": "/en/guides/backend/sentry/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "backend",
        "monitor",
        "your",
        "astro",
        "site"
      ],
      "type": "backend"
    },
    {
      "id": "guides/backend/neon",
      "language": "en",
      "filePath": "src/content/docs/en/guides/backend/neon.mdx",
      "title": "Neon Postgres & Astro",
      "summary": "**Neon Postgres & Astro Integration** **Purpose:** Astro components are integrated with Neon Postgres, a fully managed serverless Postgres database, to enable seamless database interactions. **Key Features:** * Environment configuration: Set Neon environment variables in `.env` files or `src/env.d.ts` for better TypeScript support. * Dependency installation: Install `@neondatabase/serverless` package to connect to Neon. * Neon client creation: Initialize the Neon client in `src/lib/neon.ts` using `import.meta.env.NEON_DATABASE_URL`. * Querying the database: Use the Neon client to query the database from any `.astro` component, as demonstrated in `src/pages/index.astro`. **Implementation Details:** * Requires a Neon account with a created project and database connection string. * Astro project must have on-demand rendering (SSR) enabled. * Use `sql` method to execute queries on the Neon database. **Use Cases:** * Integrate serverless Postgres database with Astro applications. * Enable seamless database interactions in Astro components. * Take advantage of Neon's autoscaling, branching, and bottomless storage features.",
      "url": "/en/guides/backend/neon/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "backend",
        "neon",
        "postgres",
        "astro"
      ],
      "type": "backend"
    },
    {
      "id": "reference/errors/no-client-entrypoint",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/no-client-entrypoint.mdx",
      "title": "No client entrypoint specified in renderer.",
      "summary": "**Astro components are rendered with client-side directives, but require a client entrypoint to hydrate.** **Key Features and APIs:** * `client:CLIENT_DIRECTIVE` directive * `RENDERER_NAME` renderer * `addRenderer` option * Hydrating framework components **Implementation Details and Use Cases:** * Provide a client entrypoint using the `addRenderer` option to hydrate components on the client. * Use the `client:CLIENT_DIRECTIVE` directive to specify client-side rendering requirements. * Ensure the renderer used provides a client entrypoint for hydrating interactive components. **Searchable Keywords:** Astro, client-side rendering, hydrating framework components, addRenderer option, client entrypoint.",
      "url": "/en/reference/errors/no-client-entrypoint/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "client",
        "entrypoint",
        "specified",
        "renderer."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/no-matching-import",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/no-matching-import.mdx",
      "title": "No import found for component.",
      "summary": "**Astro components are rendered with dynamic imports, but a critical error occurs when no import statement is found for a component.** **Key features and APIs:** * `import` statements are required for component rendering * `NoMatchingImport` error is triggered when no matching import is found * `COMPONENT_NAME` is the identifier of the missing import **Implementation details and use cases:** * Ensure import statements are correctly defined and match the component usage * Use `import` statements to load components dynamically * Handle `NoMatchingImport` errors by verifying import statements and component identifiers",
      "url": "/en/reference/errors/no-matching-import/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "import",
        "found",
        "component."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/no-matching-renderer",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/no-matching-renderer.mdx",
      "title": "No matching renderer found.",
      "summary": "**Astro error handling is used to detect and report rendering issues.** **Key features:** * `COMPONENT_NAME` and `RENDERER_COUNT` placeholders for error message customization * Integration with various frameworks (React, Preact, Solid-js, Vue, Svelte) through respective integrations (e.g., `@astrojs/react`) * Error message includes links to relevant guides and documentation (e.g., Frameworks components, UI Frameworks) **Implementation details:** * Error message is generated based on the absence of a matching renderer for the imported component * Error message includes instructions for installing the required integration for the specific framework used **Use cases:** * Detecting and reporting rendering issues in Astro applications * Providing guidance for resolving rendering errors through integration installation and framework-specific documentation.",
      "url": "/en/reference/errors/no-matching-renderer/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "matching",
        "renderer",
        "found."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/no-matching-static-path-found",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/no-matching-static-path-found.mdx",
      "title": "No static path found for requested path.",
      "summary": "**Astro components are used to render dynamic routes, but a \"NoMatchingStaticPathFound\" error occurs when a `getStaticPaths()` route pattern is matched without a corresponding static path for the requested path.** **Key features and APIs include:** * `getStaticPaths()` method for generating static paths * Astro's dynamic routing system for rendering routes with parameters * Error handling for cases where no matching static path is found **Implementation details and use cases:** * Dynamic routes are matched using `getStaticPaths()`, but no corresponding path is found for the requested parameters * This error is often caused by a typo in the generated or requested path * Use `getStaticPaths()` to generate static paths for dynamic routes and avoid this error",
      "url": "/en/reference/errors/no-matching-static-path-found/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "static",
        "path",
        "found",
        "requested"
      ],
      "type": "guide"
    },
    {
      "id": "guides/on-demand-rendering",
      "language": "en",
      "filePath": "src/content/docs/en/guides/on-demand-rendering.mdx",
      "title": "On-demand rendering",
      "summary": "**On-demand rendering** Astro components are rendered on demand by a server adapter, generating server-rendered pages and routes per visit, customizable for each viewer. Key features include: * `getStaticPaths` and `Astro.props` APIs for customizing on-demand rendering * Server adapters for Node.js, Netlify, Vercel, and Cloudflare, with community adapters available * Server-side rendering (SSR) enabled on demand, allowing for dynamic content and user-specific data display Implementation details include adding an adapter to enable on-demand rendering, with official adapters maintained by Astro and community adapters available through the integrations directory.",
      "url": "/en/guides/on-demand-rendering/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "on-demand",
        "rendering"
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/optimizely",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/optimizely.mdx",
      "title": "Optimizely CMS & Astro",
      "summary": "Optimizely CMS & Astro is a headless CMS integration that enables content management for Astro projects using a visual editor powered by GraphQL. Key features include: * Integration with Optimizely SaaS CMS for content management * Support for GraphQL API for data fetching and manipulation * Utilization of Astro.props for accessing CMS data in components * Implementation of getStaticPaths for server-side rendering and SEO optimization * Internationalization support for multilingual content management Use cases include building headless blogs, e-commerce sites, and other content-driven applications with Astro and Optimizely CMS.",
      "url": "/en/guides/cms/optimizely/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "optimizely",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "tutorial/6-islands/4",
      "language": "en",
      "filePath": "src/content/docs/en/tutorial/6-islands/4.mdx",
      "title": "Optional: Make a content collection",
      "summary": "**Astro content collections are a powerful way to manage groups of similar content, such as blog posts, by providing a schema to define a common structure for each post and using APIs like `getCollection()` to retrieve content and metadata.** **Key features and APIs:** * `getCollection()` method to retrieve content and metadata * Schema definition using Zod to enforce data structure and validation * Support for frontmatter properties with required and data type specifications * Integration with Astro's built-in file-based routing and content management **Implementation details and use cases:** * Move blog post folder to `src/blog/` and create a schema to define frontmatter properties * Use `getCollection()` to generate blog post index and display individual blog posts * Leverage schema validation to catch mistakes and receive better guidance in code editor",
      "url": "/en/tutorial/6-islands/4/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "6 islands",
        "optional:",
        "make",
        "collection"
      ],
      "type": "tutorial"
    },
    {
      "id": "reference/errors/page-number-param-not-found",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/page-number-param-not-found.mdx",
      "title": "Page number param not found.",
      "summary": "**PageNumberParamNotFound**: Astro error indicating the absence of a page number parameter in the filepath. **Features/APIs:** * `paginate()` method * `PARAM_NAME` parameter * filepath analysis **Implementation Details:** * Astro's routing system checks for page number parameters in the filepath * Error occurs when `PARAM_NAME` is not found in the filepath **Use Cases:** * Pagination implementation in Astro applications * Error handling for missing page number parameters **See Also:** * [Pagination](/en/guides/routing/#pagination)",
      "url": "/en/reference/errors/page-number-param-not-found/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "page",
        "number",
        "param",
        "found."
      ],
      "type": "guide"
    },
    {
      "id": "basics/astro-pages",
      "language": "en",
      "filePath": "src/content/docs/en/basics/astro-pages.mdx",
      "title": "Pages",
      "summary": "**Pages** are files that live in the `src/pages/` subdirectory of your Astro project, handling routing, data loading, and page layout for every page in your website. Astro supports the following file types in the `src/pages/` directory: `.astro`, `.md`, `.mdx`, `.html`, and `.js`/.`ts` (as endpoints). It uses file-based routing, where each file becomes an endpoint based on its file path, and supports dynamic routing for generating multiple pages from a single file. Astro pages use the `.astro` file extension and support features like Astro components, with implementation details including using standard HTML `` elements for linking between pages and leveraging URL paths relative to the root domain.",
      "url": "/en/basics/astro-pages/",
      "keywords": [
        "content",
        "docs",
        "basics",
        "pages"
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/payload",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/payload.mdx",
      "title": "Payload CMS & Astro",
      "summary": "**Payload CMS & Astro Integration** Payload CMS is a headless open-source content management system that integrates with Astro projects, enabling content management and delivery through a REST API. Key features include: * **getStaticPaths**: Utilize Payload CMS collections as a data source for Astro's static site generation. * **Astro.props**: Access Payload CMS data in Astro components using the `props` API. * **CollectionConfig**: Configure Payload CMS collections using the `CollectionConfig` type, defining fields, access control, and admin settings. Implementation details involve setting up a Payload CMS project, connecting it to a MongoDB database, and configuring Astro to use the Payload CMS REST API. Use cases include managing blog posts, articles, and other content types within an Astro project.",
      "url": "/en/guides/cms/payload/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "payload",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/prefetch",
      "language": "en",
      "filePath": "src/content/docs/en/guides/prefetch.mdx",
      "title": "Prefetch",
      "summary": "**Prefetch** Astro components are designed to prefetch links for snappier navigation between pages, reducing page load times and improving usability. Key features include: * Opt-in prefetching via `prefetch` config and `data-astro-prefetch` attribute * Four prefetch strategies: `hover`, `tap`, `viewport`, and `load` * Customizable prefetch configuration for fine-tuned performance * Support for internationalization and accessibility features Implementation details include: * Adding a prefetch script to all pages via `astro.config.mjs` * Using `data-astro-prefetch` attribute to opt-in to prefetching on individual links * Fine-tuning prefetch strategies for various use cases and user scenarios Use cases include: * Improving page load times and user experience on multi-page applications * Enhancing accessibility and usability for users with slow connections or data saver mode enabled * Customizing prefetching behavior for specific links and user interactions",
      "url": "/en/guides/prefetch/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "prefetch"
      ],
      "type": "guide"
    },
    {
      "id": "tutorial/1-setup/1",
      "language": "en",
      "filePath": "src/content/docs/en/tutorial/1-setup/1.mdx",
      "title": "Prepare your dev environment",
      "summary": "**Prepare your dev environment** Astro components are used to create a checklist of dev tools and software required to build an Astro website, including a command line (terminal), Node.js, and a code editor. Key features include importing Astro components, using the `Steps` component from `@astrojs/starlight/components`, and implementing conditional rendering with `PreCheck`. Use cases include setting up a development environment for an Astro project, checking for required software, and installing necessary tools.",
      "url": "/en/tutorial/1-setup/1/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "1 setup",
        "prepare",
        "your",
        "environment"
      ],
      "type": "tutorial"
    },
    {
      "id": "guides/cms/preprcms",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/preprcms.mdx",
      "title": "Prepr CMS & Astro",
      "summary": "**Prepr CMS & Astro Integration** Prepr CMS & Astro is a headless CMS integration that enables content management and personalization for Astro projects. It provides a GraphQL API to connect data to Astro, allowing for on-demand rendering and internationalization. **Key Features and APIs** * `Prepr` function: fetches data from Prepr CMS using GraphQL API * `fetch` method: sends POST requests to Prepr endpoint with query and variables * `import.meta.env.PREPR_ENDPOINT`: environment variable for Prepr API URL * `src/lib/prepr.js`: configuration file for Prepr endpoint **Implementation Details and Use Cases** * Create a new folder `src/lib/` and add a `prepr.js` file to configure the Prepr endpoint * Use the `Prepr` function to fetch data from Prepr CMS and render it in Astro components * Integrate with Astro's on-demand rendering feature for dynamic content loading",
      "url": "/en/guides/cms/preprcms/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "prepr",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "reference/errors/prerender-dynamic-endpoint-path-collide",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/prerender-dynamic-endpoint-path-collide.mdx",
      "title": "Prerendered dynamic endpoint has path collision.",
      "summary": "**Prerendered dynamic endpoint has path collision.** Astro components are affected by path collisions when prerendering dynamic endpoints with undefined params, causing generated paths to collide during prerendering. This issue can be resolved by preventing undefined params in getStaticPaths() or adding an additional extension to the endpoint's filename, such as renaming pages/api/[slug].ts to pages/api/[slug].json.ts. The getStaticPaths() function and params API are relevant to resolving this issue.",
      "url": "/en/reference/errors/prerender-dynamic-endpoint-path-collide/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "prerendered",
        "dynamic",
        "endpoint",
        "path"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/no-prerendered-routes-with-domains",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/no-prerendered-routes-with-domains.mdx",
      "title": "Prerendered routes arent supported when internationalization domains are enabled.",
      "summary": "**Prerendered routes are not supported when internationalization domains are enabled.** Prerendered routes are incompatible with internationalization domains due to limitations in static page support. To enable internationalization domains, prerendering must be disabled for the affected page component using the `COMPONENT` property. This restriction is enforced by the `NoPrerenderedRoutesWithDomains` error.",
      "url": "/en/reference/errors/no-prerendered-routes-with-domains/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "prerendered",
        "routes",
        "arent",
        "supported"
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/prismic",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/prismic.mdx",
      "title": "Prismic & Astro",
      "summary": "**Prismic & Astro Integration** Prismic & Astro integration enables developers to leverage Prismic as a headless content management system (CMS) within Astro projects, allowing for seamless content management and rendering of dynamic content. **Key Features and APIs** * Utilize Prismic's API to fetch and render content in Astro components * Leverage Astro's `getStaticPaths` and `getStaticProps` APIs to pre-render content at build time * Access Prismic data through Astro's `Astro.props` API * Implement internationalization (i18n) support using Prismic's built-in features **Implementation Details and Use Cases** * Integrate Prismic with Astro by creating a Prismic API client and using it to fetch content in Astro components * Use Prismic's content modeling features to create custom content types and fields * Pre-render content at build time using Astro's `getStaticPaths` and `getStaticProps` APIs to improve performance and SEO",
      "url": "/en/guides/cms/prismic/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "prismic",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "reference/programmatic-reference",
      "language": "en",
      "filePath": "src/content/docs/en/reference/programmatic-reference.mdx",
      "title": "Programmatic Astro API (experimental)",
      "summary": "**Programmatic Astro API (experimental)** The Astro API exports command APIs to programmatically run CLI commands, providing more control when running Astro. The `AstroInlineConfig` type extends the user Astro config type and is used by all command APIs, allowing for customization of config file paths, log levels, and modes. **Key Features:** * `AstroInlineConfig` type with `configFile`, `mode`, and `logLevel` properties * `configFile` property allows custom path to Astro config file or disabling config file loading * `mode` property determines development or build mode and affects Vite behavior * APIs are experimental and subject to change, with updates tracked in the Astro changelog",
      "url": "/en/reference/programmatic-reference/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "programmatic",
        "astro",
        "(experimental)"
      ],
      "type": "guide"
    },
    {
      "id": "basics/project-structure",
      "language": "en",
      "filePath": "src/content/docs/en/basics/project-structure.mdx",
      "title": "Project structure",
      "summary": "**Astro project structure is a standardized folder layout for organizing project source code and assets.** The Astro project root includes the following directories and files: * `src/*` for project source code (components, pages, styles, images, etc.) * `public/*` for non-code, unprocessed assets (fonts, icons, etc.) * `package.json` for project manifest * `astro.config.mjs` for Astro configuration (recommended) * `tsconfig.json` for TypeScript configuration (recommended) The `src/` folder contains pages, layouts, Astro components, UI framework components, styles, Markdown, and images to be optimized and processed by Astro.",
      "url": "/en/basics/project-structure/",
      "keywords": [
        "content",
        "docs",
        "basics",
        "project",
        "structure"
      ],
      "type": "guide"
    },
    {
      "id": "reference/publish-to-npm",
      "language": "en",
      "filePath": "src/content/docs/en/reference/publish-to-npm.mdx",
      "title": "Publish to NPM",
      "summary": "**Publishing Astro Components to NPM** Astro components can be published directly to and installed from NPM, allowing for reuse across projects and sharing with the Astro community. Key features include support for workspaces, package manifest configuration, and Node Module integration. To get started, use the Astro Component template, configure workspaces, and follow the package creation process.",
      "url": "/en/reference/publish-to-npm/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "publish"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/route-not-found",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/route-not-found.mdx",
      "title": "Route not found.",
      "summary": "**RouteNotFound**: Astro components are designed to handle route not found scenarios, providing a default rendering for unmatched routes. Key features include the `RouteNotFound` component, which displays a warning message indicating that Astro couldn't find a matching route. This component can be customized using Astro.props, and is implemented using a combination of Astro's routing API and custom components.",
      "url": "/en/reference/errors/route-not-found/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "route",
        "found."
      ],
      "type": "guide"
    },
    {
      "id": "guides/routing",
      "language": "en",
      "filePath": "src/content/docs/en/guides/routing.mdx",
      "title": "Routing",
      "summary": "**Astro components are used for file-based routing to generate build URLs based on the file layout of the project's `src/pages/` directory.** **Key features include:** * Standard HTML `` elements for navigating between routes * Automatic page creation from `.astro` page components, Markdown, and MDX files within the `src/pages/` directory * Dynamic route parameters in filenames to generate multiple, matching pages * Access to route parameters from inside page components using `Astro.props` **Implementation details and use cases:** * Use `base` configuration to customize the base URL of routes * Customize file output format using `build.format` configuration option * Utilize dynamic route parameters to generate bio pages for authors on a blog.",
      "url": "/en/guides/routing/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "routing"
      ],
      "type": "guide"
    },
    {
      "id": "reference/routing-reference",
      "language": "en",
      "filePath": "src/content/docs/en/reference/routing-reference.mdx",
      "title": "Routing Reference",
      "summary": "**Astro Routing Reference** Astro components are generated and prerendered at build time by default, with support for on-demand server rendering. **Key Features and APIs** * `prerender`: a boolean value exported from each route to determine whether it is prerendered (default: `true` in static mode, `false` with `output: 'server'` configuration) * Supported page files in `src/pages/` directory create routes, with optional parameter-based dynamic routing * On-demand server rendering can be enabled for individual routes or as the default **Implementation Details and Use Cases** * Per-page override: export `prerender` with `false` to enable on-demand rendering for an individual route * Switch to `server` mode: configure `output: 'server'` to generate pages and endpoints on the server upon request by default * Enable prerendering for individual routes in `server` mode by exporting `prerender` with `true`",
      "url": "/en/reference/routing-reference/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "routing"
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/sanity",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/sanity.mdx",
      "title": "Sanity & Astro",
      "summary": "**Sanity & Astro Integration** Sanity & Astro is a plugin that enables the use of Sanity as a headless content management system (CMS) in Astro projects, allowing for structured content management and internationalization. **Key Features:** * Utilizes Sanity's structured content platform for content management * Integrates with Astro's component-based architecture through Astro.props and getStaticPaths API * Supports internationalization and localization through Sanity's built-in features **Implementation Details:** * Import Sanity components and APIs in Astro files using import statements * Use Sanity's Studio to manage and create content, which is then rendered in Astro components * Leverage Astro's getStaticPaths API to pre-render pages with Sanity data **Use Cases:** * Build a blog or news site with Sanity as the CMS and Astro as the frontend framework * Create a headless e-commerce site with Sanity managing product data and Astro rendering the frontend * Use Sanity's structured content platform to manage complex data models and render them in Astro components.",
      "url": "/en/guides/cms/sanity/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "sanity",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/client-side-scripts",
      "language": "en",
      "filePath": "src/content/docs/en/guides/client-side-scripts.mdx",
      "title": "Scripts and event handling",
      "summary": "**Client-Side Scripting in Astro** Astro components can execute client-side JavaScript using standard HTML `` tags, enabling event handling, analytics, animations, and more without requiring a UI framework. **Key Features and APIs** * Import npm modules and local files * Use TypeScript with full support for importing TypeScript files * Add event listeners and send analytics data * Play animations and execute JavaScript code in the browser * Use `document.querySelectorAll` to find component DOM on the page * Add event listeners using `addEventListener` * Use `console.log` to log messages to the browser console **Implementation Details** * Astro processes and bundles `` tags by default * Scripts are injected at the point of declaration with `type=\"module\"` * Scripts are only included once if a component is used multiple times on a page",
      "url": "/en/guides/client-side-scripts/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "scripts",
        "event",
        "handling"
      ],
      "type": "guide"
    },
    {
      "id": "tutorial/3-components/4",
      "language": "en",
      "filePath": "src/content/docs/en/tutorial/3-components/4.mdx",
      "title": "Send your first script to the browser",
      "summary": "**Astro components are used to create reusable UI components for client-side interactivity.** **Key features include:** * Importing Astro components (e.g., `Blanks`, `Box`, `Checklist`, `MultipleChoice`, `Option`, `PreCheck`, `Steps`) * Using Astro's client-side rendering capabilities to create interactive components (e.g., `Hamburger` component) * Utilizing Astro's component lifecycle methods (e.g., `astro:componentDidLoad`) **Implementation details and use cases:** * Creating a new Astro component (e.g., `Hamburger.astro`) to represent a hamburger menu * Using Astro's component composition to nest components (e.g., `Hamburger` within `Header.astro`) * Styling components using CSS (e.g., `global.css`) to customize their appearance **Technical keywords:** Astro, client-side rendering, component lifecycle, component composition, CSS styling.",
      "url": "/en/tutorial/3-components/4/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "3 components",
        "send",
        "your",
        "first",
        "script"
      ],
      "type": "tutorial"
    },
    {
      "id": "guides/server-islands",
      "language": "en",
      "filePath": "src/content/docs/en/guides/server-islands.mdx",
      "title": "Server islands",
      "summary": "**Server Islands** Server islands allow you to on-demand render dynamic or personalized \"islands\" individually, without sacrificing the performance of the rest of the page, using the `server:defer` directive and an adapter installed for delayed rendering. **Key Features:** * Delayed rendering of server island components using `server:defer` directive * Support for on-demand rendering features, such as fetching content and accessing cookies * Passing serializable props to server island components, with limitations on data structures **Implementation Details:** * Server island components are normal server-rendered Astro components with delayed rendering * Fallback content can be specified as a placeholder for the server island * Adapters are required for on-demand rendering and delayed rendering **Use Cases:** * Dynamic or personalized content rendering without sacrificing page performance * Fetching content and accessing cookies in server island components * Using server islands for on-demand rendering features",
      "url": "/en/guides/server-islands/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "server",
        "islands"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/session-storage-save-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/session-storage-save-error.mdx",
      "title": "Session data could not be saved.",
      "summary": "**Error Handling for Session Data Saving** Session data could not be saved due to an error with the specified driver `DRIVER`. This error is thrown when the session data fails to save, typically due to a database or storage issue. The error is critical and requires immediate attention to resolve the session data saving issue. **Key Features and APIs:** * Error handling for session data saving * Driver-specific error handling for `DRIVER` * Integration with database or storage systems **Implementation Details:** * Error messages are generated based on the driver and error type * Error handling is critical for session data saving * Use cases include database or storage system failures, invalid session data, or driver configuration issues. **Technical Keywords:** session data saving, error handling, driver-specific errors, database storage systems.",
      "url": "/en/reference/errors/session-storage-save-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "session",
        "data",
        "could",
        "saved."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/session-config-without-flag-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/session-config-without-flag-error.mdx",
      "title": "Session flag not set",
      "summary": "**Session flag not set** Astro components throw this error when session storage is configured but the `experimental.session` flag is not enabled. This error is thrown when `session.config` is provided without enabling the `experimental.session` flag. The `experimental.session` flag was removed in Astro 5.7, making this error obsolete.",
      "url": "/en/reference/errors/session-config-without-flag-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "session",
        "flag"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/session-storage-init-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/session-storage-init-error.mdx",
      "title": "Session storage could not be initialized.",
      "summary": "**Session Storage Initialization Error** Session storage could not be initialized due to an error with the specified driver `DRIVER`. This error is thrown when the session storage fails to initialize, preventing further session management. The error is typically resolved by checking the session storage driver configuration and ensuring it is correctly set up.",
      "url": "/en/reference/errors/session-storage-init-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "session",
        "storage",
        "could",
        "initialized."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/session-config-missing-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/session-config-missing-error.mdx",
      "title": "Session storage was enabled but not configured.",
      "summary": "**Session Storage Configuration Error** Session storage was enabled but not configured, resulting in an error when attempting to use session-based functionality. This error occurs when the `experimental.session` flag is set to `true` without configuring storage manually or using an adapter that provides session storage. The `getStaticPaths` method and `Astro.props` API are affected by this configuration issue.",
      "url": "/en/reference/errors/session-config-missing-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "session",
        "storage",
        "enabled",
        "configured."
      ],
      "type": "guide"
    },
    {
      "id": "guides/sessions",
      "language": "en",
      "filePath": "src/content/docs/en/guides/sessions.mdx",
      "title": "Sessions",
      "summary": "**Sessions** Sessions are used to share data between requests for on-demand rendered pages, storing larger amounts of data on the server without size limits or security issues. They are useful for storing user data, shopping carts, and form state, and work without client-side JavaScript. Sessions require a storage driver, which can be automatically configured by adapters like Node, Cloudflare, and Netlify, or specified manually in `astro.config.mjs`.",
      "url": "/en/guides/sessions/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "sessions"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/session-without-supported-adapter-output-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/session-without-supported-adapter-output-error.mdx",
      "title": "Sessions cannot be used with an adapter that doesnt support server output.",
      "summary": "**Sessions require an adapter that supports server output.** Sessions utilize the `buildOutput` adapter feature, which must include `\"server\"` to function correctly. This is achieved by implementing the `server` property in the adapter configuration.",
      "url": "/en/reference/errors/session-without-supported-adapter-output-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "sessions",
        "cannot",
        "used",
        "with"
      ],
      "type": "guide"
    },
    {
      "id": "recipes/sharing-state",
      "language": "en",
      "filePath": "src/content/docs/en/recipes/sharing-state.mdx",
      "title": "Share state between Astro components",
      "summary": "**Share state between Astro components** Astro components can share state across components using Nano Stores, a client-side storage solution. Key features include importing and using stores in `` tags, setting and subscribing to store values, and using APIs such as `atom` and `set` to manage shared state. This approach enables seamless state sharing between components, making it ideal for building complex Astro applications.",
      "url": "/en/recipes/sharing-state/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "share",
        "state",
        "between",
        "astro"
      ],
      "type": "recipe"
    },
    {
      "id": "recipes/sharing-state-islands",
      "language": "en",
      "filePath": "src/content/docs/en/recipes/sharing-state-islands.mdx",
      "title": "Share state between islands",
      "summary": "**Astro components are designed to share state between islands using Nano Stores.** **Key features include:** * Utilizing Nano Stores for shared client-side storage * Lightweight implementation with zero dependencies (less than 1 KB) * Framework-agnostic solution for seamless state sharing between frameworks **Implementation details and use cases:** * Author stores that any component can interact with * Recommended for Astro websites with islands architecture or partial hydration * Alternative solutions include Svelte's built-in stores, Solid signals, Vue's reactivity API, and custom browser events.",
      "url": "/en/recipes/sharing-state-islands/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "share",
        "state",
        "between",
        "islands"
      ],
      "type": "recipe"
    },
    {
      "id": "guides/cms/sitecore",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/sitecore.mdx",
      "title": "Sitecore Experience Manager & Astro",
      "summary": "**Sitecore Experience Manager & Astro** Sitecore Experience Manager & Astro is a content management system integration that enables developers to add content to their Astro projects using Sitecore as the CMS. Key features include: * Integration with Sitecore Headless API using the Sitecore JavaScript Software Development Kit (JSS) * Support for internationalization (i18n) and localization (L10n) * Utilizes Astro's `@astrojs/starlight/components` library for rendering Sitecore content Implementation details include running the `npx @astro-sitecore-jss/create-astro-sitecore-jss@latest` command to initialize a new project, and following Sitecore's official documentation to create a Sitecore Headless website. Community resources include the Sitecore JSS for Astro on GitHub and introductory blog posts on Sitecore with Astro and starting a first Sitecore Astro project.",
      "url": "/en/guides/cms/sitecore/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "sitecore",
        "experience",
        "manager",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/cms/sitepins",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/sitepins.mdx",
      "title": "Sitepins & Astro",
      "summary": "**Sitepins & Astro Integration** Sitepins is a Git-based, headless CMS for Astro projects, offering a clean WYSIWYG editor, version-controlled content workflow, and seamless integration with Astro and other SSGs. Key features include Astro.props, getStaticPaths, and Sitepins API integration, enabling developers to manage content with full Git version control. Implement Sitepins by connecting your GitHub repository, configuring content folders, and editing content in the visual editor.",
      "url": "/en/guides/cms/sitepins/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "sitepins",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "reference/errors/config-not-found",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/config-not-found.mdx",
      "title": "Specified configuration file not found.",
      "summary": "**Specified configuration file not found.** The `ConfigNotFound` error occurs when the specified configuration file using `--config` cannot be resolved, indicating that the file does not exist or the path is incorrect. This error is resolved by verifying the existence of the configuration file or correcting the path. The `--config` option is used to specify a configuration file path, as documented in the CLI reference.",
      "url": "/en/reference/errors/config-not-found/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "specified",
        "configuration",
        "file",
        "found."
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/spinal",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/spinal.mdx",
      "title": "Spinal & Astro",
      "summary": "**Spinal & Astro Integration** Spinal & Astro is a commercial, SaaS-focused, Git-based CMS integration for Astro projects, enabling content management and internationalization. **Key Features:** * Import Markdown content from a selected folder into Spinal using Astro's `getStaticPaths` and `Astro.props` APIs. * Utilize Spinal's commercial features, including a SaaS-focused platform and Git-based content management. * Leverage official resources, such as a documentation theme built for Astro with Tailwind CSS. **Implementation Details:** * Connect a GitHub account to Spinal and select an Astro repository to import Markdown content. * Use Astro's `Steps` component to guide the setup process. * Integrate with production sites, such as spinalcms.com, which uses Astro + Spinal for content management.",
      "url": "/en/guides/cms/spinal/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "spinal",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "tutorial/1-setup/4",
      "language": "en",
      "filePath": "src/content/docs/en/tutorial/1-setup/4.mdx",
      "title": "Store your repository online",
      "summary": "**Repository Management** Store your repository online using GitHub or other online git providers. Key features include: * Creating a new repository on GitHub using the web interface * Committing local code changes to GitHub using VS Code's Source Control tab * Utilizing GitHub's repository URL for deployment and hosting Implementation details include: * Using the `+` button on GitHub.com to create a new repository * Configuring repository settings and clicking the \"Create Repository\" button * Committing changes using VS Code's Source Control tab and GitHub's repository URL APIs and methods used include: * GitHub's web interface for repository creation and management * VS Code's Source Control tab for committing local code changes * `git` commands for version control (optional)",
      "url": "/en/tutorial/1-setup/4/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "1 setup",
        "store",
        "your",
        "repository",
        "online"
      ],
      "type": "tutorial"
    },
    {
      "id": "guides/cms/storyblok",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/storyblok.mdx",
      "title": "Storyblok & Astro",
      "summary": "**Storyblok & Astro Integration** Astro components are enhanced with Storyblok integration, allowing developers to manage content using reusable components called Bloks. **Key Features and APIs** * `@storyblok/astro` integration module * `STORYBLOK_TOKEN` environment variable for authentication * `getStaticPaths` API for pre-rendering content * `Astro.props` API for accessing Storyblok content **Implementation Details and Use Cases** * Connect Astro project to Storyblok space using `.env` file and `STORYBLOK_TOKEN` * Install `@storyblok/astro` integration module using npm or yarn * Use `getStaticPaths` and `Astro.props` APIs to fetch and render Storyblok content * Integrate with Astro's component-based architecture for seamless content management.",
      "url": "/en/guides/cms/storyblok/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "storyblok",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/cms/strapi",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/strapi.mdx",
      "title": "Strapi & Astro",
      "summary": "**Strapi & Astro Integration** Astro components are integrated with Strapi, a headless CMS, to fetch and display content in Astro projects. **Key Features and APIs** * `STRAPI_URL` environment variable to connect to Strapi CMS server * `env.d.ts` file for IntelliSense support * `src/lib/strapi.ts` wrapper function to interact with Strapi API * `Props` interface for API request configuration * `endpoint`, `query`, `wrappedByKey`, and `wrappedByList` properties for API customization **Implementation Details and Use Cases** The integration involves setting up a `.env` file to store the Strapi URL, creating an `env.d.ts` file for IntelliSense support, and implementing a wrapper function in `src/lib/strapi.ts` to fetch data from the Strapi API. This allows developers to easily connect their Astro project to a Strapi CMS server and display dynamic content.",
      "url": "/en/guides/cms/strapi/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "strapi",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/cms/studiocms",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/studiocms.mdx",
      "title": "StudioCMS & Astro",
      "summary": "StudioCMS & Astro are designed to build and manage content for Astro projects using a headless CMS, providing a user-friendly dashboard and custom rendering system for Astro components. Key features include Astro.props, getStaticPaths, and Astro components integration, with implementation details and use cases for content management, internationalization, and custom rendering. StudioCMS is built with Astro and provides a configurable dashboard, API, and GitHub repository for development and community support.",
      "url": "/en/guides/cms/studiocms/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "studiocms",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "recipes/tailwind-rendered-markdown",
      "language": "en",
      "filePath": "src/content/docs/en/recipes/tailwind-rendered-markdown.mdx",
      "title": "Style rendered Markdown with Tailwind Typography",
      "summary": "**Style rendered Markdown with Tailwind Typography** Astro components are used to style rendered Markdown from content collections using Tailwind's Typography plugin. The `@tailwindcss/typography` package is installed and configured as a plugin in the Tailwind configuration file, enabling the use of utility classes to style Markdown content. A reusable `` component is created to wrap rendered Markdown with a `` element and apply Tailwind element modifiers for styling.",
      "url": "/en/recipes/tailwind-rendered-markdown/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "style",
        "rendered",
        "markdown",
        "with"
      ],
      "type": "recipe"
    },
    {
      "id": "tutorial/2-pages/4",
      "language": "en",
      "filePath": "src/content/docs/en/tutorial/2-pages/4.mdx",
      "title": "Style your About page",
      "summary": "**Style your About page** Astro components are used to style individual pages, including the About page, using `` tags with attributes and directives. Key features include the use of CSS variables and styling of specific elements, such as `` and `` elements, using class names like `skill`. APIs and methods used include Astro's own `` tags, `pageTitle` variable, and `skills.map()` function.",
      "url": "/en/tutorial/2-pages/4/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "2 pages",
        "style",
        "your",
        "about",
        "page"
      ],
      "type": "tutorial"
    },
    {
      "id": "guides/styling",
      "language": "en",
      "filePath": "src/content/docs/en/guides/styling.mdx",
      "title": "Styles and CSS",
      "summary": "**Astro components are designed to simplify styling and CSS management, allowing developers to write custom CSS directly in components or import popular libraries like Tailwind, Sass, and Less.** **Key features include:** * Scoped styles by default, automatically encapsulating CSS within components * Support for `` tags in components and page templates * Automatic compilation of CSS rules to prevent leaks and preserve specificity * Compatibility with low-specificity selectors and child components **Implementation details and use cases:** * Use `` tags to write custom CSS in components or page templates * Import popular CSS libraries like Tailwind, Sass, and Less * Leverage scoped styles to prevent CSS leaks and preserve specificity * Wrap child components in a `` element to style them independently",
      "url": "/en/guides/styling/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "styles"
      ],
      "type": "guide"
    },
    {
      "id": "guides/backend/supabase",
      "language": "en",
      "filePath": "src/content/docs/en/guides/backend/supabase.mdx",
      "title": "Supabase & Astro",
      "summary": "**Supabase & Astro** Astro components are integrated with Supabase, an open source Firebase alternative, to provide a Postgres database, authentication, edge functions, realtime subscriptions, and storage. Key features include initializing Supabase in Astro with environment variables, installing `@supabase/supabase-js` dependencies, and utilizing APIs such as `SUPABASE_URL` and `SUPABASE_ANON_KEY`. Implementation details involve adding Supabase credentials to the `.env` file and utilizing TypeScript type definitions in `env.d.ts` for IntelliSense support.",
      "url": "/en/guides/backend/supabase/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "backend",
        "supabase",
        "astro"
      ],
      "type": "backend"
    },
    {
      "id": "guides/syntax-highlighting",
      "language": "en",
      "filePath": "src/content/docs/en/guides/syntax-highlighting.mdx",
      "title": "Syntax Highlighting",
      "summary": "**Syntax Highlighting in Astro** Astro components are designed to provide syntax highlighting for code blocks using built-in support for Shiki and Prism, enabling features such as code fences, Code components, and Prism components. Key features include: * Syntax highlighting for Markdown and MDX code fences using Shiki * Built-in Code component powered by Shiki for `.astro` files * Prism component for `.astro` files * Configuration options for markdown.syntaxHighlight, markdown.shikiConfig, and Prism stylesheet integration Implementation details include: * Using Shiki's `github-dark` theme by default * Limiting compiled output to inline styles without extraneous CSS classes, stylesheets, or client-side JS * Community integrations available for additional text marking and annotation options",
      "url": "/en/guides/syntax-highlighting/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "syntax",
        "highlighting"
      ],
      "type": "guide"
    },
    {
      "id": "reference/directives-reference",
      "language": "en",
      "filePath": "src/content/docs/en/reference/directives-reference.mdx",
      "title": "Template directives reference",
      "summary": "**Template Directives Reference** **Purpose:** Template directives are a special kind of HTML attribute used to control an element or component's behavior in Astro templates (.astro files) and some .mdx files. **Features:** * Include a colon `:` in their name, using the form `X:Y` (e.g., `client:load`) * Can take a custom value, except for some directives that take no value * Never included in the final HTML output of a component **Common Directives:** * `class:list`: takes an array of class values and converts them into a class string, powered by clsx library * `set:html`: injects an HTML string into an element, but requires manual escaping **Implementation Details:** * Template directives are visible to the compiler and must be used in a valid form * Some directives can take a custom value, while others take no value * Directives are not included in the final HTML output of a component **Use Cases:** * Use `class:list` to simplify class management and concatenate class values * Use `set:html` to inject dynamic HTML content into an element, but ensure manual escaping to prevent XSS attacks",
      "url": "/en/reference/directives-reference/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "template",
        "directives"
      ],
      "type": "guide"
    },
    {
      "id": "reference/astro-syntax",
      "language": "en",
      "filePath": "src/content/docs/en/reference/astro-syntax.mdx",
      "title": "Template expressions reference",
      "summary": "**Astro component syntax is a superset of HTML, designed to feel familiar to anyone with experience writing HTML or JSX, and adds support for including components and JavaScript expressions.** **Key features include:** * Defining local JavaScript variables in the frontmatter component script using JSX-like expressions * Injecting variables into the component's HTML template using curly braces syntax * Support for dynamic attributes and template literals * Limited reactivity, as Astro components only run once during the rendering step **Implementation details and use cases:** * Use local variables to include dynamic values in the component's HTML template * Pass attribute values to HTML elements and components using curly braces syntax * Note that HTML attributes will be converted to strings, and functions and objects cannot be passed to HTML elements.",
      "url": "/en/reference/astro-syntax/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "template",
        "expressions"
      ],
      "type": "guide"
    },
    {
      "id": "guides/testing",
      "language": "en",
      "filePath": "src/content/docs/en/guides/testing.mdx",
      "title": "Testing",
      "summary": "**Testing in Astro** Astro supports various testing frameworks for unit tests, component tests, and end-to-end tests, including Jest, Mocha, Jasmine, Cypress, and Playwright, as well as framework-specific libraries like React Testing Library. **Key Features and APIs** * `getViteConfig()` helper for setting up Vitest with Astro project settings * Vitest configuration options for customizing test environment * Container API for natively testing Astro components * Support for unit, component, and end-to-end testing with popular frameworks **Implementation and Use Cases** * Use `getViteConfig()` to set up Vitest with Astro project settings in `vitest.config.ts` * Customize Astro configuration applied in tests by passing a second argument to `getViteConfig()` * Utilize the Container API to test Astro components with Vitest",
      "url": "/en/guides/testing/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "testing"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/endpoint-did-not-return-aresponse",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/endpoint-did-not-return-aresponse.mdx",
      "title": "The endpoint did not return a Response.",
      "summary": "**EndpointDidNotReturnAResponse**: An error thrown when an endpoint fails to return a `Response` or a `Promise` resolving with a `Response`. **Key Features:** * Thrown when an endpoint returns nothing or an object not conforming to the `Response` interface. * Requires endpoints to return a `Response` or a `Promise` resolving with a `Response`. * Example implementation: `export async function GET({ request, url, cookies }: APIContext): Promise { ... }` **Implementation Details:** * Astro API endpoints must adhere to the `Response` interface or return a `Promise` resolving with a `Response`. * Use `Response.json()` to return a JSON response, as shown in the example implementation. **Use Cases:** * Ensure endpoints return a valid `Response` to prevent `EndpointDidNotReturnAResponse` errors. * Use `Promise` to handle asynchronous operations and return a `Response` when resolved.",
      "url": "/en/reference/errors/endpoint-did-not-return-aresponse/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "endpoint",
        "return",
        "response."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/middleware-no-data-or-next-called",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/middleware-no-data-or-next-called.mdx",
      "title": "The middleware didnt return a Response.",
      "summary": "**MiddlewareNoDataOrNextCalled Error** MiddlewareNoDataOrNextCalled is thrown when middleware fails to return a `Response` object, either directly or by calling the `next` function. This error occurs when the middleware does not return any data or call `next`, as seen in the example where `context.locals.someData = false;` is assigned without returning a `Response`. To resolve this, ensure middleware returns a `Response` object or calls `next` to continue the request pipeline.",
      "url": "/en/reference/errors/middleware-no-data-or-next-called/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "middleware",
        "didnt",
        "return",
        "response."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/middleware-not-aresponse",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/middleware-not-aresponse.mdx",
      "title": "The middleware returned something that is not a Response object.",
      "summary": "**MiddlewareNotAResponse**: Astro middleware must return a valid `Response` object. **Purpose/Function**: Middleware functions in Astro must return a `Response` object to ensure proper routing and rendering. **Key Features/APIs**: `defineMiddleware`, `onRequest`, `Response` object. **Implementation Details**: Middleware functions should return a `Response` object, not a primitive value or object. Use `defineMiddleware` to define middleware functions that return a `Response` object. **Use Cases**: Ensure middleware functions return a `Response` object to prevent errors and ensure proper routing and rendering in Astro applications.",
      "url": "/en/reference/errors/middleware-not-aresponse/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "middleware",
        "returned",
        "something",
        "that"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/i18n-no-locale-found-in-path",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/i18n-no-locale-found-in-path.mdx",
      "title": "The path doesnt contain any locale",
      "summary": "**i18n Utility Error Handling** The `i18nNoLocaleFoundInPath` error occurs when an i18n utility attempts to use a locale from a URL path that does not contain one. To prevent this error, use the `pathHasLocale` method to check URLs for a locale before utilizing i18n utilities. This can be achieved by calling `pathHasLocale` to determine if the path has a locale, and then using i18n utilities accordingly.",
      "url": "/en/reference/errors/i18n-no-locale-found-in-path/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "path",
        "doesnt",
        "contain",
        "locale"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/missing-locale",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/missing-locale.mdx",
      "title": "The provided locale does not exist.",
      "summary": "**Astro Internationalization Error Handling** Astro components are designed to handle internationalization errors, specifically when a requested locale does not exist in the configured `i18n.locales`. The `MissingLocale` error is triggered when Astro cannot find the requested locale, indicating that the locale/path `LOCALE` is not configured in `i18n.locales` or does not have a corresponding directory in `src/pages/`. This error can be resolved by ensuring all supported locales are configured in `i18n.locales` and have corresponding directories within `src/pages/`.",
      "url": "/en/reference/errors/missing-locale/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "provided",
        "locale",
        "does",
        "exist."
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/tina-cms",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/tina-cms.mdx",
      "title": "Tina CMS & Astro",
      "summary": "**Tina CMS & Astro Integration** Tina CMS is a Git-backed headless content management system integrated with Astro, enabling developers to add content to their Astro projects using Tina's API. Key features include: * Installation via `npx @tinacms/cli@latest init` or `pnpm dlx @tinacms/cli@latest init`/`yarn dlx @tinacms/cli@latest init` * Integration with Astro's `dev` script via `tinacms dev -c \"astro dev\"` * Access to Tina's API through `Astro.props` and `getStaticPaths` methods * Use cases include managing content for Astro projects, leveraging Tina's Git-backed CMS for content editing and versioning.",
      "url": "/en/guides/cms/tina-cms/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "tina",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/troubleshooting",
      "language": "en",
      "filePath": "src/content/docs/en/guides/troubleshooting.mdx",
      "title": "Troubleshooting",
      "summary": "**Astro provides several tools to help troubleshoot and debug Astro code, including `console.log()` statements, debugging framework components, and the built-in `` component.** **Key features and APIs:** * `console.log()` statements for debugging in terminal and browser * Debugging framework components for server-side and hydrated rendering * `` component for inspecting values in client-side HTML template * Astro provides a built-in `` component for quick debugging in the browser **Implementation details and use cases:** * Use `console.log()` statements in Astro frontmatter for terminal output and in `` tags for browser output * Debug framework components for server-side and hydrated rendering * Use `` component to inspect values in client-side HTML template for quick debugging in the browser",
      "url": "/en/guides/troubleshooting/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "troubleshooting"
      ],
      "type": "guide"
    },
    {
      "id": "guides/backend/turso",
      "language": "en",
      "filePath": "src/content/docs/en/guides/backend/turso.mdx",
      "title": "Turso & Astro",
      "summary": "**Turso & Astro** Turso & Astro is a distributed database solution built on libSQL, a fork of SQLite, optimized for low query latency in global applications. It enables local development with a SQLite file and global deployment using Turso. **Key Features and APIs** * Initialize Turso in Astro using the Turso CLI, database URL, and access token * Configure environment variables (TURSO_DATABASE_URL, TURSO_AUTH_TOKEN) in a `.env` file * Install the `@libsql/client` package to connect Turso to Astro * Initialize a new client using `createClient` from `@libsql/client/web` * Execute SQL queries using the `turso` client **Implementation Details and Use Cases** * Use the Turso CLI to obtain the database URL and create an access token * Store the database URL and access token as environment variables in a `.env` file * Use the `@libsql/client` package to connect to the Turso database in Astro * Execute SQL queries using the `turso` client to access information from the database",
      "url": "/en/guides/backend/turso/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "backend",
        "turso",
        "astro"
      ],
      "type": "backend"
    },
    {
      "id": "guides/typescript",
      "language": "en",
      "filePath": "src/content/docs/en/guides/typescript.mdx",
      "title": "TypeScript",
      "summary": "**TypeScript Support in Astro** Astro components are enabled with built-in TypeScript support, allowing import of `.ts` and `.tsx` files, direct TypeScript code writing in Astro components, and use of an `astro.config.ts` file for configuration. Key features include type checking for component props, automatic type inference in the Astro VS Code Extension, and support for `tsconfig.json` files with three extensible templates (`base`, `strict`, and `strictest`).",
      "url": "/en/guides/typescript/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "typescript"
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/umbraco",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/umbraco.mdx",
      "title": "Umbraco & Astro",
      "summary": "Here is the technical documentation summary: **Umbraco & Astro Integration** Astro components are integrated with Umbraco CMS to fetch and display content using the Content Delivery API. **Key Features and APIs** * `fetch()` API to access Umbraco content * `Content Delivery API` to retrieve content data * `appsettings.json` configuration to enable public access and API keys * `Umbraco Content Delivery API` documentation for additional configuration options **Implementation Details and Use Cases** * Update `appsettings.json` to enable Content Delivery API * Use `fetch()` to retrieve content data from Umbraco API * Display content in Astro components using fetched data",
      "url": "/en/guides/cms/umbraco/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "umbraco",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "reference/errors/response-sent-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/response-sent-error.mdx",
      "title": "Unable to set response.",
      "summary": "**Astro components are unable to set response after it has been sent to the browser.** **Key features and APIs:** * `ResponseSentError` exception * Limited ability to modify response headers, cookies, and status code outside of page components * `Astro.props` and other APIs are not applicable in this scenario **Implementation details and use cases:** * Making changes to the response after it has been sent is not supported * Use page components to modify response headers, cookies, and status code * `getStaticPaths` and other Astro APIs are unaffected by this limitation",
      "url": "/en/reference/errors/response-sent-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "unable",
        "response."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/unhandled-rejection",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/unhandled-rejection.mdx",
      "title": "Unhandled rejection",
      "summary": "**Unhandled Rejection**: Astro components are designed to handle rejected promises, but in some cases, an unhandled rejection may occur, triggering a stack trace and a warning message. **Key Features and APIs**: * Astro detects unhandled rejections and provides a stack trace * Use `await` or `.catch()` handlers to resolve promises and prevent unhandled rejections * `UnhandledRejection` is a critical error that requires attention to resolve **Implementation Details and Use Cases**: * Ensure all promises are properly handled with `await` or `.catch()` to prevent unhandled rejections * Use try-catch blocks to catch and handle rejected promises * Review Astro's documentation for best practices on handling promises and errors.",
      "url": "/en/reference/errors/unhandled-rejection/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "unhandled",
        "rejection"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/unknown-clierror",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/unknown-clierror.mdx",
      "title": "Unknown CLI Error.",
      "summary": "**Astro CLI Error Handling** Astro CLI components are designed to handle unknown errors encountered during CLI command execution, providing a basic error message with minimal information. Key features include error message output and a link to open an issue on the Astro build issues tracker. Implementation details involve importing the `DontEditWarning` component and rendering it to display the error message.",
      "url": "/en/reference/errors/unknown-clierror/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "unknown",
        "error."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/unknown-compiler-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/unknown-compiler-error.mdx",
      "title": "Unknown compiler error.",
      "summary": "**Astro compiler error handling** Astro components are designed to handle unknown compiler errors, which can occur due to internal compiler issues. The `Unknown compiler error` message is displayed when Astro encounters an unexpected error during compilation, along with a link to create an issue on the Astro compiler issues list. The `withastro/compiler issues list` API is used to retrieve the list of known issues, allowing developers to check for existing solutions or report new issues.",
      "url": "/en/reference/errors/unknown-compiler-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "unknown",
        "compiler",
        "error."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/unknown-config-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/unknown-config-error.mdx",
      "title": "Unknown configuration error.",
      "summary": "Astro configuration loader encounters unknown errors when loading configuration files, often due to syntax errors, and provides a message with more information. The error can be resolved by reviewing the configuration file for syntax errors. Critical implementation details include Astro's configuration file loading mechanism and error handling.",
      "url": "/en/reference/errors/unknown-config-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "unknown",
        "configuration",
        "error."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/unknown-content-collection-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/unknown-content-collection-error.mdx",
      "title": "Unknown Content Collection Error.",
      "summary": "**Astro Content Collection Error Handling** Astro components encounter an unknown error loading content collections due to errors in `src/content.config.ts` or internal errors. This can be resolved by investigating and fixing the underlying cause, or by reporting the issue to the Astro community. The `Astro.props` and `getStaticPaths` APIs can be used to troubleshoot and optimize content collection loading.",
      "url": "/en/reference/errors/unknown-content-collection-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "unknown",
        "collection",
        "error."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/unknown-csserror",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/unknown-csserror.mdx",
      "title": "Unknown CSS Error.",
      "summary": "**Astro CSS Error Handling** Astro components are unable to parse CSS due to syntax errors, resulting in an unknown error. This issue can be resolved by examining the error message for more information, which often points to a specific syntax error in the CSS code. The `Styles and CSS` guide provides further information on troubleshooting and best practices for styling in Astro.",
      "url": "/en/reference/errors/unknown-csserror/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "unknown",
        "error."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/unknown-markdown-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/unknown-markdown-error.mdx",
      "title": "Unknown Markdown Error.",
      "summary": "Astro components are designed to handle Markdown parsing errors, including unknown errors, which are often caused by syntax errors in the Markdown content. Key features and APIs include error message analysis, syntax error detection, and critical error handling through Astro.props and getStaticPaths methods. Implementation details involve parsing Markdown content and checking for syntax errors, with use cases including debugging and troubleshooting Markdown-based Astro components.",
      "url": "/en/reference/errors/unknown-markdown-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "unknown",
        "markdown",
        "error."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/unknown-vite-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/unknown-vite-error.mdx",
      "title": "Unknown Vite Error.",
      "summary": "**Vite Error Handling** Vite components are designed to handle unknown errors during rendering, providing a fallback `DontEditWarning` component to display when an error occurs. The `DontEditWarning` component is imported and rendered as a fallback, allowing developers to identify and report issues. The `Vite` framework utilizes its built-in error handling mechanisms, such as the `vite.config.js` file, to troubleshoot and resolve errors.",
      "url": "/en/reference/errors/unknown-vite-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "unknown",
        "vite",
        "error."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/env-unsupported-get-secret",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/env-unsupported-get-secret.mdx",
      "title": "Unsupported astro:env getSecret",
      "summary": "**Unsupported astro:env getSecret** Astro components are unable to utilize the `getSecret` function exported by `astro:env/server` due to unsupported adapter functionality. The `getSecret` method is not recognized by the current adapter, resulting in an error. This issue can be resolved by upgrading to a more recent Astro version or consulting unmaintained documentation for older versions.",
      "url": "/en/reference/errors/env-unsupported-get-secret/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "unsupported",
        "astro:env",
        "getsecret"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/unsupported-image-conversion",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/unsupported-image-conversion.mdx",
      "title": "Unsupported image conversion",
      "summary": "**Unsupported Image Conversion** Astro components do not support converting between vector (such as SVGs) and raster (such as PNGs and JPEGs) images, due to the lack of implementation for this feature. The `UnsupportedImageConversion` error is triggered when attempting to convert between these image types. This limitation is documented in the Astro guides under the \"Images\" section.",
      "url": "/en/reference/errors/unsupported-image-conversion/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "unsupported",
        "image",
        "conversion"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/unsupported-image-format",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/unsupported-image-format.mdx",
      "title": "Unsupported image format",
      "summary": "**UnsupportedImageFormat Error** UnsupportedImageFormat is an error that occurs when an unsupported image format is received from an image path. This error is triggered when the built-in image services do not support the image format, currently limited to `SUPPORTED_FORMATS.JOIN(', ')`. The error can be resolved by using an `img` tag directly for unsupported formats, such as GIFs, by importing the image and setting its `src`, `width`, and `height` attributes.",
      "url": "/en/reference/errors/unsupported-image-format/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "unsupported",
        "image",
        "format"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/unsupported-external-redirect",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/unsupported-external-redirect.mdx",
      "title": "Unsupported or malformed URL.",
      "summary": "**Unsupported or Malformed URL Handling** Astro components are designed to handle external redirects, but may throw an error when encountering unsupported or malformed URLs. The `UnsupportedExternalRedirect` error occurs when the destination URL in an external redirect does not start with `http` or `https`, or is not a valid URL. This error can be resolved by ensuring that external redirects conform to the required URL format, and can be mitigated using the `Astro.redirect` API to handle redirects programmatically.",
      "url": "/en/reference/errors/unsupported-external-redirect/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "unsupported",
        "malformed",
        "url."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/unsupported-config-transform-error",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/unsupported-config-transform-error.mdx",
      "title": "Unsupported transform in content config.",
      "summary": "**Unsupported transform in content config** Astro components require `transform()` functions in content config to return valid JSON or data types compatible with the devalue library, including Dates, Maps, and Sets. This ensures proper parsing and rendering of content. The `transform()` function must return a valid JSON object or a compatible data type to avoid `UnsupportedConfigTransformError` and `PARSE_ERROR`.",
      "url": "/en/reference/errors/unsupported-config-transform-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "unsupported",
        "transform",
        "config."
      ],
      "type": "guide"
    },
    {
      "id": "upgrade-astro",
      "language": "en",
      "filePath": "src/content/docs/en/upgrade-astro.mdx",
      "title": "Upgrade Astro",
      "summary": "**Astro Upgrade Guide** Astro components are designed to be easily upgradable, with a focus on semantic versioning and backward compatibility. Key features include: * `@astrojs/upgrade` CLI command for automatic upgrades * `npm install`, `pnpm add`, and `yarn add` commands for manual upgrades * Support for upgrading Astro and official integrations together * Access to exhaustive changelogs and upgrade guides for major version changes Implementation details include: * Using `@astrojs/upgrade` CLI command to update Astro and integrations * Manually updating Astro and integrations using package manager commands * Accessing upgrade guides and changelogs for major version changes Use cases include: * Upgrading Astro and official integrations to the latest versions * Understanding Astro's versioning system and corresponding documentation updates * Accessing exhaustive changelogs and upgrade guides for major version changes",
      "url": "/en/upgrade-astro/",
      "keywords": [
        "content",
        "docs",
        "upgrade",
        "astro"
      ],
      "type": "guide"
    },
    {
      "id": "guides/upgrade-to/v2",
      "language": "en",
      "filePath": "src/content/docs/en/guides/upgrade-to/v2.mdx",
      "title": "Upgrade to Astro v2",
      "summary": "**Upgrade to Astro v2** Astro components are designed to provide a seamless upgrade experience from Astro v1 to v2, leveraging Astro.props, getStaticPaths, and other APIs to ensure a smooth transition. Key features include support for modern Node.js versions, improved performance, and enhanced internationalization capabilities. Implementation details involve updating package managers, such as npm, pnpm, or yarn, to the latest Astro version, and addressing breaking changes, including the removal of Node 14 support.",
      "url": "/en/guides/upgrade-to/v2/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "upgrade to",
        "upgrade",
        "astro"
      ],
      "type": "guide"
    },
    {
      "id": "guides/upgrade-to/v3",
      "language": "en",
      "filePath": "src/content/docs/en/guides/upgrade-to/v3.mdx",
      "title": "Upgrade to Astro v3",
      "summary": "**Upgrade to Astro v3** Astro components are upgraded to the latest version using package managers such as npm, pnpm, or yarn, with specific commands for upgrading Astro and its integrations. **Key Features and APIs:** * `npm install astro@latest`, `pnpm add astro@latest`, `yarn add astro@latest` for upgrading Astro * `@astrojs/react@latest`, `@astrojs/tailwind@latest` for upgrading React and Tailwind integrations * `astro.config.mjs` removal of experimental flags: `assets`, `viewTransitions` **Implementation Details and Use Cases:** * Update Astro version to the latest using package managers * Remove experimental flags from `astro.config.mjs` * Upgrade Astro integrations such as React and Tailwind * View Transitions API breaking changes and upgrading advice",
      "url": "/en/guides/upgrade-to/v3/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "upgrade to",
        "upgrade",
        "astro"
      ],
      "type": "guide"
    },
    {
      "id": "guides/upgrade-to/v4",
      "language": "en",
      "filePath": "src/content/docs/en/guides/upgrade-to/v4.mdx",
      "title": "Upgrade to Astro v4",
      "summary": "**Upgrade to Astro v4** Astro components are upgraded to the latest version (v4.0) using package manager commands, such as `npx @astrojs/upgrade`, `pnpm dlx @astrojs/upgrade`, or `yarn dlx @astrojs/upgrade`, to update Astro and official integrations. The upgrade process includes potentially breaking changes and removal of previously deprecated features. Key APIs and methods affected by the upgrade include `Astro.props`, `getStaticPaths`, and experimental flags like `devOverlay`.",
      "url": "/en/guides/upgrade-to/v4/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "upgrade to",
        "upgrade",
        "astro"
      ],
      "type": "guide"
    },
    {
      "id": "guides/upgrade-to/v5",
      "language": "en",
      "filePath": "src/content/docs/en/guides/upgrade-to/v5.mdx",
      "title": "Upgrade to Astro v5",
      "summary": "**Upgrade to Astro v5** Astro components are upgraded to the latest version using package managers such as npm, pnpm, or yarn with the `@astrojs/upgrade` command. **Key Features and APIs:** * `@astrojs/upgrade` command for upgrading Astro and official integrations * `npm`, `pnpm`, and `yarn` package managers for upgrading dependencies * `Astro.props` and `getStaticPaths` APIs for handling static site generation and internationalization **Implementation Details and Use Cases:** * Upgrade Astro and official integrations together using `@astrojs/upgrade` * Manually upgrade Astro integrations and other dependencies as needed * Check the Astro changelog for full release notes and breaking changes **Technical Keywords:** Astro v5, upgrade, package manager, npm, pnpm, yarn, `@astrojs/upgrade`, `Astro.props`, `getStaticPaths`, static site generation, internationalization.",
      "url": "/en/guides/upgrade-to/v5/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "upgrade to",
        "upgrade",
        "astro"
      ],
      "type": "guide"
    },
    {
      "id": "guides/backend/index",
      "language": "en",
      "filePath": "src/content/docs/en/guides/backend/index.mdx",
      "title": "Use a backend service with Astro",
      "summary": "**Astro components are designed to integrate with backend services, enabling developers to add authentication, storage, and data management capabilities to their projects.** **Key features and APIs include:** * `getStaticPaths` for server-side rendering and data fetching * `Astro.props` for accessing and manipulating component props * Integration with community-maintained backend services through the Astro integrations directory **Implementation details and use cases:** * Use backend services to manage databases, user authentication, and server-side functionality * Integrate popular features such as user sign-ups, authentication, data storage, and API generation * Leverage backend services for application monitoring, real-time communication, and user-uploaded asset storage",
      "url": "/en/guides/backend/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "backend",
        "service",
        "with",
        "astro"
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/index",
      "language": "en",
      "filePath": "src/content/docs/en/guides/cms/index.mdx",
      "title": "Use a CMS with Astro",
      "summary": "**Astro components are designed to integrate with Content Management Systems (CMS) to fetch and display content dynamically.** **Key features and APIs include:** * `getStaticPaths` for pre-rendering pages with CMS data * `Astro.props` for accessing CMS data in components * Integration with headless CMSes like Storyblok and others **Implementation details and use cases:** * Use a headless CMS to manage content outside of the Astro project * Fetch content data using JavaScript SDKs or CMS-provided integrations * Display content dynamically using Astro components and APIs",
      "url": "/en/guides/cms/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "with",
        "astro"
      ],
      "type": "guide"
    },
    {
      "id": "guides/media/index",
      "language": "en",
      "filePath": "src/content/docs/en/guides/media/index.mdx",
      "title": "Use a DAM with Astro",
      "summary": "**Astro components are designed to integrate with Digital Asset Managers (DAMs) for managing images and videos.** **Key features include:** * Integration with headless DAMs via APIs or SDKs * Support for hosted media systems like Cloudinary * Built-in image storage options * Use of Astro.props and getStaticPaths for asset management **Implementation details and use cases include:** * Using a headless DAM to manage assets across multiple web or mobile properties * Integrating with other content systems like PIMs for product information management * Fetching and displaying assets on a website or app using Astro's integration with Cloudinary.",
      "url": "/en/guides/media/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "media",
        "with",
        "astro"
      ],
      "type": "guide"
    },
    {
      "id": "recipes/bun",
      "language": "en",
      "filePath": "src/content/docs/en/recipes/bun.mdx",
      "title": "Use Bun with Astro",
      "summary": "**Use Bun with Astro** Astro components are built and served using Bun, an all-in-one JavaScript runtime & toolkit, allowing for seamless integration and optimization of Astro projects. **Key Features and APIs** * `bunx create-astro` command for creating new Astro projects with Bun * `bun install` for installing dependencies * `bun add` for adding Astro integrations (e.g., `bunx astro add react`) * `--bun` CLI flag for using Bun's runtime with Astro commands * `@types/bun` package for runtime types **Implementation and Use Cases** Bun is used as the default runtime for Astro projects, enabling features like zero-configuration development and optimized production builds. Use Bun with Astro to create fast, scalable, and maintainable web applications.",
      "url": "/en/recipes/bun/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "with",
        "astro"
      ],
      "type": "recipe"
    },
    {
      "id": "guides/fonts",
      "language": "en",
      "filePath": "src/content/docs/en/guides/fonts.mdx",
      "title": "Using custom fonts",
      "summary": "**Custom Fonts in Astro** Astro components allow for the use of custom fonts through the `@font-face` statement in CSS, enabling the registration of custom font families and their usage in components or layouts. Key features include: * `@font-face` statement for registering custom font families * `font-family` property for styling elements with custom fonts * Support for local font files and Fontsource integration for using Google Fonts and other open-source fonts Implementation details include adding font files to the `public/fonts/` directory, creating a global `.css` file or using a `` block to define the `@font-face` statement, and applying the custom font to elements using the `font-family` property. Use cases include styling headings and other text elements with custom fonts in Astro components and layouts.",
      "url": "/en/guides/fonts/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "using",
        "custom",
        "fonts"
      ],
      "type": "guide"
    },
    {
      "id": "guides/environment-variables",
      "language": "en",
      "filePath": "src/content/docs/en/guides/environment-variables.mdx",
      "title": "Using environment variables",
      "summary": "**Astro Environment Variables** Astro provides access to Vite's built-in environment variables support, including default environment variables for project configuration, and allows for type-safe organization and use of environment variables within the Astro context. Environment variables can be accessed using `import.meta.env` and are statically replaced at build time. **Supported features include:** `import.meta.env`, `.env` files, `PUBLIC_` prefix for client-side availability, and IntelliSense for TypeScript.",
      "url": "/en/guides/environment-variables/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "using",
        "environment",
        "variables"
      ],
      "type": "guide"
    },
    {
      "id": "recipes/streaming-improve-page-performance",
      "language": "en",
      "filePath": "src/content/docs/en/recipes/streaming-improve-page-performance.mdx",
      "title": "Using streaming to improve page performance",
      "summary": "**Astro components are optimized for streaming to improve page performance by sending components to the browser as they become available.** **Key features and APIs include:** * HTML streaming for faster page loading * `await` calls moved to smaller components to avoid blocking data fetches * Use of `fetch` API for data fetching * Astro's streaming allows for rendering of HTML before data is ready **Implementation details and use cases:** * Refactoring example demonstrates moving fetch calls to other components for improved performance * Astro page can render parts of the page sooner by using smaller components for data fetching * Use of streaming enables faster page loading and improved user experience",
      "url": "/en/recipes/streaming-improve-page-performance/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "using",
        "streaming",
        "improve",
        "page"
      ],
      "type": "recipe"
    },
    {
      "id": "reference/errors/locals-not-an-object",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/locals-not-an-object.mdx",
      "title": "Value assigned to locals is not accepted.",
      "summary": "**Astro middleware defines are restricted to object assignments.** `locals` can only be assigned to an object using `context.locals = { ... }`, whereas assigning non-object values like numbers, strings, etc. is not accepted. This restriction is enforced by the `LocalsNotAnObject` error, thrown when `locals` is overwritten with a non-object value.",
      "url": "/en/reference/errors/locals-not-an-object/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "value",
        "assigned",
        "locals",
        "accepted."
      ],
      "type": "guide"
    },
    {
      "id": "recipes/captcha",
      "language": "en",
      "filePath": "src/content/docs/en/recipes/captcha.mdx",
      "title": "Verify a Captcha",
      "summary": "**Verify a Captcha** Astro components are used to create an API route and fetch it from the client to verify Google reCAPTCHA v3 without exposing the secret to clients. **Key Features and APIs:** * `POST` endpoint to accept recaptcha data and verify it with reCAPTCHA's API * `fetch` API to send a POST request to the endpoint from a client script * `Response` object to return the verification result * `URLSearchParams` to construct the request body * `new Response` to create a response object with the verification result **Implementation Details and Use Cases:** * Create a `POST` endpoint to verify reCAPTCHA data * Use `fetch` to send a POST request to the endpoint from a client script * Return the verification result as a JSON response * Use environment variables to store sensitive data, such as the secret key * Integrate with reCAPTCHA's API to verify the user's response",
      "url": "/en/recipes/captcha/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "verify",
        "captcha"
      ],
      "type": "recipe"
    },
    {
      "id": "guides/view-transitions",
      "language": "en",
      "filePath": "src/content/docs/en/guides/view-transitions.mdx",
      "title": "View transitions",
      "summary": "**View Transitions** Astro components enable seamless navigation between pages with view transitions, a popular design choice for preserving visual continuity as visitors move between states or views of an application. View transitions are powered by the View Transitions browser API and include built-in animation options, support for forwards and backwards navigation animations, and customizable animation options. Key features include carrying HTML elements during navigation, preventing client-side navigation for non-page links, and fallback behavior control for browsers without View Transition API support.",
      "url": "/en/guides/view-transitions/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "view",
        "transitions"
      ],
      "type": "guide"
    },
    {
      "id": "reference/modules/astro-transitions",
      "language": "en",
      "filePath": "src/content/docs/en/reference/modules/astro-transitions.mdx",
      "title": "View Transitions Router API Reference",
      "summary": "**View Transitions Router API Reference** The View Transitions Router API provides functions to control and interact with the View Transitions API and client-side router, enabling customizable page transitions and routing on individual pages. Key features include the `` component, `fade` and `slide` utility functions, and support for transition directives on page elements and components.",
      "url": "/en/reference/modules/astro-transitions/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "modules",
        "view",
        "transitions",
        "router"
      ],
      "type": "guide"
    },
    {
      "id": "concepts/why-astro",
      "language": "en",
      "filePath": "src/content/docs/en/concepts/why-astro.mdx",
      "title": "Why Astro?",
      "summary": "**Astro is a web framework for building content-driven websites like blogs, marketing, and e-commerce, pioneering a new frontend architecture to reduce JavaScript overhead and complexity.** **Key Features:** * Islands: A component-based web architecture optimized for content-driven websites * UI-agnostic: Supports React, Preact, Svelte, Vue, Solid, HTMX, web components, and more * Server-first: Moves expensive rendering off of visitors' devices * Zero JS, by default: Less client-side JavaScript to slow down the site * Content collections: Organize, validate, and provide TypeScript type-safety for Markdown content * Customizable: Partytown, MDX, and hundreds of integrations available **Implementation Details:** * Astro includes everything needed to create a website, with built-in integrations and API hooks for customization * Supports server-first rendering, reducing JavaScript overhead and complexity * Optimized for content-driven websites, with features like content collections and UI-agnostic support",
      "url": "/en/concepts/why-astro/",
      "keywords": [
        "content",
        "docs",
        "concepts",
        "astro?"
      ],
      "type": "guide"
    },
    {
      "id": "tutorial/1-setup/3",
      "language": "en",
      "filePath": "src/content/docs/en/tutorial/1-setup/3.mdx",
      "title": "Write your first line of Astro",
      "summary": "**Astro components are a set of reusable UI elements for building web applications, featuring internationalization support and integration with Astro's Starlight components.** **Key features include:** * Importing Astro components using `import` statements (e.g., `import Checklist from '~/components/Checklist.astro';`) * Using Astro components in templates (e.g., `...`) * Accessing component props using `Astro.props` (e.g., `Astro.props.generator`) * Implementing steps and tutorials using the `` component * Editing Astro files in the code editor and previewing changes in the browser **Implementation details and use cases:** * Editing Astro files in the code editor and previewing changes in the browser * Using Astro components to build reusable UI elements for web applications * Integrating Astro components with other Astro features, such as Starlight components and internationalization support",
      "url": "/en/tutorial/1-setup/3/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "1 setup",
        "write",
        "your",
        "first",
        "line"
      ],
      "type": "tutorial"
    },
    {
      "id": "tutorial/2-pages/2",
      "language": "en",
      "filePath": "src/content/docs/en/tutorial/2-pages/2.mdx",
      "title": "Write your first Markdown blog post",
      "summary": "**Astro components are used to create interactive and dynamic content for blog posts.** **Key features include:** * Importing Astro components (e.g., Checklist, Blanks, Box, MultipleChoice, Option, PreCheck, Badge) and Starlight components (e.g., Steps) * Using Markdown files (e.g., post-1.md) to create blog posts with metadata (e.g., title, pubDate, description, author, image, tags) * Utilizing Astro's built-in features for internationalization and static site generation **Implementation details and use cases:** * Creating a new directory for blog posts (e.g., src/pages/posts/) * Writing Markdown content with metadata and formatting (e.g., headings, lists) * Using Astro components to create interactive elements (e.g., Checklist, MultipleChoice) * Previewing blog posts in the browser with dynamic routing (e.g., /posts/post-1, /posts/post-2)",
      "url": "/en/tutorial/2-pages/2/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "2 pages",
        "write",
        "your",
        "first",
        "markdown"
      ],
      "type": "tutorial"
    },
    {
      "id": "guides/backend/xata",
      "language": "en",
      "filePath": "src/content/docs/en/guides/backend/xata.mdx",
      "title": "Xata & Astro",
      "summary": "**Xata & Astro Integration** **Purpose:** Add a serverless database with full-text search to your Astro project using Xata's REST API. **Features:** * Serverless Data Platform with relational database, search engine, and analytics engine * Exposes a single consistent REST API * Supports full-text search * Integrates with Astro's environment variables and package management **Implementation Details:** * Requires a Xata account, API token, and database URL * Uses Xata CLI for setup and code generation * Generates an instance of the Xata SDK with types tailored to the database schema * Automatically pulls environment variables and database URL from the SDK instance **Use Cases:** * Add a serverless database to your Astro project * Enable full-text search in your application * Leverage Xata's analytics engine for data insights",
      "url": "/en/guides/backend/xata/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "backend",
        "xata",
        "astro"
      ],
      "type": "backend"
    },
    {
      "id": "reference/errors/invalid-rewrite404",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/invalid-rewrite404.mdx",
      "title": "You attempted to rewrite a 404 inside a static page, and this isnt allowed.",
      "summary": "**InvalidRewrite404**: Rewriting a 404 is only allowed inside on-demand pages. **Error Cause**: Attempting to rewrite a 404 page inside a static page. **Allowed Use Case**: Rewrite 404 pages using `getStaticPaths` method in on-demand pages. **Deprecated**: This error is from an older version of Astro and is no longer in use.",
      "url": "/en/reference/errors/invalid-rewrite404/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "attempted",
        "rewrite",
        "inside",
        "static"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/incorrect-strategy-for-i18n",
      "language": "en",
      "filePath": "src/content/docs/en/reference/errors/incorrect-strategy-for-i18n.mdx",
      "title": "You cant use the current function with the current strategy",
      "summary": "**Astro components are restricted by i18n routing strategy** The `DontEditWarning` component can only be used when `i18n.routing.strategy` is set to `\"manual\"`, utilizing the `i18n.routing` configuration setting. This restriction is due to some internationalization functions being available only when Astro's own i18n routing is disabled. See the `i18n` routing guide for more information on configuring Astro's internationalization features.",
      "url": "/en/reference/errors/incorrect-strategy-for-i18n/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "cant",
        "current",
        "function",
        "with"
      ],
      "type": "guide"
    }
  ]
}