{
  "version": "2.0",
  "generated": "2025-08-03T00:12:34.380Z",
  "languages": [
    "en"
  ],
  "count": 378,
  "metadata": {
    "urlStrategy": "auto",
    "baseUrl": null,
    "summaryStrategy": "standard"
  },
  "documents": [
    {
      "id": "guides/integrations-guide/alpinejs",
      "language": "en",
      "title": "@astrojs/alpinejs",
      "summary": "**@astrojs/alpinejs Integration** Astro components are extended with Alpine.js support, enabling the use of Alpine.js anywhere on the page. Key features include: * `astro add` command for automated setup * `integrations` property in `astro.config.*` file for manual integration * Support for Alpine.js methods and APIs, such as `$` and `x-data` Implementation details involve installing the `@astrojs/alpinejs` package and associated peer dependencies, then applying the integration to the `astro.config.*` file.",
      "url": "/en/guides/integrations-guide/alpinejs/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "renderer",
        "integration",
        "@astrojs/alpinejs"
      ],
      "type": "integration"
    },
    {
      "id": "guides/integrations-guide/cloudflare",
      "language": "en",
      "title": "@astrojs/cloudflare",
      "summary": "Here is the technical documentation summary: **@astrojs/cloudflare Adapter** The @astrojs/cloudflare adapter enables deployment of Astro projects to Cloudflare, supporting on-demand rendered routes and features, server islands, actions, and sessions. This adapter integrates with Cloudflare's Developer Platform, providing access to resources such as storage and AI, and deploys to a global edge network. The adapter can be installed using the `astro add` command or manually, and enables server-rendering and on-demand rendering per page.",
      "url": "/en/guides/integrations-guide/cloudflare/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "adapter",
        "integration",
        "@astrojs/cloudflare"
      ],
      "type": "integration"
    },
    {
      "id": "guides/integrations-guide/db",
      "language": "en",
      "title": "@astrojs/db",
      "summary": "Astro DB is a fully-managed SQL database designed for the Astro ecosystem, enabling local development and deployment to libSQL-compatible databases. Key features include type-safe querying and modeling of content as a relational database, with APIs such as `db()` and `db.config.ts` for configuration. Astro DB can be installed using `astro add db` or manually via npm/pnpm/yarn and `astro.config.mjs` integration.",
      "url": "/en/guides/integrations-guide/db/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "other",
        "integration",
        "@astrojs/db"
      ],
      "type": "integration"
    },
    {
      "id": "guides/integrations-guide/markdoc",
      "language": "en",
      "title": "@astrojs/markdoc",
      "summary": "Astro components are enhanced with Markdoc functionality for creating components, pages, and content collection entries. Key features include Astro.props, getStaticPaths, and integration with Astro components such as FileTree, Steps, and ReadMore. This integration enables the usage of Markdoc to bring existing content authored in Markdoc to an Astro project using content collections.",
      "url": "/en/guides/integrations-guide/markdoc/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "other",
        "integration",
        "@astrojs/markdoc"
      ],
      "type": "integration"
    },
    {
      "id": "guides/integrations-guide/mdx",
      "language": "en",
      "title": "@astrojs/mdx",
      "summary": "**@astrojs/mdx Integration** Astro components are enabled for MDX usage, allowing creation of pages as `.mdx` files, with support for variables, JSX expressions, and components within Markdown content. Key features include: * `astro add mdx` command for automated setup * `@astrojs/mdx` package installation * `integrations` property in `astro.config.*` file for integration configuration * Support for editor integration in VS Code through the official MDX extension Implementation details include using the `mdx()` function in `astro.config.*` file and installing the `@astrojs/mdx` package. Use cases include bringing existing MDX content to an Astro project and creating new pages as `.mdx` files.",
      "url": "/en/guides/integrations-guide/mdx/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "other",
        "integration",
        "@astrojs/mdx"
      ],
      "type": "integration"
    },
    {
      "id": "guides/integrations-guide/netlify",
      "language": "en",
      "title": "@astrojs/netlify",
      "summary": "**@astrojs/netlify Adapter** The @astrojs/netlify adapter enables Astro to deploy on-demand rendered routes and features to Netlify, including server islands, actions, and sessions. It enhances the Astro build process to prepare projects for deployment through Netlify, supporting features like Netlify Image CDN. The adapter can be installed using the `astro add` command or manually, and enables on-demand rendering per page or server-rendering all pages by default.",
      "url": "/en/guides/integrations-guide/netlify/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "adapter",
        "integration",
        "@astrojs/netlify"
      ],
      "type": "integration"
    },
    {
      "id": "guides/integrations-guide/node",
      "language": "en",
      "title": "@astrojs/node",
      "summary": "Astro components are deployable to Node targets using the @astrojs/node adapter, enabling on-demand rendered routes and features, including server islands, actions, and sessions. Key features include: * getStaticPaths for server-side rendering * Astro.props for accessing component props * Support for server islands, actions, and sessions * Integration with Express and other http servers * Automated setup with `astro add` command or manual installation via npm, pnpm, or yarn Implementation details include: * Installing `@astrojs/node` via `astro add` or manual package manager commands * Enabling on-demand rendering per page or setting build output to `output: 'server'` for server-rendering all pages by default",
      "url": "/en/guides/integrations-guide/node/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "adapter",
        "integration",
        "@astrojs/node"
      ],
      "type": "integration"
    },
    {
      "id": "guides/integrations-guide/partytown",
      "language": "en",
      "title": "@astrojs/partytown",
      "summary": "**@astrojs/partytown Integration** Astro components are enabled with the @astrojs/partytown integration, which installs and configures Partytown for lazy-loaded resource intensive scripts in web workers, offloading from the main thread. Key features include: * `astro add partytown` command for automated setup * `@astrojs/partytown` package installation * `integrations` property in `astro.config.*` file for manual configuration * Partytown lazy-loading and web worker support for third-party scripts Implementation details include using `astro add` or manual package installation, followed by configuration in `astro.config.*` file. Use cases include offloading resource-intensive scripts for analytics, ads, or other third-party services.",
      "url": "/en/guides/integrations-guide/partytown/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "other",
        "integration",
        "@astrojs/partytown"
      ],
      "type": "integration"
    },
    {
      "id": "guides/integrations-guide/preact",
      "language": "en",
      "title": "@astrojs/preact",
      "summary": "Astro components are extended with Preact support through the @astrojs/preact framework integration, enabling rendering and client-side hydration for Preact components. Key features include Astro.props, getStaticPaths, and compatibility with React components via the compat configuration option. Implementation details involve installing the @astrojs/preact package using `astro add preact` or manual installation via npm, pnpm, or yarn. Use cases include building interactive UI components for the web and leveraging Preact's smaller package size and React compatibility.",
      "url": "/en/guides/integrations-guide/preact/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "renderer",
        "integration",
        "@astrojs/preact"
      ],
      "type": "integration"
    },
    {
      "id": "guides/integrations-guide/prefetch",
      "language": "en",
      "title": "@astrojs/prefetch",
      "summary": "Astro components are enhanced with dynamic prefetching capabilities through the `@astrojs/prefetch` integration, which allows for preloading of resources and data before page loads. Key features include support for `getStaticPaths`, `Astro.props`, and dynamic import handling. Implementation details involve integrating with Astro's built-in routing and caching mechanisms to optimize page loading performance. This integration is deprecated in favor of the built-in `prefetch` feature introduced in Astro 3.5, and users are advised to migrate to the new implementation for optimal results.",
      "url": "/en/guides/integrations-guide/prefetch/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "@astrojs/prefetch"
      ],
      "type": "guide"
    },
    {
      "id": "guides/integrations-guide/react",
      "language": "en",
      "title": "@astrojs/react",
      "summary": "Astro components are extended with React support through the @astrojs/react framework integration, enabling rendering and client-side hydration for React components. Key features include Astro.add, astro.config.integrations, and Astro.props, with implementation details involving installation via astro add or manual npm/pnpm/yarn installation, followed by integration configuration in astro.config.*.",
      "url": "/en/guides/integrations-guide/react/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "renderer",
        "integration",
        "@astrojs/react"
      ],
      "type": "integration"
    },
    {
      "id": "guides/integrations-guide/sitemap",
      "language": "en",
      "title": "@astrojs/sitemap",
      "summary": "**Astro Sitemap Integration** The Astro Sitemap integration generates a sitemap based on statically-generated routes in Astro projects, including dynamic routes like `[...slug]` or `src/pages/[lang]/[version]/info.astro` generated by `getStaticPaths()`. This integration uses the `@astrojs/sitemap` package to create an XML file outlining all pages, videos, and files on the site, improving search engine crawl efficiency. The integration is installed using the `astro add` command or manually via npm, pnpm, or yarn.",
      "url": "/en/guides/integrations-guide/sitemap/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "other",
        "integration",
        "@astrojs/sitemap"
      ],
      "type": "integration"
    },
    {
      "id": "guides/integrations-guide/solid-js",
      "language": "en",
      "title": "@astrojs/solid-js",
      "summary": "Astro components are extended with support for SolidJS components through the @astrojs/solid-js framework integration, enabling rendering and client-side hydration. Key features include: * Integration with Astro's `astro add` command for automated setup * Support for SolidJS components through the `@astrojs/solid-js` package * Client-side hydration for improved performance * Installation via `npm`, `pnpm`, or `yarn` with associated peer dependencies Implementation details involve installing the `@astrojs/solid-js` package and applying the integration to the `astro.config.*` file using the `integrations` property.",
      "url": "/en/guides/integrations-guide/solid-js/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "renderer",
        "integration",
        "@astrojs/solid-js"
      ],
      "type": "integration"
    },
    {
      "id": "guides/integrations-guide/svelte",
      "language": "en",
      "title": "@astrojs/svelte",
      "summary": "Astro components are extended to support Svelte 5 components through the @astrojs/svelte framework integration, enabling rendering and client-side hydration. Key features include: * Support for Svelte 5 components * Client-side hydration * Integration with Astro's `astro add` command for automated setup * Manual installation via npm, pnpm, or yarn * Peer dependencies installation for Svelte and TypeScript Implementation details involve installing the `@astrojs/svelte` package and applying the integration to the `astro.config.*` file using the `integrations` property.",
      "url": "/en/guides/integrations-guide/svelte/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "renderer",
        "integration",
        "@astrojs/svelte"
      ],
      "type": "integration"
    },
    {
      "id": "guides/integrations-guide/tailwind",
      "language": "en",
      "title": "@astrojs/tailwind",
      "summary": "**@astrojs/tailwind Integration** The @astrojs/tailwind integration enables seamless use of Tailwind CSS in Astro projects, providing a pre-configured setup for styling components with Tailwind's utility-first approach. Key features include: * Integration with Astro's component lifecycle and rendering pipeline * Support for Tailwind's utility classes and configuration options * Utilization of Astro.props and getStaticPaths APIs for dynamic styling and server-side rendering Implementation details involve configuring the integration in Astro's project settings and utilizing Tailwind's CSS classes within Astro components. Use cases include styling Astro pages, components, and layouts with Tailwind's utility-first approach, enabling rapid and consistent styling of Astro applications.",
      "url": "/en/guides/integrations-guide/tailwind/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "@astrojs/tailwind"
      ],
      "type": "guide"
    },
    {
      "id": "guides/integrations-guide/vercel",
      "language": "en",
      "title": "@astrojs/vercel",
      "summary": "**@astrojs/vercel Adapter** The @astrojs/vercel adapter enables deployment of Astro projects to Vercel, supporting on-demand rendered routes and features, server islands, actions, and sessions. It integrates with Vercel services such as Web Analytics and Image Optimization. The adapter is installed using the `astro add` command, which automates setup and updates the `astro.config.mjs` file.",
      "url": "/en/guides/integrations-guide/vercel/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "adapter",
        "integration",
        "@astrojs/vercel"
      ],
      "type": "integration"
    },
    {
      "id": "guides/integrations-guide/vue",
      "language": "en",
      "title": "@astrojs/vue",
      "summary": "Astro components are extended to support rendering and client-side hydration for Vue 3 components through the @astrojs/vue framework integration. Key features include automatic installation via `astro add` command, manual installation via npm or yarn, and integration configuration via `astro.config.*` file using the `integrations` property.",
      "url": "/en/guides/integrations-guide/vue/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "renderer",
        "integration",
        "@astrojs/vue"
      ],
      "type": "integration"
    },
    {
      "id": "guides/integrations-guide/deno",
      "language": "en",
      "title": "@deno/astro-adapter",
      "summary": "The Deno Astro adapter enables Astro to deploy SSR sites to Deno targets, including Deno Deploy, utilizing Deno's serverless capabilities. Key features include integration with Deno's runtime and deployment services, leveraging APIs such as `getStaticPaths` and `Astro.props` for server-side rendering. Implementation involves migrating to the Deno-maintained adapter or adding an alternative adapter for continued SSR functionality.",
      "url": "/en/guides/integrations-guide/deno/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "@deno/astro-adapter"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/redirect-with-no-location",
      "language": "en",
      "title": "A redirect must be given a location with the Location header.",
      "summary": "Astro components require a redirect to be given a location with the `Location` header for proper functionality. This is achieved through the `Astro.redirect` API, which must be used in conjunction with the `Location` header to ensure correct routing behavior. Implementation details involve using the `redirect` method to specify the target location, and use cases include server-side rendering and client-side routing scenarios.",
      "url": "/en/reference/errors/redirect-with-no-location/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "redirect",
        "must",
        "given",
        "location"
      ],
      "type": "guide"
    },
    {
      "id": "tutorial/0-introduction/1",
      "language": "en",
      "title": "About this Tutorial",
      "summary": "**Astro Tutorial Overview** Astro components are used to create interactive web applications, utilizing HTML, Markdown, CSS, and JavaScript. Key features include Astro.props, Astro components (e.g., Checklist, Box), and GitHub integration for publishing projects. Implementation details include local storage for tracking progress and optional use of the Tutorial Tracker.",
      "url": "/en/tutorial/0-introduction/1/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "0 introduction",
        "about",
        "this"
      ],
      "type": "tutorial"
    },
    {
      "id": "reference/errors/actions-returned-invalid-data-error",
      "language": "en",
      "title": "Action handler returned invalid data.",
      "summary": "**Actions Returned Invalid Data Error** Astro actions handler returned invalid data, violating the requirement to return serializable data types such as objects, arrays, strings, and numbers. The error occurs when the handler returns a Response object, which is not a supported data type. This issue is critical and can be resolved by revising the handler to return a valid serializable data type.",
      "url": "/en/reference/errors/actions-returned-invalid-data-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "action",
        "handler",
        "returned",
        "invalid"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/action-not-found-error",
      "language": "en",
      "title": "Action not found.",
      "summary": "**ActionNotFoundError**: The server received a request for an action named `ACTION_NAME` but could not find a match. This error occurs when the server fails to locate an action with the specified name, typically due to a mismatch between the action name and its updated reference in `actions/index` or calling code. The error is triggered by the `ActionNotFoundError` exception, which can be resolved by verifying the action name consistency across the application.",
      "url": "/en/reference/errors/action-not-found-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "action",
        "found."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/action-called-from-server-error",
      "language": "en",
      "title": "Action unexpected called from the server.",
      "summary": "**ActionCalledFromServerError**: A wrapper component that must be used to call actions from server code, preventing unexpected action calls from server pages or endpoints without using `Astro.callAction()`. This component is used to ensure correct action invocation and prevent errors. It is typically used in conjunction with `Astro.callAction()` API.",
      "url": "/en/reference/errors/action-called-from-server-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "action",
        "unexpected",
        "called",
        "from"
      ],
      "type": "guide"
    },
    {
      "id": "guides/actions",
      "language": "en",
      "title": "Actions",
      "summary": "**Astro Actions are server functions that enable type-safe communication between client and server code, performing data fetching, JSON parsing, and input validation with Zod validation.** **Key Features:** * Define actions in a `server` object exported from `src/actions/index.ts` using `defineAction` from `astro:actions`. * Use `astro:actions` module to call actions client-side within UI framework components, form POST requests, or script tags. * Actions return an object with `data` or `error` properties, containing JSON-serialized results or thrown errors. **Implementation Details:** * Use `defineAction` to define actions with input validation using Zod validation. * Call actions using `actions.myAction` and await the result. * Handle errors with the `ActionError` object. **Use Cases:** * Replace API endpoints with type-safe actions for seamless communication. * Automatically validate JSON and form data inputs. * Generate type-safe functions for client-side and HTML form actions.",
      "url": "/en/guides/actions/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "actions"
      ],
      "type": "guide"
    },
    {
      "id": "reference/modules/astro-actions",
      "language": "en",
      "title": "Actions API Reference",
      "summary": "**Actions API Reference** Actions help you build a type-safe backend you can call from client code and HTML forms. The `astro:actions` module exposes utilities to define and call actions, including `defineAction()`, `isInputError()`, `isActionError()`, and `ActionError`. **Key Features and APIs** * `defineAction()`: defines new actions from the `src/actions/index.ts` file, accepting a `handler()` function and an optional `input` property to validate input parameters. * `handler()`: a required function containing server logic to run when the action is called, with user input as its first argument and a `context` object as its second argument. * `isInputError()`: checks if an error is an input error. * `isActionError()`: checks if an error is an action error. * `ActionError`: a class representing an action error. **Implementation Details and Use Cases** * Use `defineAction()` to define new actions in the `src/actions/index.ts` file. * Implement a `handler()` function to run server logic when the action is called. * Use `isInputError()` and `isActionError()` to handle errors in your action handlers. * Return values from the `handler()` function are parsed using the devalue library.",
      "url": "/en/reference/modules/astro-actions/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "modules",
        "actions"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/actions-without-server-output-error",
      "language": "en",
      "title": "Actions must be used with server output.",
      "summary": "**Actions must be used with server output.** Astro components require a server output to create callable backend functions, which can be achieved by adding an adapter to the Astro config and configuring routes for on-demand rendering using `getStaticPaths` and `Astro.props`. This ensures that backend functions are executed on the server, enabling features like server-side rendering and API routes. The `ActionsWithoutServerOutputError` occurs when a project lacks a server output, preventing the creation of callable backend functions.",
      "url": "/en/reference/errors/actions-without-server-output-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "actions",
        "must",
        "used",
        "with"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/adapter-support-output-mismatch",
      "language": "en",
      "title": "Adapter does not support server output.",
      "summary": "**Adapter does not support server output.** The `ADAPTER_NAME` adapter is configured to output a static website, but the project contains server-rendered pages. This mismatch requires installing and configuring the appropriate server adapter for final deployment. The adapter does not support server-side rendering, necessitating a different entrypoint, such as `@astrojs/vercel/serverless`, for server-side rendering.",
      "url": "/en/reference/errors/adapter-support-output-mismatch/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "adapter",
        "does",
        "support",
        "server"
      ],
      "type": "guide"
    },
    {
      "id": "recipes/rss",
      "language": "en",
      "title": "Add an RSS feed",
      "summary": "**Astro RSS Feed Generation** Astro supports fast, automatic RSS feed generation for blogs and other content websites using the `@astrojs/rss` package. This package provides helpers for generating RSS feeds using API endpoints, unlocking both static builds and on-demand generation when using an SSR adapter. **Key Features and APIs** * `rss()` helper from `@astrojs/rss` package * `GET` function to export RSS feed * `title`, `site`, and other parameters for customizing RSS feed output * Support for static builds and on-demand generation with SSR adapter **Implementation Details and Use Cases** * Install `@astrojs/rss` using npm, pnpm, or yarn * Create a file in `src/pages/` with a `.xml.js` extension for the RSS feed output URL * Import `rss()` helper and export a `GET` function with the required parameters",
      "url": "/en/recipes/rss/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "feed"
      ],
      "type": "recipe"
    },
    {
      "id": "tutorial/5-astro-api/4",
      "language": "en",
      "title": "Add an RSS feed",
      "summary": "**Astro RSS Feed Integration** Astro provides a custom package to generate an RSS feed for your website, enabling users to subscribe and receive notifications when new blog posts are published. The feed is updated every time the site is rebuilt and can be read by feed readers like Feedly and The Old Reader. **Key Features and APIs:** * `@astrojs/rss` package for installing and generating RSS feeds * `rss.xml.js` file for creating the feed document * `npm install`, `pnpm add`, and `yarn add` commands for installing the package * `npm run dev`, `pnpm run dev`, and `yarn run dev` commands for restarting the dev server **Implementation Details and Use Cases:** * Create a new file `rss.xml.js` in `src/pages/` to generate the feed document * Use the `@astrojs/rss` package to generate the feed * Update the feed every time the site is rebuilt * Subscribe to the feed using feed readers like Feedly and The Old Reader",
      "url": "/en/tutorial/5-astro-api/4/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "5 astro api",
        "feed"
      ],
      "type": "tutorial"
    },
    {
      "id": "tutorial/2-pages/3",
      "language": "en",
      "title": "Add dynamic content about you",
      "summary": "**Astro components are used to add dynamic content to HTML files, enabling conditional rendering and variable usage.** **Key features include:** * Importing Astro components (e.g., `Checklist`, `Spoiler`, `Steps`) and using them in HTML files * Defining and using variables in Astro frontmatter (e.g., `const pageTitle = \"About Me\";`) * Conditionally displaying HTML elements using Astro's dynamic rendering capabilities * Utilizing Astro's built-in components (e.g., `Steps`) to create interactive content **Implementation details and use cases:** * Astro components can be used to create interactive tutorials, quizzes, and other dynamic content * Variables can be defined in Astro frontmatter and used throughout the HTML file to create dynamic content * Astro's dynamic rendering capabilities enable conditional rendering of HTML elements based on user input or other factors",
      "url": "/en/tutorial/2-pages/3/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "2 pages",
        "dynamic",
        "about"
      ],
      "type": "tutorial"
    },
    {
      "id": "recipes/i18n",
      "language": "en",
      "title": "Add i18n features",
      "summary": "**Astro components are used to implement internationalization (i18n) support through dynamic routing and content collections.** **Key features and APIs include:** * Dynamic routing with support for multiple languages * Content collections for serving content in different languages * Helper functions for serving an international audience * Built-in support for i18n routing in v4.0 **Implementation details and use cases:** * Create directories for each language and set up pages for each language * Use `meta refresh` to redirect to the default language * Use `FileTree` and `StaticSsrTabs` components to visualize directory structure and implement static site generation * Hide the default language in the URL using instructions provided in the recipe.",
      "url": "/en/recipes/i18n/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "i18n",
        "features"
      ],
      "type": "recipe"
    },
    {
      "id": "recipes/external-links",
      "language": "en",
      "title": "Add icons to external links",
      "summary": "Astro components are used to add icons to external links in Markdown files by installing a rehype plugin. The `rehype-external-links` plugin is installed using npm, pnpm, or yarn, and imported into the `astro.config.mjs` file as a rehype plugin with an options object that includes a content property. The content property is set to either 'text' or 'raw' to add plain text or HTML to the end of the link, respectively.",
      "url": "/en/recipes/external-links/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "icons",
        "external",
        "links"
      ],
      "type": "recipe"
    },
    {
      "id": "guides/integrations-guide/index",
      "language": "en",
      "title": "Add Integrations",
      "summary": "**Astro integrations** add new functionality and behaviors for your project with only a few lines of code, unlocking features like React, Vue, Svelte, and Solid UI frameworks, on-demand rendering, and tool integrations like MDX and Partytown. Integrations can be added using the `astro add` command or manually installed, with hundreds of official and community integrations available in the Astro integrations directory. Key features include renderer support, SSR adapters, and custom code hooks into the build process, dev server, and more.",
      "url": "/en/guides/integrations-guide/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide",
        "integrations"
      ],
      "type": "guide"
    },
    {
      "id": "recipes/modified-time",
      "language": "en",
      "title": "Add last modified time",
      "summary": "**Astro components are used to build a remark plugin that adds the last modified time to Markdown and MDX files.** **Key features and APIs include:** * `execSync` to run Git commands and retrieve the timestamp of the latest commit * `remarkModifiedTime` function to add the timestamp to the frontmatter of the file * `child_process` module for executing Git commands * `Day.js` library for modifying and formatting times **Implementation details and use cases:** * The plugin uses Git history to calculate the last modified time, which may not be accurate on some deployment platforms * The plugin can be used to display the modified time in pages, and is ready for internationalization",
      "url": "/en/recipes/modified-time/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "last",
        "modified",
        "time"
      ],
      "type": "recipe"
    },
    {
      "id": "recipes/reading-time",
      "language": "en",
      "title": "Add reading time",
      "summary": "**Astro components are used to create a remark plugin that adds a reading time property to the frontmatter of Markdown or MDX files.** **Key features and APIs include:** * `remarkReadingTime` plugin function that calculates reading time using `reading-time` and `mdast-util-to-string` packages * `toString` method from `mdast-util-to-string` to extract text from Markdown files * `getReadingTime` function from `reading-time` to calculate reading time in minutes * `data.astro.frontmatter.minutesRead` property to store reading time in minutes as a friendly string **Implementation details and use cases:** * Install `reading-time` and `mdast-util-to-string` packages using npm, pnpm, or yarn * Create a remark plugin using the `remarkReadingTime` function * Add the plugin to Astro config using `remarkPlugins` array",
      "url": "/en/recipes/reading-time/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "reading",
        "time"
      ],
      "type": "recipe"
    },
    {
      "id": "tutorial/2-pages/5",
      "language": "en",
      "title": "Add site-wide styling",
      "summary": "**Astro components are used to add site-wide styling through global CSS files.** **Key features and APIs include:** * Creating a global stylesheet in `src/styles/global.css` * Importing the global stylesheet in each page using `import '../styles/global.css';` * Using CSS selectors to define styles globally, such as `html`, `body`, and `*` * Implementing global styles in `global.css` files, including font family, background color, and margin settings. **Implementation details and use cases:** * Creating a `global.css` file in the `src/styles` directory * Importing the global stylesheet in each page's frontmatter * Using global styles to control layout, typography, and spacing across the site * Combining global styles with scoped styles using the `` tag for specific elements.",
      "url": "/en/tutorial/2-pages/5/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "2 pages",
        "site-wide",
        "styling"
      ],
      "type": "tutorial"
    },
    {
      "id": "reference/errors/action-query-string-invalid-error",
      "language": "en",
      "title": "An invalid Action query string was passed by a form.",
      "summary": "**ActionQueryStringInvalidError**: The server received the query string `?_astroAction=ACTION_NAME`, but could not find an action with that name. This error occurs when the server receives an invalid action query string, typically due to a mismatch between the action name in the URL and the actual action function name. To resolve this, use the action function's `.queryString` property to retrieve the form `action` URL.",
      "url": "/en/reference/errors/action-query-string-invalid-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "invalid",
        "action",
        "query",
        "string"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/actions-used-with-for-get-error",
      "language": "en",
      "title": "An invalid Action query string was passed by a form.",
      "summary": "**Action Query String Validation** Astro components validate action query strings to prevent invalid GET requests from forms. Key features include: * **Action Validation**: Checks if an action is called from a form using a GET request, which is not supported. * **Method Validation**: Verifies if the form's `method` attribute is set to \"POST\", which is required for form actions. * **Deprecated since version 4.13.2**: The `method` attribute is deprecated and will be removed in future versions. Implementation details and use cases involve checking the `method` attribute on forms and ensuring it is set to \"POST\" for action calls. This is critical for preventing invalid GET requests and ensuring proper form functionality.",
      "url": "/en/reference/errors/actions-used-with-for-get-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "invalid",
        "action",
        "query",
        "string"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/unknown-filesystem-error",
      "language": "en",
      "title": "An unknown error occurred while reading or writing files to disk.",
      "summary": "**Error Handling in Astro Components** Astro components are designed to handle file system errors, including unknown errors while reading or writing files to disk. Key features include error detection through file system operations and error handling through Astro's built-in error management APIs, such as `Astro.props` and `getStaticPaths`. Implementation details involve checking for missing permissions and non-existent files, with use cases including file-based data storage and caching in Astro applications.",
      "url": "/en/reference/errors/unknown-filesystem-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "unknown",
        "error",
        "occurred",
        "while"
      ],
      "type": "guide"
    },
    {
      "id": "recipes/analyze-bundle-size",
      "language": "en",
      "title": "Analyze bundle size",
      "summary": "**Astro bundle analysis is facilitated by integrating `rollup-plugin-visualizer` to visualize and optimize bundle size.** **Key features and APIs:** * `rollup-plugin-visualizer` library for bundle visualization and analysis * `visualizer` plugin for Rollup configuration * `defineConfig` function for Astro configuration * `vite` plugin for Rollup configuration * `emitFile` and `filename` options for visualizer configuration * `npm run build`, `pnpm build`, and `yarn build` commands for building the project **Implementation details and use cases:** * Install `rollup-plugin-visualizer` using npm, pnpm, or yarn * Add the `visualizer` plugin to the `astro.config.mjs` file * Run the build command to generate the `stats.html` file * Analyze the bundle size and optimize the project accordingly",
      "url": "/en/recipes/analyze-bundle-size/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "analyze",
        "bundle",
        "size"
      ],
      "type": "recipe"
    },
    {
      "id": "guides/cms/apostrophecms",
      "language": "en",
      "title": "ApostropheCMS & Astro",
      "summary": "Here is the technical documentation summary: **ApostropheCMS & Astro Integration** ApostropheCMS is a content management system that enables on-page editing in Astro projects, providing a seamless editing experience for content creators. The integration utilizes the ApostropheCMS extension for Astro, which requires an on-demand rendered Astro project with the Node.js adapter installed and `output: 'server'` configured, as well as an ApostropheCMS project with a configured `APOS_EXTERNAL_FRONT_KEY` environment variable. The shared key enables communication between the frontend (Astro) and backend (ApostropheCMS) through the `APOS_EXTERNAL_FRONT_KEY` environment variable.",
      "url": "/en/guides/cms/apostrophecms/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "apostrophecms",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/backend/appwriteio",
      "language": "en",
      "title": "Appwrite & Astro",
      "summary": "Appwrite & Astro integrates a self-hosted backend-as-a-service platform with Astro components, providing authentication and account management, user preferences, database and storage persistence, cloud functions, localization, image manipulation, and other server-side utilities through APIs such as `appwrite.client()` and `appwrite.storage()`. Key features include support for Astro's `getStaticPaths` and `Astro.props` methods, enabling seamless integration with Astro's server-side rendering capabilities. This integration is suitable for use cases requiring server-side rendering, authentication, and data persistence in Astro applications.",
      "url": "/en/guides/backend/appwriteio/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "backend",
        "appwrite",
        "astro"
      ],
      "type": "backend"
    },
    {
      "id": "reference/adapter-reference",
      "language": "en",
      "title": "Astro Adapter API",
      "summary": "**Astro Adapter API** Astro adapters are integrations that provide an entrypoint for server rendering at request time, implementing host-specific APIs for handling requests and configuring the build according to host conventions. **Key Features and APIs** * `setAdapter` API in the `astro:config:done` hook * `AstroAdapter` interface with properties: + `name`: string + `serverEntrypoint`: string + `previewEntrypoint`: string + `exports`: string[] + `args`: any + `adapterFeatures`: `AstroAdapterFeatures` + `supportedAstroFeatures`: `AstroAdapterFeatureMap` * `AstroAdapterFeatures` interface with properties: + `edgeMiddleware`: boolean + `buildOutput`: 'static' | 'server' **Implementation and Use Cases** Adapters can be built as integrations and must call the `setAdapter` API to configure the build and provide an entrypoint for server rendering.",
      "url": "/en/reference/adapter-reference/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "astro",
        "adapter"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/cant-render-page",
      "language": "en",
      "title": "Astro cant render the route.",
      "summary": "**Astro Route Rendering Failure** Astro components fail to render routes when no associated file or redirect is found, resulting in a \"CantRenderPage\" error. This error occurs due to the absence of a file or redirect associated with the route, causing Astro to be unable to find content to render. The issue can be resolved by checking for missing files or redirects, or by filing an issue if the problem persists after restarting the dev server.",
      "url": "/en/reference/errors/cant-render-page/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "astro",
        "cant",
        "render",
        "route."
      ],
      "type": "guide"
    },
    {
      "id": "reference/container-reference",
      "language": "en",
      "title": "Astro Container API (experimental)",
      "summary": "**Astro Container API (experimental)** The Astro Container API allows rendering Astro components in isolation, unlocking potential future uses such as testing `.astro` component output in `vite` environments and manually loading rendering scripts for creating containers in pages rendered on demand or other \"shell\" environments. **Key Features:** * `create()`: Creates a new instance of the container with options for streaming and loaded client renderers. * `renderToString()`: Renders an Astro component returning a string. * `renderToResponse()`: Renders an Astro component returning a `Response` object. * `experimental_AstroContainerOptions`: Type definition for container options, including `streaming` and `renderers` properties. **Implementation Details:** * The API is experimental and subject to breaking changes, even in minor or patch releases. * Consult the Astro CHANGELOG for changes as they occur. * Use the `create()` method to create a new container instance with specified options. * Use `renderToString()` or `renderToResponse()` to render Astro components.",
      "url": "/en/reference/container-reference/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "astro",
        "container",
        "(experimental)"
      ],
      "type": "guide"
    },
    {
      "id": "reference/content-loader-reference",
      "language": "en",
      "title": "Astro Content Loader API",
      "summary": "Here is the technical documentation summary: **Astro Content Loader API** The Astro Content Loader API allows you to load data from any source, local or remote, and interact with Astro's content layer to manage content collections. Key features include built-in loaders (`glob()` and `file()`), custom loader creation, and support for internationalization. The API provides a `glob()` loader for creating entries from directories of files, accepting options such as `pattern`, `base`, and `generateId`.",
      "url": "/en/reference/content-loader-reference/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "astro",
        "loader"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/failed-to-find-page-map-ssr",
      "language": "en",
      "title": "Astro couldnt find the correct page to render",
      "summary": "**Astro Error Handling: FailedToFindPageMapSSR** Astro components fail to render due to incorrect page mapping for Server-Side Rendering (SSR) usage, resulting in an internal error. This occurs when Astro cannot find the correct page to render, likely due to missing or incorrect `getStaticPaths` or `Astro.props` configuration. Implementation details involve checking `getStaticPaths` method and `Astro.props` object for correct page mapping and SSR configuration.",
      "url": "/en/reference/errors/failed-to-find-page-map-ssr/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "astro",
        "couldnt",
        "find",
        "correct"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/rewrite-encountered-an-error",
      "language": "en",
      "title": "Astro couldnt find the route to rewrite, or if was found but it emitted an error during the rendering phase.",
      "summary": "**Astro Error Handling: RewriteEncounteredAnError** Astro components are unable to rewrite routes that do not exist or emit errors during rendering. This error is triggered by the `RewriteEncounteredAnError` event, which provides information about the non-existent route or rendering error, including the `STACK` property. The `RewriteEncounteredAnError` event is deprecated in Astro and cannot be emitted by the framework anymore.",
      "url": "/en/reference/errors/rewrite-encountered-an-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "astro",
        "couldnt",
        "find",
        "route"
      ],
      "type": "guide"
    },
    {
      "id": "astro-courses",
      "language": "en",
      "title": "Astro Courses",
      "summary": "Astro Courses are a collection of educational resources for learning Astro, including official tutorials, recommended courses, and community learning materials. Key features include: * Integration with Astro's affiliate links for discounts with education partners * Support for internationalization * Use of Astro components, such as `LinkCard` and `CardGrid`, from `@astrojs/starlight/components` * APIs and methods, including `href` and `description` properties for `LinkCard` components Implementation details include: * Use of Astro's built-in tooling and features * Integration with external learning platforms, such as Scrimba and Coding in Public * Community-driven resources, including guides, articles, and blog posts Use cases include: * Learning Astro basics with official tutorials and recommended courses * Exploring community learning resources and guides * Using Astro's affiliate links for discounts with education partners",
      "url": "/en/astro-courses/",
      "keywords": [
        "content",
        "docs",
        "astro",
        "courses"
      ],
      "type": "guide"
    },
    {
      "id": "guides/astro-db",
      "language": "en",
      "title": "Astro DB",
      "summary": "**Astro DB is a fully-managed SQL database designed exclusively for Astro, providing a complete solution for configuring, developing, and querying data.** **Key Features:** * **Local Database**: A local database is created in `.astro/content.db` when running `astro dev`, allowing data management without Docker or network connection. * **Table Definition**: Define tables in `db/config.ts` using `defineDb` and `defineTable` utilities, enabling TypeScript support with property autocompletion and type-checking. * **Integration**: Install `@astrojs/db` using `astro add` command, automatically creating a `db/config.ts` file for database configuration. **Implementation Details:** * **Database Configuration**: Define database tables in `db/config.ts` using `defineDb` and `defineTable` utilities. * **Table Structure**: Use `column` utility to enforce data types for each row value. * **TypeScript Support**: Generate a TypeScript interface for querying tables, enabling property autocompletion and type-checking. **Use Cases:** * **Local Development**: Use Astro DB for local development, eliminating the need for Docker or network connection. * **Data Management**: Configure and query data using a fully-managed SQL database designed exclusively for Astro.",
      "url": "/en/guides/astro-db/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "astro"
      ],
      "type": "guide"
    },
    {
      "id": "reference/integrations-reference",
      "language": "en",
      "title": "Astro Integration API",
      "summary": "**Astro Integrations** add new functionality and behaviors for your project with only a few lines of code, utilizing the Astro Integration API to extend Astro's capabilities. **Key Features and APIs:** * `AstroIntegration` interface with `name` and `hooks` properties * `hooks` object with methods: + `astro:config:setup`: config setup hook with options for `config`, `command`, `isRestart`, `updateConfig`, `addRenderer`, `addWatchFile`, `addClientDirective`, `addMiddleware`, `addDevToolbarApp`, `injectScript`, `injectRoute`, and `createCodegenDir` + `astro:route:setup`: route setup hook with options for `route` and `logger` + `astro:routes:resolved`: routes resolved hook with options for `routes` and `logger` * Implementation details and use cases include integrating renderers (e.g., Svelte, React), libraries (e.g., Partytown), and features (e.g., Sitemap) into Astro projects. **Technical Keywords:** Astro Integration API, Astro Integrations, Astro Components, Svelte, React, Preact, Vue, Solid, Partytown, Sitemap.",
      "url": "/en/reference/integrations-reference/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "astro",
        "integration"
      ],
      "type": "guide"
    },
    {
      "id": "recipes/index",
      "language": "en",
      "title": "Astro recipes",
      "summary": "Astro recipes are short, focused how-to guides that provide step-by-step instructions for adding new features or behavior to an Astro project. Key features include official recipes, community resources, and guided examples, utilizing Astro components such as RecipesNav and ReadMore. The Astro recipes API includes Astro.props and other implementation details, making it a valuable resource for developers looking to enhance their Astro projects.",
      "url": "/en/recipes/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "astro"
      ],
      "type": "guide"
    },
    {
      "id": "reference/api-reference",
      "language": "en",
      "title": "Astro render context",
      "summary": "Astro render context provides a runtime API specific to the current render, including the current page URL and APIs for actions like redirecting to another page. The `Astro` global object is available in `.astro` components, and its properties mirror the Astro global properties. The `context` object, passed to endpoint functions and middleware, contains properties like `props`, `redirect()`, and others, allowing for dynamic rendering and behavior injection.",
      "url": "/en/reference/api-reference/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "astro",
        "render",
        "context"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/prerender-client-address-not-available",
      "language": "en",
      "title": "Astro.clientAddress cannot be used inside prerendered routes.",
      "summary": "Astro.clientAddress cannot be used inside prerendered routes due to limitations in accessing client-side information during server-side rendering. This is because Astro.clientAddress relies on client-side APIs that are not available during prerendering. To work around this, consider using on-demand rendering or alternative approaches for accessing client-side information.",
      "url": "/en/reference/errors/prerender-client-address-not-available/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "astro.clientaddress",
        "cannot",
        "used",
        "inside"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/client-address-not-available",
      "language": "en",
      "title": "Astro.clientAddress is not available in current adapter.",
      "summary": "Astro.clientAddress is a property that provides the client's address, but it is not available in the current adapter, requiring a file an issue with the adapter to add support. The adapter's limitation prevents access to Astro.clientAddress, necessitating alternative solutions. To resolve this, refer to official integrations and the Astro.clientAddress API reference for further assistance.",
      "url": "/en/reference/errors/client-address-not-available/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "astro.clientaddress",
        "available",
        "current",
        "adapter."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/static-client-address-not-available",
      "language": "en",
      "title": "Astro.clientAddress is not available in prerendered pages.",
      "summary": "Astro.clientAddress is only available on server-rendered pages, not in prerendered pages. The Astro.clientAddress property is only accessible when server-side rendering is enabled. To obtain the user's IP address in static mode, use APIs like Ipify in a client-side script or a serverless function hosted on your provider.",
      "url": "/en/reference/errors/static-client-address-not-available/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "astro.clientaddress",
        "available",
        "prerendered",
        "pages."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/astro-glob-no-match",
      "language": "en",
      "title": "Astro.glob() did not match any files.",
      "summary": "**Astro.glob() is a utility function for globbing files in Astro applications.** It returns an array of matching files based on a provided glob pattern, and can be used to dynamically import components or assets. The `Astro.glob()` function takes a string argument, `GLOB_STR`, which is a glob pattern that specifies the files to match. If no files match the glob pattern, it returns an empty array, indicating that `Astro.glob(GLOB_STR)` did not return any matching files.",
      "url": "/en/reference/errors/astro-glob-no-match/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "astro.glob()",
        "match",
        "files."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/astro-glob-used-outside",
      "language": "en",
      "title": "Astro.glob() used outside of an Astro file.",
      "summary": "Astro.glob() is a function used for importing multiple files at once, but it can only be used within Astro files (.astro). To achieve a similar result outside of Astro files, use import.meta.glob() instead. This function allows importing multiple files using a glob pattern, similar to Astro.glob().",
      "url": "/en/reference/errors/astro-glob-used-outside/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "astro.glob()",
        "used",
        "outside",
        "astro"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/locals-not-serializable",
      "language": "en",
      "title": "Astro.locals is not serializable",
      "summary": "**Astro.locals is not serializable** Astro.locals is a feature that allows storing data in the context of an Astro page, but it throws a LocalsNotSerializable error when attempting to store non-serializable data. This error occurs when a user tries to store a function, object with a function property, or other non-serializable data in Astro.locals. The error can be resolved by ensuring that only serializable data is stored in Astro.locals, such as strings, numbers, booleans, and objects with only serializable properties.",
      "url": "/en/reference/errors/locals-not-serializable/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "astro.locals",
        "serializable"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/static-redirect-not-available",
      "language": "en",
      "title": "Astro.redirect is not available in static mode.",
      "summary": "**Astro.redirect is only available in server-side rendering (SSR) mode.** Astro.redirect is a function that enables client-side redirects, but it is not available when using static mode. Instead, use the meta refresh attribute or host-based redirects (e.g., Netlify redirects) to achieve similar functionality. To use Astro.redirect, enable SSR in your Astro config by setting `output` to `'server'` or `'hybrid'`.",
      "url": "/en/reference/errors/static-redirect-not-available/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "astro.redirect",
        "available",
        "static",
        "mode."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/astro-response-headers-reassigned",
      "language": "en",
      "title": "Astro.response.headers must not be reassigned.",
      "summary": "Astro components are restricted from reassigning the `Astro.response.headers` object, which can be modified by adding or removing individual headers, but not replaced with a new instance of `Headers`. This restriction is enforced to prevent unintended changes to the response headers. The `AstroResponseHeadersReassigned` error is thrown when attempting to set a new value as the `headers` field on the `ResponseInit` object.",
      "url": "/en/reference/errors/astro-response-headers-reassigned/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "astro.response.headers",
        "must",
        "reassigned."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/render-undefined-entry-error",
      "language": "en",
      "title": "Attempted to render an undefined content collection entry.",
      "summary": "**Astro components are designed to render content collection entries, but may fail if an entry is undefined.** **Key features and APIs:** * `Astro.props` is used to access component properties * `getStaticPaths` is not directly related to this issue, but is a relevant Astro API * Rendering undefined content collection entries can occur due to missing or non-existent entries **Implementation details and use cases:** * Rendering undefined content collection entries can be resolved by checking for existence before rendering * Use `Astro.props` to access component properties and ensure they are defined before rendering * This issue can occur in various use cases, including dynamic routing and content rendering.",
      "url": "/en/reference/errors/render-undefined-entry-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "attempted",
        "render",
        "undefined",
        "collection"
      ],
      "type": "guide"
    },
    {
      "id": "guides/authentication",
      "language": "en",
      "title": "Authentication",
      "summary": "**Authentication in Astro** Authentication and authorization manage access to websites or apps, verifying identity and granting access to protected areas and resources. Astro does not have an official authentication solution, but community integrations, such as `auth-astro`, provide utilities for multiple authentication methods. These integrations can be installed using `astro add` or manually installed via npm or yarn. **Key Features and APIs** * `auth-astro` integration for Astro * Supports multiple authentication methods (e.g., email sign-in, OAuth providers) * `astro add` command for installation * Manual installation via npm or yarn **Implementation Details and Use Cases** * Use `auth-astro` to add authentication to Astro projects * Integrate with backend services (e.g., Supabase, Firebase) for authentication * Customize areas of the site for logged-in individuals **Technical Keywords** * Authentication * Authorization * Astro * `auth-astro` * Community integrations * Backend services (e.g., Supabase, Firebase)",
      "url": "/en/guides/authentication/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "authentication"
      ],
      "type": "guide"
    },
    {
      "id": "tutorial/6-islands/2",
      "language": "en",
      "title": "Back on dry land. Take your blog from day to night, no island required!",
      "summary": "**Astro components are used to build interactive elements, including theme toggles, using vanilla JavaScript and CSS.** **Key features and APIs:** * `button` element with `id` attribute for theme toggle * `svg` element with `width` and `viewBox` attributes for icon rendering * `path` elements with `class` attributes for sun and moon icon rendering * JavaScript code for interactivity, sent to the browser without framework JavaScript **Implementation details and use cases:** * Create a new file at `src/components/ThemeIcon.astro` and paste the code into it * Use Astro's component syntax to define the theme toggle icon * Use vanilla JavaScript and CSS to add interactivity to the theme toggle icon * Use the `button` element to toggle between light and dark mode",
      "url": "/en/tutorial/6-islands/2/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "6 islands",
        "back",
        "land.",
        "take",
        "your"
      ],
      "type": "tutorial"
    },
    {
      "id": "recipes/build-custom-img-component",
      "language": "en",
      "title": "Build a custom image component",
      "summary": "**Astro components are used to display and optimize images, with built-in components like `` and `` supporting responsive images and image optimization.** **Key features and APIs include:** * `getImage()` function for generating custom images * `` and `` components for displaying and optimizing images * `Astro.props` for passing props to custom components * `ImageMetadata` type for typing image metadata **Implementation details and use cases include:** * Creating a custom image component using `getImage()` function * Passing props to custom component using `Astro.props` * Using media queries to display different source images * Optimizing images using `` component **Technical keywords:** Astro, image optimization, responsive images, media queries, custom components, `getImage()` function, `Astro.props`, `ImageMetadata` type.",
      "url": "/en/recipes/build-custom-img-component/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "build",
        "custom",
        "image",
        "component"
      ],
      "type": "recipe"
    },
    {
      "id": "tutorial/5-astro-api/3",
      "language": "en",
      "title": "Build a tag index page",
      "summary": "Here is the technical documentation summary: **Build a tag index page** Astro components are used to create a tag index page that displays a list of all unique tags, linking to each tag page, using the `/pages/folder/index.astro` routing pattern. **Key features and APIs:** * `/pages/folder/index.astro` routing pattern * Importing and using Astro components (e.g., `Box`, `Checklist`, `MultipleChoice`) * Using Astro's `Steps` component for guided tutorials * Implementing a tag index page using a new file at `src/pages/tags/index.astro` * Using a layout component (e.g., `BaseLayout`) to structure the page **Implementation details and use cases:** * Creating a new file at `src/pages/tags/index.astro` using the `/pages/folder/index.astro` routing pattern * Importing and using a layout component to structure the page * Displaying a list of all unique tags, linking to each tag page",
      "url": "/en/tutorial/5-astro-api/3/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "5 astro api",
        "build",
        "index",
        "page"
      ],
      "type": "tutorial"
    },
    {
      "id": "recipes/build-forms-api",
      "language": "en",
      "title": "Build forms with API routes",
      "summary": "**Astro API Routes enable sending form submissions to a custom API endpoint** Astro API Routes provide a way to intercept form submissions using JavaScript, allowing form data to be sent to a custom API endpoint instead of refreshing the page. Key features include `request.formData()` for processing form data and `APIRoute` for defining API endpoints. Implementation details include creating a `POST` API endpoint at `/api/feedback` to receive form data, validating form values, and returning a success response. Use cases include integrating with UI frameworks and handling form submissions in Astro projects.",
      "url": "/en/recipes/build-forms-api/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "build",
        "forms",
        "with",
        "routes"
      ],
      "type": "recipe"
    },
    {
      "id": "recipes/build-forms",
      "language": "en",
      "title": "Build HTML forms in Astro pages",
      "summary": "**Astro components are used to build HTML forms and handle submissions in frontmatter scripts.** **Key features and APIs include:** * `` tag with input fields and submit buttons * `name` attribute for input fields to describe their values * Validation attributes (e.g., `required`, `minlength`, `type=\"email\"`) for client-side validation * Use of server adapters for on-demand rendering and handling form submissions on the server **Implementation details and use cases:** * Create an Astro page with a form and handling code in the frontmatter script * Use validation attributes to provide basic client-side validation * Use server adapters to handle form submissions on the server, sending no JavaScript to the client.",
      "url": "/en/recipes/build-forms/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "build",
        "html",
        "forms",
        "astro"
      ],
      "type": "recipe"
    },
    {
      "id": "tutorial/3-components/3",
      "language": "en",
      "title": "Build it yourself - Header",
      "summary": "**Header Component** Astro components are used to create a responsive page navigation that adapts to multiple screen sizes. **Key Features and APIs** * Import and use existing `Navigation.astro` component inside a `` element within a `` element. * Utilize Astro's built-in `header` and `nav` elements for semantic HTML structure. * Leverage Astro's component composition to create a reusable Header component. **Implementation Details and Use Cases** * Create a new `Header.astro` component in `src/components/` and import `Navigation.astro` inside a `` element. * Update existing pages to use the new `Header` component by replacing the `Navigation` component with the `Header` component. * Use Astro's `import` and `export` syntax to manage component dependencies and reuse.",
      "url": "/en/tutorial/3-components/3/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "3 components",
        "build",
        "yourself",
        "header"
      ],
      "type": "tutorial"
    },
    {
      "id": "recipes/docker",
      "language": "en",
      "title": "Build your Astro site with Docker",
      "summary": "**Build your Astro site with Docker** Astro components are containerized using Docker to build, deploy, and run applications using containers. This implementation uses Dockerfiles to define the build process, with specific features including `FROM node:lts AS runtime`, `WORKDIR /app`, `COPY . .`, `RUN npm install`, `RUN npm run build`, `ENV HOST=0.0.0.0`, `ENV PORT=4321`, `EXPOSE 4321`, and `CMD node ./dist/server/entry.mjs`. Use cases include deploying to various platforms such as AWS, Azure, and Google Cloud.",
      "url": "/en/recipes/docker/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "build",
        "your",
        "astro",
        "site"
      ],
      "type": "recipe"
    },
    {
      "id": "tutorial/0-introduction/index",
      "language": "en",
      "title": "Build your first Astro Blog",
      "summary": "Astro components are used to build a fully-functioning blog from scratch, utilizing features such as Astro.props, getStaticPaths, and Astro components like Checklist, Box, and Lede. Implementation details include setting up a development environment, creating pages and blog posts, querying local files, and adding interactivity to the site. This tutorial showcases Astro's capabilities for building dynamic and interactive web applications.",
      "url": "/en/tutorial/0-introduction/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "0 introduction",
        "build",
        "your",
        "first",
        "astro"
      ],
      "type": "tutorial"
    },
    {
      "id": "tutorial/6-islands/1",
      "language": "en",
      "title": "Build your first Astro island",
      "summary": "**Astro Island Components are a set of reusable, interactive components that can be embedded in Astro pages, enabling developers to create dynamic and engaging user experiences.** **Key Features and APIs:** * `client:` directives for making islands interactive * Support for Preact components through `npx astro add preact` command * `useState` hook from Preact for managing component state * `Steps` component for guiding users through a series of instructions * `PackageManagerTabs` component for displaying package manager-specific instructions **Implementation Details and Use Cases:** * Create a new Preact component in a `.jsx` file, such as `Greeting.jsx`, and use the `useState` hook to manage component state * Use the `client:` directive to make the island interactive, such as by responding to button clicks * Embed the Preact component in an Astro page using the `client:` directive * Use the `Steps` component to guide users through a series of instructions, such as adding a package to the project * Use the `PackageManagerTabs` component to display package manager-specific instructions, such as for npm, pnpm, or yarn.",
      "url": "/en/tutorial/6-islands/1/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "6 islands",
        "build",
        "your",
        "first",
        "astro"
      ],
      "type": "tutorial"
    },
    {
      "id": "tutorial/4-layouts/1",
      "language": "en",
      "title": "Build your first layout",
      "summary": "**Astro Layout Components are reusable templates for structuring page content** Astro layout components provide a way to create shared page layouts using Astro's `` element, allowing developers to refactor common elements and pass page-specific values as props. Key features include the ability to use Astro's `getStaticPaths` API to pre-render pages and leverage Astro's `Astro.props` API to access page metadata. Implementation details involve creating a new layout component file, importing necessary components, and using Astro's template syntax to define the layout structure.",
      "url": "/en/tutorial/4-layouts/1/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "4 layouts",
        "build",
        "your",
        "first",
        "layout"
      ],
      "type": "tutorial"
    },
    {
      "id": "guides/cms/builderio",
      "language": "en",
      "title": "Builder.io & Astro",
      "summary": "**Builder.io & Astro Integration** Builder.io components are integrated with Astro to enable visual CMS content editing for building websites with zero client-side JavaScript. **Key Features and APIs:** * `BUILDER_API_PUBLIC_KEY` and `BUILDER_BLOGPOST_MODEL` environment variables for API key and model name configuration * `ImportMetaEnv` interface for IntelliSense support in `env.d.ts` file * `FileTree` and `Steps` components from `@astrojs/starlight/components` for project structure visualization **Implementation Details and Use Cases:** * Create a `.env` file in the project root with `BUILDER_API_PUBLIC_KEY` and `BUILDER_BLOGPOST_MODEL` variables * Configure `ImportMetaEnv` interface in `env.d.ts` file for IntelliSense support * Use Builder.io's visual CMS to edit content for Astro projects with zero client-side JavaScript.",
      "url": "/en/guides/cms/builderio/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "builder.io",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/build-with-ai",
      "language": "en",
      "title": "Building Astro sites with AI tools",
      "summary": "**Building Astro sites with AI tools** Astro components are designed to be integrated with AI-powered editors and agentic coding tools, leveraging Astro's core APIs and concepts to enhance AI assistance. Key features include access to Astro Docs MCP Server for real-time documentation and the use of `llms.txt` and `llms-full.txt` files for optimized AI consumption. The Astro Docs MCP Server provides a standardized way for AI tools to access the latest documentation, ensuring current best practices and avoiding outdated recommendations.",
      "url": "/en/guides/build-with-ai/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "building",
        "astro",
        "sites",
        "with",
        "tools"
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/buttercms",
      "language": "en",
      "title": "ButterCMS & Astro",
      "summary": "Astro components are integrated with ButterCMS to fetch and display structured content in Astro projects. Key features include using the ButterCMS SDK, importing the `butterClient` instance, and accessing content through APIs such as `butterClient.post.retrieve()`. Implementation details involve setting up a `.env` file with the API token, installing the ButterCMS SDK, and creating a `buttercms.js` file to initialize the client. Use cases include building headless CMS and blog engine integrations, leveraging internationalization support, and utilizing Astro's component-based architecture.",
      "url": "/en/guides/cms/buttercms/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "buttercms",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/cms/caisy",
      "language": "en",
      "title": "Caisy & Astro",
      "summary": "**Caisy & Astro Integration** Caisy & Astro components are used to fetch and display content from a headless CMS using GraphQL API. **Key Features:** * Utilize `graphql-request` and Caisy's rich text renderer for Astro to fetch CMS data and display content on an Astro page. * Implement GraphQL queries using `gql` and `GraphQLClient` to fetch data from Caisy's API. * Use `RichTextRenderer` to render rich text content from Caisy's API. * Leverage Caisy's features such as pagination, filtering, and localization to query and display content. **Implementation Details:** * Use `GraphQLClient` to establish a connection to Caisy's API with API key and project ID. * Use `gql` to define GraphQL queries to fetch data from Caisy's API. * Use `RichTextRenderer` to render rich text content from Caisy's API. * Utilize Caisy's features such as pagination, filtering, and localization to query and display content. **Use Cases:** * Fetch and display blog articles from Caisy's API on an Astro page. * Use pagination to query large numbers of documents from Caisy's API. * Use filtering and ordering to query and display specific content from Caisy's API.",
      "url": "/en/guides/cms/caisy/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "caisy",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "recipes/call-endpoints",
      "language": "en",
      "title": "Call endpoints from the server",
      "summary": "Astro components are capable of calling server endpoints to fetch data, enabling server-side rendering and API-driven content. Key features include the `APIRoute` type, `GET` method, and `Astro` global object, which provide a simple and efficient way to interact with server endpoints. Implementation details involve creating an endpoint file with a `GET` method that returns a `Response` object, and then importing and calling this method from an Astro page component using the `await` keyword and `json()` method to parse the response data.",
      "url": "/en/recipes/call-endpoints/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "call",
        "endpoints",
        "from",
        "server"
      ],
      "type": "recipe"
    },
    {
      "id": "reference/errors/cannot-determine-weight-and-style-from-font-file",
      "language": "en",
      "title": "Cannot determine weight and style from font file.",
      "summary": "**Font File Weight and Style Determination Failure** Font files cannot determine weight and style automatically, requiring manual configuration of `weight` and `style` in the family config. Use `Astro.props` to set these properties explicitly. Implement `font-family` config with `weight` and `style` properties to resolve the issue.",
      "url": "/en/reference/errors/cannot-determine-weight-and-style-from-font-file/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "cannot",
        "determine",
        "weight",
        "style"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/cannot-extract-font-type",
      "language": "en",
      "title": "Cannot extract the font type from the given URL.",
      "summary": "**Font Type Extraction Error** Cannot extract the font type from the given URL due to an error in font type resolution. This issue occurs when the `font-type` attribute is not properly set or is missing from the font URL. The error is triggered by the `font-type` extraction mechanism, which fails to resolve the font type from the provided URL.",
      "url": "/en/reference/errors/cannot-extract-font-type/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "cannot",
        "extract",
        "font",
        "type"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/cannot-fetch-font-file",
      "language": "en",
      "title": "Cannot fetch the given font file.",
      "summary": "**Font File Fetching Error** Cannot fetch the given font file due to an error in font file URL fetching. This issue is caused by a failure to retrieve the font file from the specified URL, resulting in a critical error. The error is typically resolved by verifying the font file URL and ensuring it is correctly formatted and accessible.",
      "url": "/en/reference/errors/cannot-fetch-font-file/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "cannot",
        "fetch",
        "given",
        "font"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/cannot-load-font-provider",
      "language": "en",
      "title": "Cannot load font provider",
      "summary": "**Astro Font Provider Loading Failure** Astro components are unable to load font providers due to a critical error, resulting in a \"Cannot load font provider\" message. This issue occurs when Astro is unable to load a font provider, requiring manual intervention to resolve. The error is typically resolved by opening an issue on the corresponding provider's repository, utilizing APIs such as `Astro.props` to troubleshoot and debug the issue.",
      "url": "/en/reference/errors/cannot-load-font-provider/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "cannot",
        "load",
        "font",
        "provider"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/incompatible-descriptor-options",
      "language": "en",
      "title": "Cannot set both densities and widths",
      "summary": "**Image Descriptor Options:** Cannot set both densities and widths. Only one of `densities` or `widths` can be specified, as they are used to construct a `srcset` attribute with mutually exclusive `x` and `w` descriptors. Use `widths` for specific widths if required.",
      "url": "/en/reference/errors/incompatible-descriptor-options/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "cannot",
        "both",
        "densities",
        "widths"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/rewrite-with-body-used",
      "language": "en",
      "title": "Cannot use Astro.rewrite after the request body has been read",
      "summary": "Astro components are designed to handle server-side rendering and routing, featuring APIs such as Astro.rewrite and Astro.props, with methods like getStaticPaths for static site generation. Astro.rewrite() cannot be used if the request body has already been read, requiring a request clone using Request.clone() to read the body before rewriting the request. This is a critical implementation detail for Astro developers working with request bodies and routing.",
      "url": "/en/reference/errors/rewrite-with-body-used/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "cannot",
        "astro.rewrite",
        "after",
        "request"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/no-adapter-installed-server-islands",
      "language": "en",
      "title": "Cannot use Server Islands without an adapter.",
      "summary": "**Server Islands Require Adapter** Server islands in Astro components cannot be used without a configured adapter, which is necessary for server-side rendering. This limitation applies to server islands, requiring an adapter for proper functionality. To resolve, install and configure the appropriate server adapter for your deployment.",
      "url": "/en/reference/errors/no-adapter-installed-server-islands/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "cannot",
        "server",
        "islands",
        "without"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/no-adapter-installed",
      "language": "en",
      "title": "Cannot use Server-side Rendering without an adapter.",
      "summary": "**Server-side Rendering in Astro** Astro components are rendered on the server using an adapter, which is required for generating output on the targeted deployment platform. The `NoAdapterInstalled` error occurs when attempting to use server-side rendering without an adapter installed, preventing Astro from generating the proper output. To resolve this, install and configure the appropriate server adapter for your final deployment.",
      "url": "/en/reference/errors/no-adapter-installed/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "cannot",
        "server-side",
        "rendering",
        "without"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/cant-use-astro-config-module-error",
      "language": "en",
      "title": "Cannot use the astro:config module without enabling the experimental feature.",
      "summary": "**Astro components are unable to use the astro:config module without enabling the experimental feature.** **Key features and APIs:** * `experimental.serializeConfig` flag in `astro.config.mjs` * `astro:config` module import error * `CantUseAstroConfigModuleError` error type **Implementation details and use cases:** * Enable `experimental.serializeConfig` to use `astro:config` module * Upgrade to a recent Astro version to resolve deprecated error * Consult unmaintained documentation snapshots for older versions",
      "url": "/en/reference/errors/cant-use-astro-config-module-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "cannot",
        "astro:config",
        "module",
        "without"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/actions-cant-be-loaded",
      "language": "en",
      "title": "Cant load the Astro actions.",
      "summary": "**Astro actions loading failure** Astro actions loading failure occurs when the Astro actions file cannot be loaded, resulting in a Thrown error in development mode. This issue is typically caused by a missing or incorrectly configured actions file, which can be resolved by verifying the file's existence and syntax. The `ActionsCantBeLoaded` error is thrown when the Astro actions file fails to load, preventing the application from proceeding.",
      "url": "/en/reference/errors/actions-cant-be-loaded/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "cant",
        "load",
        "astro",
        "actions."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/middleware-cant-be-loaded",
      "language": "en",
      "title": "Cant load the middleware.",
      "summary": "**Astro middleware loading error handling** Astro middleware loading error handling is triggered when an error occurs while loading middleware in development mode. The `MiddlewareCantBeLoaded` error is thrown when middleware throws an error while attempting to load it. This can be demonstrated by intentionally throwing an error in the middleware code, such as `throw new Error(\"Error thrown while loading the middleware.\")` in the `onRequest` function defined by `defineMiddleware`.",
      "url": "/en/reference/errors/middleware-cant-be-loaded/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "cant",
        "load",
        "middleware."
      ],
      "type": "guide"
    },
    {
      "id": "tutorial/1-setup/index",
      "language": "en",
      "title": "Check in: Unit 1 - Setup",
      "summary": "Here is the technical documentation summary: **Setup and Deployment** Astro components are used to set up development environments and deploy to Netlify. Key features include importing Astro components (`Checklist`, `Box`), using the `Steps` component from `@astrojs/starlight/components`, and implementing deployment to Netlify. Implementation details include using online code editors like Google IDX, setting up IDX projects, and creating GitHub repositories.",
      "url": "/en/tutorial/1-setup/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "1 setup",
        "check",
        "unit",
        "setup"
      ],
      "type": "tutorial"
    },
    {
      "id": "tutorial/2-pages/index",
      "language": "en",
      "title": "Check in: Unit 2 - Pages",
      "summary": "Astro components are used to create dynamic pages and posts with Markdown files, leveraging the `.astro` syntax and two sections: frontmatter and HTML content. Key features include: * Creating Astro pages with `.astro` syntax * Adding blog posts with Markdown (.md) files * Styling individual pages with `` tags * Applying global styles across pages using variables and conditional rendering Implementation details involve using Astro.props, getStaticPaths, and Astro components such as Checklist and Box to structure and render content.",
      "url": "/en/tutorial/2-pages/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "2 pages",
        "check",
        "unit",
        "pages"
      ],
      "type": "tutorial"
    },
    {
      "id": "tutorial/3-components/index",
      "language": "en",
      "title": "Check in: Unit 3 - Components",
      "summary": "**Astro components are reusable HTML fragments that enable code reuse across a website, allowing developers to build and manage smaller, modular pieces of UI.** **Key features and APIs include:** * Importing and using Astro components (e.g., `Box`, `Checklist`, `MultipleChoice`, `Option`) * Creating custom Astro components using `.astro` files * Utilizing Astro's built-in features, such as CSS and JavaScript integration, for responsive design and user interaction **Implementation details and use cases:** * Building reusable components for common UI elements, such as navigation, footers, and social media links * Creating interactive components, like hamburger menus, that respond to user input and screen sizes * Integrating components with existing Astro pages and Markdown files for seamless content management",
      "url": "/en/tutorial/3-components/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "3 components",
        "check",
        "unit",
        "components"
      ],
      "type": "tutorial"
    },
    {
      "id": "tutorial/4-layouts/index",
      "language": "en",
      "title": "Check in: Unit 4 - Layouts",
      "summary": "**Layout Components are reusable Astro components that enable sharing common elements and styles across pages and blog posts.** **Key Features:** * Create reusable layout components using Astro's component system * Pass content to layouts using `` elements * Pass data from Markdown frontmatter to layouts using Astro.props * Nest multiple layouts for complex page structures **Implementation Details:** * Use Astro's component syntax to define layout components * Utilize `` elements to inject content into layouts * Leverage Astro.props to access Markdown frontmatter data in layouts **Use Cases:** * Create a reusable header component with navigation links * Build a custom blog post layout with a featured image and author information * Nest a layout component within another layout for a complex page structure",
      "url": "/en/tutorial/4-layouts/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "4 layouts",
        "check",
        "unit",
        "layouts"
      ],
      "type": "tutorial"
    },
    {
      "id": "tutorial/5-astro-api/index",
      "language": "en",
      "title": "Check in: Unit 5 - Astro API",
      "summary": "Astro API enables developers to work with files in their project using `import.meta.glob()` and access data from files, create multiple pages (routes) at once using `getStaticPaths()`, and generate an RSS feed using the Astro RSS package. This API provides a robust framework for building dynamic and data-driven applications, with features such as static site generation and server-side rendering. By leveraging Astro's API, developers can create scalable and maintainable applications with ease.",
      "url": "/en/tutorial/5-astro-api/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "5 astro api",
        "check",
        "unit",
        "astro"
      ],
      "type": "tutorial"
    },
    {
      "id": "tutorial/6-islands/index",
      "language": "en",
      "title": "Check in: Unit 6 - Astro Islands",
      "summary": "Astro islands are a feature that enables the integration of frontend framework components into Astro sites, allowing for interactive elements and UI frameworks like Preact to be used within Astro projects. Key features and APIs include importing and using Astro components (e.g., `Box`, `Checklist`, `MultipleChoice`, `Option`), utilizing Preact to create interactive components (e.g., greeting component), and leveraging methods such as `getStaticPaths` and `Astro.props` to manage island functionality. Implementation details and use cases involve adding a UI framework (Preact) to an Astro project, creating interactive components, and determining when to use islands for interactivity, with potential applications in building dynamic and engaging Astro sites.",
      "url": "/en/tutorial/6-islands/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "6 islands",
        "check",
        "unit",
        "astro",
        "islands"
      ],
      "type": "tutorial"
    },
    {
      "id": "reference/cli-reference",
      "language": "en",
      "title": "CLI Commands",
      "summary": "**CLI Commands** The Astro CLI provides a set of commands for developing, building, and previewing projects from a terminal window. Key features include: * `astro dev` command to start the development server with live preview * `astro --help` command to display a list of available commands * Support for package managers (npm, pnpm, yarn) with customizable flags Implementation details include: * Using `npx`, `pnpm`, or `yarn` to execute commands * Customizable flags for command behavior * Integration with package managers for seamless execution Use cases include: * Development and testing of Astro projects * Building and deploying Astro projects to production * Generating TypeScript types for Astro modules",
      "url": "/en/reference/cli-reference/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "commands"
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/cloudcannon",
      "language": "en",
      "title": "CloudCannon & Astro",
      "summary": "CloudCannon & Astro integrates CloudCannon's Git-based headless CMS with Astro components, enabling content management and live editing of Astro projects. Key features include Astro components (e.g., `Grid`, `Card`) and APIs (e.g., `Astro.props`) for seamless integration, as well as official resources (e.g., Astro Starter Template, Astro Multilingual Starter Template) and community resources (e.g., Astro Beginner Tutorial Series) for implementation and support. This integration enables Astro developers to leverage CloudCannon's visual editor and Git-based workflow for content management and live editing.",
      "url": "/en/guides/cms/cloudcannon/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "cloudcannon",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/media/cloudinary",
      "language": "en",
      "title": "Cloudinary & Astro",
      "summary": "**Cloudinary & Astro** Cloudinary & Astro components are a set of native Astro components for image, video, and upload management, as well as a content loader for Astro content collections, leveraging Cloudinary's Transformation API for asset editing and delivery. Key features include: * `CloudinaryImage`, `CloudinaryVideo`, and `CloudinaryUpload` components for seamless integration * `getStaticPaths` and `Astro.props` API support for optimized asset delivery * Implementation details include using the Cloudinary Astro SDK, Node.js SDK, or JavaScript SDK for asset management and transformation Use cases include: * Image and video optimization with Cloudinary's Transformation API * Dynamic asset delivery and caching with Cloudinary's CDN * Integration with Astro content collections for seamless asset management",
      "url": "/en/guides/media/cloudinary/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "media",
        "cloudinary",
        "astro"
      ],
      "type": "media"
    },
    {
      "id": "reference/errors/content-collection-type-mismatch-error",
      "language": "en",
      "title": "Collection contains entries of a different type.",
      "summary": "**Collection contains entries of a different type.** Collection contains entries of an unexpected type, violating the configured type (`type: 'content'` by default). This error occurs when a legacy content collection contains entries of a different type, such as data collections (`type: 'data'`). Use `type: 'data'` in the collection config to resolve the issue. **Key features and APIs:** * `type` property in collection config * `ContentCollectionTypeMismatchError` exception * Legacy content collections * Collection type configuration **Implementation details and use cases:** * Update collection config to match entry type * Migrate legacy content collections to data collections * Ensure collection type consistency for data integrity",
      "url": "/en/reference/errors/content-collection-type-mismatch-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "collection",
        "contains",
        "entries",
        "different"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/collection-does-not-exist-error",
      "language": "en",
      "title": "Collection does not exist",
      "summary": "**Collection does not exist** Astro components handle non-existent collections by displaying a warning instead of raising an error. This behavior is achieved through the `getCollection()` API, which returns a warning when a collection with the requested name does not exist under `src/content/`. The `DontEditWarning` component is used to display the warning, and the `caution` directive is used to mark the deprecation of error handling for non-existent collections.",
      "url": "/en/reference/errors/collection-does-not-exist-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "collection",
        "does",
        "exist"
      ],
      "type": "guide"
    },
    {
      "id": "tutorial/4-layouts/3",
      "language": "en",
      "title": "Combine layouts to get the best of both worlds",
      "summary": "**Astro layouts are composable components that enable nesting of layouts to create a unified design across pages.** **Key features:** * Nesting layouts using Astro's composable component architecture * Importing and wrapping layouts using Astro's `import` and `wrap` syntax * Passing props between layouts using Astro's `props` API, such as `pageTitle` and `frontmatter` **Implementation details:** * Importing `BaseLayout.astro` in `MarkdownPostLayout.astro` and wrapping the entire template content * Passing `pageTitle` prop from `MarkdownPostLayout.astro` to `BaseLayout.astro` * Removing redundant `meta` tag in `MarkdownPostLayout.astro` as it is already included in `BaseLayout` **Use cases:** * Creating a unified design across pages by nesting layouts * Reusing layout components to reduce code duplication * Customizing layout components to fit specific page requirements",
      "url": "/en/tutorial/4-layouts/3/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "4 layouts",
        "combine",
        "layouts",
        "best",
        "both"
      ],
      "type": "tutorial"
    },
    {
      "id": "basics/astro-components",
      "language": "en",
      "title": "Components",
      "summary": "**Astro components** are HTML-only templating components with no client-side runtime, using the `.astro` file extension, and are the basic building blocks of any Astro project. They can be as small as a snippet of HTML, reusable UI elements, or entire page layouts, and don't render on the client, instead rendering to HTML at build-time or on-demand. Astro components can include JavaScript code in their frontmatter, which is stripped from the final page, and can be enhanced with client-side interactivity using standard HTML `` tags or UI Framework components.",
      "url": "/en/basics/astro-components/",
      "keywords": [
        "content",
        "docs",
        "basics",
        "components"
      ],
      "type": "guide"
    },
    {
      "id": "reference/modules/astro-config",
      "language": "en",
      "title": "Config imports API Reference",
      "summary": "**Config imports API Reference** The `astro:config` module exposes a non-exhaustive, serializable, type-safe version of the Astro configuration, with two submodules: `/client` and `/server`. The `/client` submodule provides access to client-side configuration values, while the `/server` submodule exposes all available config values, including sensitive file system information. **Features and APIs:** * `astro:config/client`: exposes client-side configuration values, including `i18n`, `trailingSlash`, `base`, `build.format`, and `site`. * `astro:config/server`: exposes all available config values, including sensitive file system information, such as `srcDir`, `cacheDir`, `outDir`, `publicDir`, and `root`. * `import` statements: allow importing specific configuration values or submodules. **Implementation details and use cases:** * Use `astro:config/client` for client-side code, such as utility functions or components. * Use `astro:config/server` for server-side code, such as API routes or server-side rendering. * Access sensitive file system information only on the server-side to protect client-side security.",
      "url": "/en/reference/modules/astro-config/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "modules",
        "config",
        "imports"
      ],
      "type": "guide"
    },
    {
      "id": "guides/configuring-astro",
      "language": "en",
      "title": "Configuration overview",
      "summary": "**Astro Configuration Overview** Astro is a flexible, unopinionated framework that allows configuration through various files, including the Astro config file (`astro.config.mjs`) and TypeScript config file (`tsconfig.json`). The Astro config file uses the `defineConfig()` helper to provide IntelliSense and configure build and rendering options, while the TypeScript config file enables type checking and editor tooling. Supported configuration options are documented in the Astro configuration reference.",
      "url": "/en/guides/configuring-astro/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "configuration",
        "overview"
      ],
      "type": "guide"
    },
    {
      "id": "reference/configuration-reference",
      "language": "en",
      "title": "Configuration Reference",
      "summary": "**Configuration Reference** Astro components are configured using the `defineConfig` function from `astro/config`, which exports a configuration object with top-level options. **Top-Level Options** * `site`: a string representing the final, deployed URL (Type: `string`). * `base`: a string representing the base path to deploy to (Type: `string`). **Implementation Details** * `site` is used to generate the sitemap and canonical URLs in the final build. * `base` is used as the root for pages and assets in development and production builds. * `trailingSlash` config affects the value of `import.meta.env.BASE_URL` and `config.base` when accessed by integrations.",
      "url": "/en/reference/configuration-reference/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "configuration"
      ],
      "type": "guide"
    },
    {
      "id": "reference/experimental-flags/index",
      "language": "en",
      "title": "Configuring experimental flags",
      "summary": "Astro components are configurable through experimental flags, enabling early access to new features for testing and feedback. Experimental flags are enabled in the Astro configuration file (`astro.config.mjs`) using the `experimental` object, allowing users to try out new features and participate in feature development. The `experimental` object contains a list of flags that can be enabled or disabled, with features subject to breaking changes even in small patch releases.",
      "url": "/en/reference/experimental-flags/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "experimental flags",
        "configuring",
        "experimental",
        "flags"
      ],
      "type": "guide"
    },
    {
      "id": "tutorial/6-islands/3",
      "language": "en",
      "title": "Congratulations!",
      "summary": "**Astro components are reusable UI elements for building web applications, featuring internationalization support and integration with Starlight components.** **Key features include:** * Astro.props for accessing component props * getStaticPaths for server-side rendering and SEO optimization * Integration with Starlight components, such as CardGrid and LinkCard * Customizable layout and styling through Astro components and CSS variables **Implementation details and use cases include:** * Using Astro components to build reusable UI elements for web applications * Integrating Starlight components for enhanced functionality and styling * Customizing layout and styling through Astro components and CSS variables * Leveraging Astro's internationalization support for global reach and accessibility",
      "url": "/en/tutorial/6-islands/3/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "6 islands",
        "congratulations!"
      ],
      "type": "tutorial"
    },
    {
      "id": "reference/errors/mixed-content-data-collection-error",
      "language": "en",
      "title": "Content and data cannot be in same collection.",
      "summary": "**MixedContentDataCollectionError**: Astro components cannot contain a mix of content and data entries in the same collection, violating the requirement for all entries to be of the same type. **Key Features and APIs**: * `MixedContentDataCollectionError` exception raised when a legacy content collection contains mixed content and data entries * `COLLECTION_NAME` property exposed in the error object, indicating the affected collection name * Separate collections by type to resolve the issue, as per the [Legacy content collections](/en/guides/upgrade-to/v5/#updating-existing-collections) guide. **Implementation Details and Use Cases**: * Output only the summary text, no additional information or explanations.",
      "url": "/en/reference/errors/mixed-content-data-collection-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "data",
        "cannot",
        "same",
        "collection."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/markdown-content-schema-validation-error",
      "language": "en",
      "title": "Content collection frontmatter invalid.",
      "summary": "**Content collection frontmatter validation** Content collection frontmatter validation ensures that Markdown documents in `src/content/` conform to their designated collection schema. This validation checks for required fields and correct data types, such as \"title\" and \"date\", which must be present and valid, respectively. The collection schema can be referenced in `src/content/config.*` files, and further information is available in the [Content collections documentation](/en/guides/content-collections/).",
      "url": "/en/reference/errors/markdown-content-schema-validation-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "collection",
        "frontmatter",
        "invalid."
      ],
      "type": "guide"
    },
    {
      "id": "guides/content-collections",
      "language": "en",
      "title": "Content collections",
      "summary": "**Content Collections** Content collections are a feature in Astro that enables managing sets of content in a project, providing organization, querying, and automatic TypeScript type-safety. They are defined using the Content Layer API, which was introduced in Astro v5.0, and can be used to load local or remote content using built-in loaders or custom implementations. Key features and APIs include: * Defining collections from structurally similar data * Using collection loaders for local or remote content * Support for various file formats (Markdown, MDX, Markdoc, YAML, TOML, JSON) * Automatic TypeScript type-safety and Intellisense support * Integration with the Content Layer API for querying and loading content Implementation details include: * Using the `@astrojs/starlight/components` library for UI components * Importing custom components (e.g., `Since`, `RecipeLinks`, `Badge`, `ReadMore`) * Defining collections using the `FileTree` component * Using collection loaders to fetch remote data from external sources Use cases include: * Organizing and querying blog posts or product items * Loading data from a CMS, database, or headless payment system * Implementing automatic TypeScript type-safety and Intellisense support",
      "url": "/en/guides/content-collections/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "collections"
      ],
      "type": "guide"
    },
    {
      "id": "reference/modules/astro-content",
      "language": "en",
      "title": "Content Collections API Reference",
      "summary": "**Content Collections API Reference** Content collections offer APIs to configure and query Markdown or MDX documents in `src/content/`. The `defineCollection()` function is a utility to configure a collection in a `src/content.config.*` file, accepting `loader` and `schema` properties. The `loader` property is either an object or a function that loads data from any source, local or remote, into content collections, while the `schema` property is an optional Zod object to configure the type and shape of document frontmatter for a collection. **Key Features and APIs:** * `defineCollection()`: configures a collection in a `src/content.config.*` file * `loader`: loads data from any source, local or remote, into content collections * `schema`: configures the type and shape of document frontmatter for a collection using Zod * `getCollection()`, `getEntry()`, `getEntries()`: query content collections * `reference()`: generates a reference to a content collection entry * `render()`: renders a content collection entry as HTML **Implementation Details and Use Cases:** * Define a collection in a `src/content.config.*` file using `defineCollection()` * Configure the `loader` and `schema` properties to load and shape content data * Use `getCollection()`, `getEntry()`, and `getEntries()` to query content collections * Generate references to content collection entries using `reference()` * Render content collection entries as HTML using `render()`",
      "url": "/en/reference/modules/astro-content/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "modules",
        "collections"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/content-entry-data-error",
      "language": "en",
      "title": "Content entry data does not match schema.",
      "summary": "**Content Entry Validation** Content entry data validation ensures that content entries conform to their respective collection schema. The `validateContentEntry` function checks for required fields and data types, returning an error message if the entry does not match the schema. This function can be used in conjunction with `getStaticPaths` and `Astro.props` to validate content entries at build time and runtime.",
      "url": "/en/reference/errors/content-entry-data-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "entry",
        "data",
        "does",
        "match"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/invalid-content-entry-data-error",
      "language": "en",
      "title": "Content entry data does not match schema.",
      "summary": "**Content Entry Validation** Content entry data validation ensures that content entries conform to their designated collection schema. Key features include: * Schema validation against `src/content.config.*` files * Required field checks (e.g., \"title\" is required) * Type validation (e.g., \"date\" must be a valid date) * Integration with Astro components (e.g., `DontEditWarning` component) Implementation details involve checking content entry data against the collection schema, with use cases including ensuring data consistency and preventing errors in content rendering.",
      "url": "/en/reference/errors/invalid-content-entry-data-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "entry",
        "data",
        "does",
        "match"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/invalid-content-entry-frontmatter-error",
      "language": "en",
      "title": "Content entry frontmatter does not match schema.",
      "summary": "**Content Entry Validation** Content entry frontmatter validation ensures that Markdown or MDX entries conform to their collection schema. The `validateFrontmatter` API checks for required fields and correct data types, such as `title` and `date`, against the schema defined in `src/content.config.*`. This feature is critical for maintaining data integrity and consistency across content collections.",
      "url": "/en/reference/errors/invalid-content-entry-frontmatter-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "entry",
        "frontmatter",
        "does",
        "match"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/content-loader-invalid-data-error",
      "language": "en",
      "title": "Content entry is missing an ID",
      "summary": "**Content entry is missing an ID** Astro components require content loaders to return an array of objects with unique ID fields or a plain object with IDs as keys and entries as values. Key features include: `loader` function, `id` field, and `Astro.props` API. Implementation details involve ensuring inline loaders return valid data, with use cases including content collection rendering and data fetching.",
      "url": "/en/reference/errors/content-loader-invalid-data-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "entry",
        "missing"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/content-loader-returns-invalid-id",
      "language": "en",
      "title": "Content loader returned an entry with an invalid id.",
      "summary": "**Content loader returned an entry with an invalid id.** Content loaders in Astro components return entries with a valid `id` property, which must be a string. The `id` property is used to identify and retrieve content from collections. If an invalid `id` is encountered, an error is thrown, and the content loader must be checked to ensure it returns a valid `id` string.",
      "url": "/en/reference/errors/content-loader-returns-invalid-id/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "loader",
        "returned",
        "entry",
        "with"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/content-schema-contains-slug-error",
      "language": "en",
      "title": "Content Schema should not contain slug.",
      "summary": "**Content Schema should not contain slug.** A content collection schema should not contain `slug` since it is reserved for slug generation. Remove this from your COLLECTION_NAME collection schema. This is a critical issue that can be resolved by updating the schema to exclude the `slug` field, allowing Astro to generate entry slugs instead.",
      "url": "/en/reference/errors/content-schema-contains-slug-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "schema",
        "should",
        "contain",
        "slug."
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/contentful",
      "language": "en",
      "title": "Contentful & Astro",
      "summary": "**Contentful & Astro Integration** Contentful & Astro components are used to add content to Astro projects using Contentful as a headless CMS, enabling internationalization and seamless content management. Key features include: * Integration with Contentful SDK for zero client-side JavaScript * Support for environment variables (CONTENTFUL_SPACE_ID, CONTENTFUL_DELIVERY_TOKEN, CONTENTFUL_PREVIEW_TOKEN) * Use of Astro's `getStaticPaths` and `Astro.props` APIs for content fetching and rendering Implementation details include setting up Contentful credentials in an `.env` file and using environment variables in the project. Use cases include managing content, integrating with other services, and publishing to multiple platforms.",
      "url": "/en/guides/cms/contentful/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "contentful",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "contribute",
      "language": "en",
      "title": "Contribute to Astro",
      "summary": "**Astro Contribution Framework** Astro components are designed to facilitate open-source contributions, enabling developers to contribute code, content, and ideas to the Astro project. **Key Features and APIs** * `ContributorList` component for showcasing contributors * `CONTRIBUTING.md` file for project-specific contribution guidelines * `README` files in each repository with links to `CONTRIBUTING.md` * GitHub repositories for Astro codebase, Docs, compiler, language tools, Starlight, and Roadmap * APIs for contributing code, content, and ideas through pull requests, review comments, and issue tracking **Implementation Details and Use Cases** * Contribution guidelines for each repository, including code review processes and Code of Conduct enforcement * Opportunities for contributing to Astro's documentation, including translation and accessibility improvements * Use cases for contributing code, such as implementing new features, fixing bugs, and optimizing performance * Governance documentation for detailed descriptions of roles, maintainer nomination processes, and code review processes",
      "url": "/en/contribute/",
      "keywords": [
        "content",
        "docs",
        "contribute",
        "astro"
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/cosmic",
      "language": "en",
      "title": "Cosmic & Astro",
      "summary": "**Cosmic & Astro Integration** Astro components are integrated with Cosmic, a headless CMS, to fetch and display content in Astro projects. **Key Features and APIs** * `@cosmicjs/sdk` JavaScript SDK for fetching data from Cosmic Bucket * `Astro.props` for accessing Cosmic data in Astro components * `getStaticPaths` for pre-rendering Cosmic content * `Steps` component from `@astrojs/starlight/components` for displaying Cosmic content **Implementation Details and Use Cases** * Create a `.env` file to store Cosmic API keys * Install `@cosmicjs/sdk` using npm, pnpm, or yarn * Use `Astro.props` to access Cosmic data in Astro components * Utilize `getStaticPaths` for pre-rendering Cosmic content in Astro projects",
      "url": "/en/guides/cms/cosmic/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "cosmic",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "reference/errors/missing-sharp",
      "language": "en",
      "title": "Could not find Sharp.",
      "summary": "**Astro image processing is enabled by default, relying on Sharp for image service.** **Key Features:** * Uses Sharp as default image service for `astro:assets` * Requires manual installation of Sharp with strict package managers like pnpm * Supports passthrough image service for no-processing image handling * Configurable via `defineConfig` and `passthroughImageService` API **Implementation Details:** * Use `passthroughImageService` to configure no-processing image service * Define image service configuration with `image.service` property * Install Sharp manually for image processing with strict package managers **Use Cases:** * Enable image processing with Sharp for `astro:assets` * Configure passthrough image service for no-processing image handling * Migrate to alternative image services for image processing needs",
      "url": "/en/reference/errors/missing-sharp/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "could",
        "find",
        "sharp."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/failed-to-load-module-ssr",
      "language": "en",
      "title": "Could not import file.",
      "summary": "**Astro components are unable to import files due to incorrect paths or type import issues.** **Key features and APIs:** * `FailedToLoadModuleSSR` error message * Import path validation for file existence and typo detection * Support for type imports with explicit type specification **Implementation details and use cases:** * Astro checks import paths for correctness during server-side rendering (SSR) * Type imports are supported, but require explicit type specification to avoid import errors * Common use cases include importing components, utilities, and types in Astro projects.",
      "url": "/en/reference/errors/failed-to-load-module-ssr/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "could",
        "import",
        "file."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/no-image-metadata",
      "language": "en",
      "title": "Could not process image metadata.",
      "summary": "Astro components are unable to process image metadata due to corrupted or malformed image files, often resolved by re-exporting the image from the image editor. Key features and APIs involved include Astro's image processing capabilities, which utilize methods to extract metadata from images. Implementation details involve Astro's rendering engine failing to parse image metadata, resulting in an error message indicating the issue. Use cases include troubleshooting image-related errors in Astro projects, particularly when working with corrupted or malformed image files.",
      "url": "/en/reference/errors/no-image-metadata/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "could",
        "process",
        "image",
        "metadata."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/could-not-transform-image",
      "language": "en",
      "title": "Could not transform image.",
      "summary": "**Astro Image Transformation Error** Astro components are unable to transform images due to corrupted or malformed image data. This error is often caused by issues with image re-exporting from image editors. The `CouldNotTransformImage` error message provides information on the specific image path and stack trace for debugging purposes.",
      "url": "/en/reference/errors/could-not-transform-image/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "could",
        "transform",
        "image."
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/craft-cms",
      "language": "en",
      "title": "Craft CMS & Astro",
      "summary": "**Craft CMS & Astro Integration** Craft CMS is a flexible open source CMS that can be used as a headless CMS to provide content to Astro projects, leveraging its GraphQL API and `headlessMode` config setting. Key features include: * Integrating with Astro's `getStaticPaths` and `getStaticProps` methods * Utilizing Craft CMS's GraphQL API to fetch content at build time or cache in advance * Implementing SSR with Astro and Craft CMS Implementation details and use cases include: * Using Craft CMS's `headlessMode` config setting to enable headless mode * Fetching content at build time using Astro's `getStaticPaths` and `getStaticProps` methods * Caching content in advance using Astro's caching mechanisms Technical keywords: Astro, Craft CMS, headless CMS, GraphQL API, getStaticPaths, getStaticProps, SSR, caching.",
      "url": "/en/guides/cms/craft-cms/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "craft",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "tutorial/5-astro-api/1",
      "language": "en",
      "title": "Create a blog post archive",
      "summary": "Here is the technical documentation summary: **Create a blog post archive** Astro components are used to dynamically display a list of blog posts on the Blog page, utilizing `import.meta.glob()` to access data from all Markdown files at once. **Key features and APIs:** * `import.meta.glob()` API to import Markdown files * `Object.values()` method to extract post metadata * Astro components (``, ``, ``) to generate dynamic list of posts * `pageTitle` variable to set page title dynamically **Implementation details and use cases:** * Refactor `blog.astro` to use `import.meta.glob()` and Astro components to generate dynamic list of posts * Use `eager: true` option to import Markdown files eagerly * Utilize `pageTitle` variable to set page title dynamically based on post metadata",
      "url": "/en/tutorial/5-astro-api/1/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "5 astro api",
        "create",
        "blog",
        "post",
        "archive"
      ],
      "type": "tutorial"
    },
    {
      "id": "recipes/making-toolbar-apps",
      "language": "en",
      "title": "Create a dev toolbar app",
      "summary": "**Astro components are used to create custom dev toolbar apps for site inspection and development.** **Key features and APIs include:** * `astro:config:setup` hook for integration setup * Custom app creation using `app.ts` file * Integration creation using `my-integration.ts` file * Use of Astro components, such as `PackageManagerTabs` and `FileTree` **Implementation details and use cases:** * Create a new Astro project with the `toolbar-app` template or build from scratch * Use the `astro:config:setup` hook to add the integration to the Astro project * Implement custom app logic in `app.ts` and integration logic in `my-integration.ts`",
      "url": "/en/recipes/making-toolbar-apps/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "create",
        "toolbar"
      ],
      "type": "recipe"
    },
    {
      "id": "tutorial/3-components/2",
      "language": "en",
      "title": "Create a social media footer",
      "summary": "**Create a Social Media Footer Component** Astro components are used to create a reusable Social Media footer component, which can be imported and used across multiple pages. **Key Features and APIs** * Importing and using Astro components within another component * Using Astro's built-in `Steps` component for step-by-step instructions * Creating a reusable `Footer` component with dynamic platform and username props * Using Astro's template syntax to render dynamic content * Importing and using external components from `@astrojs/starlight/components` **Implementation Details and Use Cases** * Creating a new file for the `Footer` component and defining its props * Importing and using the `Footer` component in multiple Astro pages * Customizing the footer to display multiple social networks and include a username * Using the `Steps` component to guide users through the implementation process",
      "url": "/en/tutorial/3-components/2/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "3 components",
        "create",
        "social",
        "media",
        "footer"
      ],
      "type": "tutorial"
    },
    {
      "id": "tutorial/4-layouts/2",
      "language": "en",
      "title": "Create and pass data to a custom blog layout",
      "summary": "**Create and pass data to a custom blog layout** Astro components are used to create a custom blog layout by utilizing the `layout` frontmatter property in Markdown files, which passes YAML values as props to the layout component. The `Astro.props` object is used to access the frontmatter values, and the `` element is used to render the Markdown content within the layout. The `getStaticPaths` API is not directly related to this feature, but it is used in other Astro components to handle client-side routing.",
      "url": "/en/tutorial/4-layouts/2/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "4 layouts",
        "create",
        "pass",
        "data",
        "custom"
      ],
      "type": "tutorial"
    },
    {
      "id": "tutorial/2-pages/1",
      "language": "en",
      "title": "Create your first Astro page",
      "summary": "**Create your first Astro page** Astro components are used to build web pages, and can be created by importing and rendering Astro components, such as `Checklist`, `Blanks`, `Box`, and `PreCheck`, within an Astro file. Key features include importing components using `import` statements, rendering components using Astro's templating syntax, and utilizing APIs such as `Steps` from `@astrojs/starlight/components`. Implementation details involve creating a new `.astro` file, copying and modifying content from an existing file, and editing HTML content to customize the page.",
      "url": "/en/tutorial/2-pages/1/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "2 pages",
        "create",
        "your",
        "first",
        "astro"
      ],
      "type": "tutorial"
    },
    {
      "id": "tutorial/1-setup/2",
      "language": "en",
      "title": "Create your first Astro project",
      "summary": "**Create your first Astro project** Astro components are used to create a new Astro project through the `create astro` setup wizard, which guides users through the process of setting up a new Astro site. Key features include: * `create astro` setup wizard: a command-line interface for creating new Astro projects * `npm create astro@latest`, `pnpm create astro@latest`, and `yarn create astro` commands: package manager-specific commands for creating new Astro projects * `Steps` component: a component for displaying step-by-step instructions * `PackageManagerTabs` component: a component for displaying package manager-specific tabs Implementation details include: * Running the `create astro` setup wizard to create a new Astro project * Starting the Astro server in development (dev) mode * Viewing a live preview of the website in the browser Use cases include: * Creating a new Astro project from scratch * Setting up a new Astro site using the `create astro` setup wizard * Displaying step-by-step instructions using the `Steps` component",
      "url": "/en/tutorial/1-setup/2/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "1 setup",
        "create",
        "your",
        "first",
        "astro"
      ],
      "type": "tutorial"
    },
    {
      "id": "guides/cms/crystallize",
      "language": "en",
      "title": "Crystallize & Astro",
      "summary": "Crystallize & Astro integrates a headless content management system (CMS) for eCommerce into Astro projects, exposing a GraphQL API for fetching content. Key features include: * Utilizing the Crystallize GraphQL API to fetch catalogue paths and content * Implementing the `createClient` function from `@crystallize/js-api-client` to establish a connection to the Crystallize API * Executing GraphQL queries to retrieve catalogue data, such as `getCataloguePaths` * Accessing Astro's `Astro.props` to render dynamic content * Leveraging Astro's `getStaticPaths` to pre-render pages with dynamic content Implementation details involve setting up a Crystallize API client, defining GraphQL queries, and rendering dynamic content using Astro's component architecture. Use cases include building headless eCommerce experiences, integrating with other APIs, and creating dynamic, data-driven pages.",
      "url": "/en/guides/cms/crystallize/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "crystallize",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "reference/errors/csp-not-enabled",
      "language": "en",
      "title": "CSP feature isnt enabled",
      "summary": "Astro components are affected by the absence of CSP (Content Security Policy) feature configuration. The `experimental.csp` configuration is not enabled, preventing Astro components from utilizing CSP features such as `Astro.props` and `getStaticPaths`. This limitation impacts implementation details, particularly in use cases requiring secure asset loading and path management.",
      "url": "/en/reference/errors/csp-not-enabled/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "feature",
        "isnt",
        "enabled"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/csssyntax-error",
      "language": "en",
      "title": "CSS Syntax Error.",
      "summary": "**CSS Syntax Error Handling** Astro components are designed to handle CSS syntax errors, providing informative error messages to aid in debugging. Key features include error detection for missing semicolons and unclosed strings, with APIs such as `CSSSyntaxError` and methods like `getStaticPaths` to facilitate error handling and optimization. Implementation details involve parsing CSS code to identify syntax errors, with use cases including real-time error reporting and automated code validation.",
      "url": "/en/reference/errors/csssyntax-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "syntax",
        "error."
      ],
      "type": "guide"
    },
    {
      "id": "recipes/customizing-output-filenames",
      "language": "en",
      "title": "Customize file names in the build output",
      "summary": "Astro components are customizable to change the default naming pattern for built assets like JavaScript, CSS, and images using Vite Rollup options. The `astro build` command can be configured to output built assets with custom naming patterns by modifying `vite.build.rollupOptions.output` in `astro.config.mjs`. Specifically, you can use `entryFileNames`, `chunkFileNames`, and `assetFileNames` to define custom naming patterns for JavaScript entry files, code-split chunks, and other assets, respectively. Implementation details include configuring `vite.build.rollupOptions.output` with custom naming patterns, such as `dist/js/[name]-[hash].js` for JavaScript entry files and `dist/static/[name]-[hash][extname]` for other assets.",
      "url": "/en/recipes/customizing-output-filenames/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "customize",
        "file",
        "names",
        "build"
      ],
      "type": "recipe"
    },
    {
      "id": "reference/errors/data-collection-entry-parse-error",
      "language": "en",
      "title": "Data collection entry failed to parse.",
      "summary": "**Data Collection Entry Parsing Failure** Data collection entry failed to parse due to invalid JSON, YAML, or TOML formatting in `type: 'data'` entries. This error occurs when the returned object does not conform to the expected format, causing Astro to fail parsing. The `COLLECTION_ENTRY_NAME` variable is used to identify the failed entry, and the error message indicates the specific type of entry that failed to parse.",
      "url": "/en/reference/errors/data-collection-entry-parse-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "data",
        "collection",
        "entry",
        "failed"
      ],
      "type": "guide"
    },
    {
      "id": "guides/data-fetching",
      "language": "en",
      "title": "Data fetching",
      "summary": "**Data Fetching in Astro** Astro components can fetch remote data using the global `fetch()` function in their component script, making HTTP requests to APIs using full URLs. This allows for dynamic data generation in HTML at build time, with optional runtime execution in SSR mode. Key features include top-level `await` support and passing fetched data to both Astro and framework components as props.",
      "url": "/en/guides/data-fetching/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "data",
        "fetching"
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/datocms",
      "language": "en",
      "title": "DatoCMS & Astro",
      "summary": "**DatoCMS & Astro Integration** Astro components are integrated with DatoCMS to fetch and display content data from a headless CMS in an Astro project. **Key Features and APIs** * `DATOCMS_API_KEY` environment variable for authentication * `env.d.ts` file for TypeScript support * `getStaticPaths` and `Astro.props` for dynamic content rendering * `Steps` and `FileTree` components from `@astrojs/starlight/components` for UI rendering **Implementation Details and Use Cases** * Create a `.env` file in the Astro project root with the DatoCMS API key * Declare the `DATOCMS_API_KEY` environment variable in `env.d.ts` for TypeScript support * Create a Model in DatoCMS with a text field for page title * Use `getStaticPaths` and `Astro.props` to fetch and display content data from DatoCMS in an Astro project.",
      "url": "/en/guides/cms/datocms/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "datocms",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/cms/decap-cms",
      "language": "en",
      "title": "Decap CMS & Astro",
      "summary": "**Decap CMS & Astro** Decap CMS is an open-source, Git-based content management system that integrates with Astro, allowing for image optimization and content collections. Decap adds a route to your project that loads a React app for authorized users to manage content directly from the deployed website, committing changes to your Astro project's source repository. **Key Features and APIs** * `npm install decap-cms-app` or `yarn add decap-cms-app` to install Decap via a package manager * Import Decap package into a `` tag in your page `` * Configure Decap using `config.yml` in `public/admin/` folder * Support for content collections using schema configuration in `config.yml` * Integration with Astro features, including image optimization **Implementation Details and Use Cases** Decap CMS is designed for use with Astro projects, allowing for seamless integration with content management and optimization features. Use cases include managing content directly from the deployed website, committing changes to the source repository, and configuring content collections using schema configuration.",
      "url": "/en/guides/cms/decap-cms/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "decap",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/deploy/index",
      "language": "en",
      "title": "Deploy your Astro Site",
      "summary": "**Deploying Astro Sites** Astro components are designed to be deployed to the web using various deployment services, including Netlify and Vercel, which support continuous deployment via Git. Key features include: * `astro build` command for building the site * `dist` directory as the publish directory * Integration with popular Git providers (GitHub, GitLab, Bitbucket) * Automatic detection of pushes to the Astro project's source repository * Rebuilding and republishing the site at each new commit Implementation details include: * Connecting the Astro project's online Git repository to a host provider * Configuring the host to use the `astro build` command and `dist` directory * Setting up continuous deployment using Git Use cases include: * Deploying an Astro site to a custom URL or personal domain * Using a host's dashboard UI or CLI to build and deploy the site * Integrating with popular deployment services (Netlify, Vercel)",
      "url": "/en/guides/deploy/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site"
      ],
      "type": "guide"
    },
    {
      "id": "guides/deploy/aws",
      "language": "en",
      "title": "Deploy your Astro Site to AWS",
      "summary": "**Deploying Astro Sites to AWS** Astro sites can be deployed to AWS using AWS Amplify, S3 static website hosting, and CloudFront. **Key Features and APIs** * AWS Amplify: a set of purpose-built tools and features for building full-stack applications on AWS * S3 static website hosting: hosting static websites on Amazon S3 * CloudFront: a content delivery network (CDN) for distributing static assets * `amplify hosting`: a command-line interface for managing Amplify Hosting projects * `amplify configure`: a command for connecting a repository to Amplify * `amplify update`: a command for modifying build settings **Implementation Details and Use Cases** * Deploying Astro projects as static sites or server-rendered sites * Using AWS Amplify to manage build settings and connect repositories * Utilizing S3 static website hosting for hosting static websites * Leveraging CloudFront for distributing static assets **Technical Keywords** * AWS Amplify * S3 static website hosting * CloudFront * Static site generation * Server-side rendering * Build settings * Repository management",
      "url": "/en/guides/deploy/aws/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/flightcontrol",
      "language": "en",
      "title": "Deploy your Astro Site to AWS with Flightcontrol",
      "summary": "**Deploying Astro Sites to AWS with Flightcontrol** Astro sites can be deployed to AWS using Flightcontrol, a fully-automated deployment service, supporting both static and Server-Side Rendered (SSR) Astro sites. Key features include: * Integration with GitHub for repository connection * Support for GUI and infrastructure-as-code (flightcontrol.json) configurations * Automatic deployment to AWS with customizable configurations * SSR setup requires installation of the `@astrojs/node` adapter Implementation details involve creating a Flightcontrol account, connecting a GitHub repository, selecting a configuration type, and adjusting settings as needed.",
      "url": "/en/guides/deploy/flightcontrol/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "with"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/sst",
      "language": "en",
      "title": "Deploy your Astro Site to AWS with SST",
      "summary": "**Deploying Astro Sites to AWS with SST** Astro sites can be deployed to AWS using SST, an open-source framework for deploying modern full-stack applications with SSG and SSR support. Key features include automatic detection of Astro projects, type-safe deployment, and integration with additional SST components such as cron jobs, Buckets, and Queues. Deployment can be initiated using the `npx sst deploy` command, with optional configuration in `sst.config.ts` for linking resources and accessing additional SST components.",
      "url": "/en/guides/deploy/sst/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "with"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/azion",
      "language": "en",
      "title": "Deploy your Astro Site to Azion",
      "summary": "**Deploying Astro Sites to Azion** Astro components are deployable to Azion, a platform for frontend developers to collaborate and deploy static (JAMstack) and SSR websites, using the Azion CLI or Azion Console Dashboard. **Key Features and APIs** * `azion deploy`: deploys Astro site to Azion using the CLI * `azion console`: deploys Astro site to Azion using the web dashboard * `Astro.props`: integrates with Azion's build settings and framework presets * `getStaticPaths`: generates static paths for Astro site deployment **Implementation Details and Use Cases** * Deploy Astro site to Azion using the Azion CLI or web dashboard * Configure build settings and framework presets for Astro site deployment * Use Azion Real-Time Metrics to monitor deployment and verify site is live on the edge",
      "url": "/en/guides/deploy/azion/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "azion"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/clever-cloud",
      "language": "en",
      "title": "Deploy your Astro Site to Clever Cloud",
      "summary": "**Deploying Astro Sites to Clever Cloud** Astro components are deployable to Clever Cloud, a European cloud platform, using automated, scalable services. Key features include static and on-demand rendered project deployment, with options for static applications and Node.js applications. Clever Cloud supports Astro's pre-rendered and on-demand rendering modes, with customizable instance sizes and scalability options. **APIs and Methods** * `getStaticPaths` * `Astro.props` * `start` script for Node.js applications (e.g., `node ./dist/server/entry.mjs --host 0.0.0.0 --port 8080`) * Environment variables injection for Node.js applications **Implementation Details** * Project configuration for static and on-demand rendered projects * Post-build hook for static applications * Manual configuration in `package.json` for Node.js applications * Instance size and scalability options for Clever Cloud deployment **Use Cases** * Deploying Astro sites to Clever Cloud using automated services * Configuring static and on-demand rendered projects for deployment * Customizing instance sizes and scalability options for Clever Cloud deployment",
      "url": "/en/guides/deploy/clever-cloud/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "clever"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/cloudflare",
      "language": "en",
      "title": "Deploy your Astro Site to Cloudflare",
      "summary": "**Deploying Astro Sites to Cloudflare** Astro components are deployable to Cloudflare using Cloudflare Workers and Cloudflare Pages, enabling full-stack application deployment and on-demand rendered sites. Key features and APIs include: * `wrangler CLI` for deployment with Cloudflare Workers * `@astrojs/cloudflare` adapter for on-demand rendering * `astro.config.mjs` file modifications for Cloudflare integration * `.assetsignore` file configuration for asset management Implementation details include installing Wrangler CLI, adding the `@astrojs/cloudflare` adapter, and configuring the `astro.config.mjs` file. Use cases include deploying full-stack applications and on-demand rendered sites to Cloudflare Workers and Pages.",
      "url": "/en/guides/deploy/cloudflare/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "cloudflare"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/fleek",
      "language": "en",
      "title": "Deploy your Astro Site to Fleek",
      "summary": "**Deploying Astro Sites to Fleek** Astro sites can be deployed to Fleek's edge-optimized decentralized network using the Fleek UI or CLI. **Key Features and APIs** * `fleek login` API for logging in to the Fleek account from the terminal * `fleek sites init` API for initializing a new Fleek site * `fleek sites deploy` API for deploying a site to Fleek * Astro project configuration for static site deployment **Implementation Details and Use Cases** * Deploying a static Astro site to Fleek using the Fleek UI involves creating a Fleek account, pushing code to a Git repository, and importing the project into Fleek. * Deploying a static Astro site to Fleek using the Fleek CLI involves installing the Fleek CLI, logging in to the Fleek account, running the build command, initializing the project, and deploying the site. **Technical Keywords** * Astro * Fleek * Edge-optimized decentralized network * Static site deployment * CLI * API * Node.js * Git * Web deployment",
      "url": "/en/guides/deploy/fleek/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "fleek"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/flyio",
      "language": "en",
      "title": "Deploy your Astro Site to Fly.io",
      "summary": "**Deploying Astro Sites to Fly.io** Astro sites can be deployed to Fly.io, a platform for running full stack apps and databases close to users, as static sites or server-side rendered sites (SSR) using the Node.js adapter. **Key Features and APIs** * Supports static site deployment with no extra configuration * Enables on-demand rendering with Node.js adapter for SSR * Uses `flyctl` for app command center and deployment * Generates Dockerfile and `fly.toml` file for automated deployment * Integrates with `dockerfile` generator for custom Dockerfile creation **Implementation Details and Use Cases** * Static site deployment: no extra configuration required * SSR deployment: use Node.js adapter and `fly launch` command * Automated deployment: use `flyctl` and generated Dockerfile and `fly.toml` file * Custom Dockerfile creation: use `dockerfile` generator and `npx dockerfile` or `bunx dockerfile` commands",
      "url": "/en/guides/deploy/flyio/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "fly.io"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/github",
      "language": "en",
      "title": "Deploy your Astro Site to GitHub Pages",
      "summary": "**Deploying Astro Sites to GitHub Pages** Astro components are used to deploy Astro sites to GitHub Pages using GitHub Actions for automated building and deployment. Key features include integration with `withastro/action` for minimal configuration and support for internationalization. **Key APIs and Methods** * `withastro/action` for automated deployment * `astro.config.mjs` for site and base URL configuration * `.nojekyll` file for disabling Jekyll processing on GitHub Pages **Implementation Details and Use Cases** * Add an empty `.nojekyll` file to the `public/` directory to prevent Jekyll processing * Set `site` and `base` options in `astro.config.mjs` for `github.io` URL deployment * Use GitHub Actions for automated building and deployment of Astro sites",
      "url": "/en/guides/deploy/github/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "github"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/gitlab",
      "language": "en",
      "title": "Deploy your Astro Site to GitLab Pages",
      "summary": "Astro components are used to deploy Astro sites to GitLab Pages using GitLab CI/CD for automated building and deployment. Key features include: * `site` and `base` options in `astro.config.mjs` for configuring site and base URLs * `site` options: `https://.gitlab.io`, `https://.gitlab.io`, or custom domain * `base` options: repository name starting with a forward slash (e.g., `/my-repo`) * Integration with GitLab CI/CD for automated building and deployment Implementation details include setting up `site` and `base` options in `astro.config.mjs` and configuring GitLab CI/CD for automated deployment. Use cases include hosting Astro sites for GitLab projects, groups, or user accounts.",
      "url": "/en/guides/deploy/gitlab/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "gitlab"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/google-cloud",
      "language": "en",
      "title": "Deploy your Astro Site to Google Cloud",
      "summary": "**Deploying Astro Sites to Google Cloud** Astro sites can be deployed to Google Cloud using Cloud Storage for static sites or Cloud Run for server-side rendering (SSR) and static sites. **Key Features and APIs** * `dist` folder upload to Cloud Storage * Cloud Build integration for automated uploads * Cloud Run API for serverless deployment * Dockerfile creation for containerization * Artifact Registry for image storage and deployment **Implementation Details and Use Cases** * Cloud Storage: suitable for static sites, requires manual uploads or Cloud Build integration * Cloud Run: suitable for SSR and static sites, requires Dockerfile creation and containerization * Use cases: deploy Astro sites to Google Cloud for scalability, reliability, and security.",
      "url": "/en/guides/deploy/google-cloud/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "google"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/google-firebase",
      "language": "en",
      "title": "Deploy your Astro Site to Googles Firebase Hosting",
      "summary": "**Deploying Astro Sites to Google's Firebase Hosting** Astro sites can be deployed to Google's Firebase Hosting as static sites or server-side rendered sites (SSR) using the Firebase CLI and Node.js adapter. Key features include: * Static site deployment with no extra configuration required * SSR deployment with Node.js adapter and Blaze plan or higher * Authentication with Firebase CLI using Google account credentials * Installation of Firebase CLI using npm, pnpm, or yarn package managers Implementation details include using the `firebase login` command to authenticate with Google, and installing the Firebase CLI using `npm install firebase-tools`, `pnpm add firebase-tools`, or `yarn add firebase-tools`.",
      "url": "/en/guides/deploy/google-firebase/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "googles"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/heroku",
      "language": "en",
      "title": "Deploy your Astro Site to Heroku",
      "summary": "Here is the technical documentation summary: Astro sites can be deployed to Heroku using the Heroku CLI and a static.json configuration file. Key features include setting up a Heroku git remote, configuring the static.json file with a root directory, and deploying the site using `git push heroku master`. Implementation details involve using the Heroku CLI to create an app, set the buildpack, and deploy the site, while use cases include hosting Astro sites on a cloud platform with scalability and reliability.",
      "url": "/en/guides/deploy/heroku/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "heroku"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/kinsta",
      "language": "en",
      "title": "Deploy your Astro Site to Kinsta Application Hosting",
      "summary": "**Deploying Astro Sites to Kinsta Application Hosting** Astro sites can be deployed to Kinsta Application Hosting using a combination of Astro's built-in features and Kinsta's cloud hosting capabilities. **Key Features and APIs** * `package.json` configuration: `name` field, `build` script, and `start` script setup * Astro's `astro build` and `astro dev` commands * `serve` package for static hosting * `@astrojs/node` package for Server-Side Rendering (SSR) * `astro.config.mjs` configuration for SSR **Implementation Details and Use Cases** * Static hosting: use `serve` package to serve Astro site from `dist/` directory * SSR: use `@astrojs/node` package to run Astro site on Kinsta's cloud hosting * Example projects: Kinsta Application Hosting Starter projects for Astro and Astro SSR",
      "url": "/en/guides/deploy/kinsta/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "kinsta"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/microsoft-azure",
      "language": "en",
      "title": "Deploy your Astro Site to Microsoft Azure",
      "summary": "**Deploying Astro Sites to Microsoft Azure** Astro sites can be deployed to Microsoft Azure using the Static Web Apps service, enabling cloud-hosted web applications with internationalization support. Key features and APIs include: * Integration with Azure Static Web Apps service * Support for GitHub Actions for automated deployment * Use of Visual Studio Code extension for Azure Static Web Apps * APIs for creating and managing Static Web Apps, including `createStaticWebApp` and `getStaticWebApp` Implementation details include: * Using the SWA Extension in Visual Studio Code to create and manage Static Web Apps * Designating subscription keys and framework presets for deployment * Utilizing GitHub Actions for automated deployment and progress tracking Use cases include: * Deploying Astro sites to cloud-hosted environments with internationalization support * Automating deployment using GitHub Actions and Visual Studio Code extension * Integrating with Azure Static Web Apps service for scalable web applications",
      "url": "/en/guides/deploy/microsoft-azure/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "microsoft"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/netlify",
      "language": "en",
      "title": "Deploy your Astro Site to Netlify",
      "summary": "**Deploying Astro Sites to Netlify** Astro sites can be deployed to Netlify as static sites, server-rendered sites, or edge-rendered sites using the Netlify adapter. Key features include: * `astro add netlify` command for installing the Netlify adapter and configuring `astro.config.mjs` * Support for on-demand rendering and edge rendering using Netlify's Edge Functions * Integration with GitHub, GitLab, BitBucket, and Azure DevOps for automated deployments * Configuration options for deploying Astro middleware using Netlify's Edge Functions",
      "url": "/en/guides/deploy/netlify/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "netlify"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/render",
      "language": "en",
      "title": "Deploy your Astro Site to Render",
      "summary": "**Deploying Astro Sites to Render** Astro components are deployable to Render, a service providing free TLS certificates, global CDN, DDoS protection, private networks, and auto deploys from Git. Key features include connecting GitHub or GitLab repositories, specifying build commands (`npm run build`), and publishing directories (`dist` or `dist/client`), utilizing APIs such as `render.com` dashboard and `GitHub`/`GitLab` integrations. Implementation details involve creating a Render account, connecting a repository, and configuring site settings, with use cases including static site hosting, auto deploys, and global CDN distribution.",
      "url": "/en/guides/deploy/render/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "render"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/stormkit",
      "language": "en",
      "title": "Deploy your Astro Site to Stormkit",
      "summary": "Here is the technical documentation summary: Astro components are deployable to Stormkit, a deployment platform for static websites, SPAs, and serverless functions, using the Astrojs Starlight components and Steps API. Key features include importing Astro projects from supported Git providers, verifying build commands in Stormkit configuration, and deploying sites using the \"Deploy Now\" button. Implementation details involve using Astrojs Starlight components, such as Steps, and leveraging Stormkit's CI capabilities to run custom build commands, including npm run build by default.",
      "url": "/en/guides/deploy/stormkit/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "stormkit"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/surge",
      "language": "en",
      "title": "Deploy your Astro Site to Surge",
      "summary": "Astro components are deployable to the web using Surge, a single-command web publishing platform for front-end developers. Key features include: * Integration with the Surge CLI for streamlined deployment * Support for building Astro sites from the project's root directory using `npm run build` * Deployment to Surge using the `surge dist` command, with optional custom domain support Implementation details involve installing the Surge CLI globally, building the Astro site, and executing the `surge dist` command to deploy the site to the web.",
      "url": "/en/guides/deploy/surge/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "surge"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/vercel",
      "language": "en",
      "title": "Deploy your Astro Site to Vercel",
      "summary": "**Deploying Astro Sites to Vercel** Astro components are deployable to Vercel's global edge network with zero configuration, utilizing Vercel's website UI or CLI for deployment. **Key Features and APIs:** * `astro add vercel` command for installing the Vercel adapter * `astro.config.mjs` file configuration for on-demand rendering * Vercel CLI (command line interface) for deployment * Website UI deployment through Git repository import **Implementation Details and Use Cases:** * Static site deployment with zero configuration * On-demand rendering enabled through Vercel adapter installation * Deployment through Vercel's website UI or CLI for static and on-demand rendered Astro sites.",
      "url": "/en/guides/deploy/vercel/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "vercel"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/zeabur",
      "language": "en",
      "title": "Deploy your Astro Site to Zeabur",
      "summary": "**Deploying Astro Sites to Zeabur** Astro sites can be deployed to Zeabur as static or server-side rendered (SSR) applications. **Static Site**: No extra configuration is required to deploy a static Astro site to Zeabur. **SSR**: Install `@zeabur/astro-adapter` and add two lines to `astro.config.mjs` to enable SSR deployment. **Key Features and APIs**: * `@zeabur/astro-adapter` adapter for SSR deployment * `astro.config.mjs` configuration file for SSR setup * `defineConfig` function from `astro/config` for project configuration * `output` and `adapter` properties for SSR configuration **Implementation Details and Use Cases**: * Deploying static Astro sites to Zeabur requires no extra configuration. * Enabling SSR deployment requires installing `@zeabur/astro-adapter` and modifying `astro.config.mjs`. * Zeabur automatically detects Astro projects and builds them using `astro build`. * Subsequent pushes to branches generate new builds.",
      "url": "/en/guides/deploy/zeabur/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "zeabur"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/zerops",
      "language": "en",
      "title": "Deploy your Astro Site to Zerops",
      "summary": "**Deploying Astro Sites to Zerops** Astro components are deployable to Zerops, a dev-first cloud platform, using a `zerops.yml` configuration file. **Key Features and APIs** * `zerops.yml` file for project configuration * `setup`, `build`, and `run` commands for Astro site deployment * Support for Static and SSR Astro sites * Integration with Zerops services and projects **Implementation Details and Use Cases** * Create a Zerops project and service for Astro Static sites * Configure `zerops.yml` for Astro site deployment * Use Zerops services and projects to deploy multiple Astro sites * Leverage Zerops features for dev-first cloud deployment",
      "url": "/en/guides/deploy/zerops/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "zerops"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/buddy",
      "language": "en",
      "title": "Deploy your Astro Site with Buddy",
      "summary": "**Deploying Astro Sites with Buddy** Astro components are deployable using Buddy, a CI/CD solution, to build and push sites to various deploy targets, including FTP servers and cloud hosting providers. Key features include integrating with git repositories, adding Node.js actions, and configuring deployment actions with source paths set to `dist`. Implementations involve creating a Buddy account, connecting a git repository, adding a pipeline, and configuring actions to run `npm install` and `npm run build`. Use cases include deploying Astro sites to cloud hosting providers and FTP servers.",
      "url": "/en/guides/deploy/buddy/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "with"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/cleavr",
      "language": "en",
      "title": "Deploy your Astro Site with Cleavr",
      "summary": "**Deploying Astro Sites with Cleavr** Astro sites can be deployed to Virtual Private Servers (VPS) using Cleavr, a server and app deployment management tool, by following a series of steps to add and configure the site. Key features and APIs include: * `Add Site` functionality with domain name, app type (NodeJS Static or NodeJS SSR), artifact folder, and entry point configuration * `Setup and deploy` process with VC profile, repo, branch, and deployment configuration * Integration with Cleavr's deployment management system Implementation details include: * Selecting the correct app type (NodeJS Static or NodeJS SSR) based on the Astro app setup * Configuring artifact folder and entry point for Static and SSR apps, respectively * Deploying the Astro app using Cleavr's deployment management system",
      "url": "/en/guides/deploy/cleavr/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "with"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/cloudray",
      "language": "en",
      "title": "Deploy your Astro Site with CloudRay",
      "summary": "**Deploying Astro Sites with CloudRay** CloudRay is a centralized platform for managing servers, organizing Bash scripts, and automating deployment tasks across virtual machines and cloud servers. It provides automation tools to run deployment scripts on your own infrastructure using a connected agent. To deploy an Astro site with CloudRay, you'll need a CloudRay Account, a GitHub repository, and a CloudRay Agent installed on your Ubuntu server. **Key Features and APIs** * CloudRay Agent for secure remote automation * Bash scripts for cloning Astro repos, installing dependencies, building sites, and configuring web servers * CloudRay's variable groups for defining repo-specific values * Runlog interface for executing scripts and monitoring deployments in real-time * Astro guide in CloudRay's documentation for official resources and tutorials **Implementation Details and Use Cases** * Write reusable Bash scripts to automate Astro deployment tasks * Use CloudRay's variable groups to define repo-specific values * Execute scripts on connected servers using CloudRay's Runlog interface * Monitor deployments in real-time and troubleshoot issues using CloudRay's dashboard",
      "url": "/en/guides/deploy/cloudray/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "with"
      ],
      "type": "deploy"
    },
    {
      "id": "guides/deploy/deno",
      "language": "en",
      "title": "Deploy your Astro Site with Deno",
      "summary": "**Deploying Astro Sites with Deno** Astro components are deployable with Deno, a JavaScript runtime, for static or on-demand rendered sites. Key features include support for static sites, on-demand rendering with the `@deno/astro-adapter` adapter, and deployment to Deno Deploy through GitHub Actions or the Deno Deploy CLI. Implementation details involve installing the adapter, updating `astro.config.mjs` with the `deno()` adapter, and modifying the `preview` script in `package.json`.",
      "url": "/en/guides/deploy/deno/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "deploy",
        "your",
        "astro",
        "site",
        "with"
      ],
      "type": "deploy"
    },
    {
      "id": "tutorial/1-setup/5",
      "language": "en",
      "title": "Deploy your site to the web",
      "summary": "**Deploying Astro Sites to the Web** Astro components are used to create interactive tutorials and guides, such as the Checklist, Box, MultipleChoice, Option, and PreCheck components, which are imported and used in the tutorial. The tutorial utilizes the Steps component from @astrojs/starlight/components and the Badge component from ~/components/Badge.astro. Key features include the PreCheck component, which displays a checklist of prerequisites, and the Steps component, which guides the user through a series of steps to deploy their Astro site to Netlify.",
      "url": "/en/tutorial/1-setup/5/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "1 setup",
        "deploy",
        "your",
        "site"
      ],
      "type": "tutorial"
    },
    {
      "id": "guides/dev-toolbar",
      "language": "en",
      "title": "Dev toolbar",
      "summary": "**Dev Toolbar** The Dev Toolbar is a debugging and inspection tool that appears at the bottom of every page in the local browser preview during development. It includes built-in apps such as Astro Menu, Inspect, and Audit, which provide information about the project, islands, and performance/accessibility issues. The Dev Toolbar can be extended with custom apps and is enabled by default, but will not appear on the published site.",
      "url": "/en/guides/dev-toolbar/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "toolbar"
      ],
      "type": "guide"
    },
    {
      "id": "reference/dev-toolbar-app-reference",
      "language": "en",
      "title": "Dev Toolbar App API",
      "summary": "Here is the technical documentation summary: The Astro Dev Toolbar App API allows developers to create Astro Integrations that add apps to the Astro Dev Toolbar, enabling new features and integrations with third-party services. The `addDevToolbarApp()` function, available in the `astro:config:setup` hook, adds dev toolbar apps with required properties: `id`, `name`, `icon`, and `entrypoint`. Implementations can utilize these properties to define toolbar apps, such as `my-app.js`, with a unique `id`, human-readable `name`, custom `icon`, and `entrypoint` path.",
      "url": "/en/reference/dev-toolbar-app-reference/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "toolbar"
      ],
      "type": "guide"
    },
    {
      "id": "develop-and-build",
      "language": "en",
      "title": "Develop and build",
      "summary": "Here is the technical documentation summary: Astro components are imported from `@astrojs/starlight/components` and used to build and customize the development environment. Key features include: * Importing components such as `Tabs`, `TabItem`, `FileTree`, `CardGrid`, `LinkCard`, and `Steps` from `@astrojs/starlight/components` * Using the `ReadMore` component from `~/components/ReadMore.astro` * Starting the Astro dev server with the `astro dev` CLI command * Customizing the development environment with TypeScript and official Astro editor extensions * Working in development mode with live file changes and an up-to-date site preview Implementation details include: * Running `npm run dev`, `pnpm run dev`, or `yarn run dev` to start the Astro dev server * Configuring the development environment with `astro dev` CLI command options * Using the Astro dev toolbar for debugging and development purposes",
      "url": "/en/develop-and-build/",
      "keywords": [
        "content",
        "docs",
        "develop",
        "build"
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/directus",
      "language": "en",
      "title": "Directus & Astro",
      "summary": "Astro components are integrated with Directus, a backend-as-a-service, to host data and content for Astro projects, utilizing APIs such as `getStaticPaths` and Astro.props, and leveraging features like internationalization. Directus can be used to manage and serve content, with official resources including the \"Getting Started with Directus and Astro\" guide and community resources like tutorials on using Directus with Neon Postgres and Astro. The integration enables developers to build and deploy Astro projects with a scalable and flexible content management system.",
      "url": "/en/guides/cms/directus/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "directus",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/cms/drupal",
      "language": "en",
      "title": "Drupal & Astro",
      "summary": "**Drupal & Astro Integration** Astro components are integrated with Drupal as a content management system (CMS) to fetch and display content in Astro projects. **Key Features and APIs** * Utilize the Drupal JSON:API module to make GET requests to the Drupal application * Set the Drupal URL in the `.env` file using the `DRUPAL_BASE_URL` variable * Implement authentication methods using Drupal's built-in authentication features * Use Astro components such as `FileTree`, `Steps`, `CardGrid`, and `LinkCard` to display content * Leverage APIs such as `Astro.props` to access and manipulate content **Implementation Details and Use Cases** * Install the JSON:API Drupal module and enable it on the Extend page * Configure the Drupal URL in the `.env` file and restart the dev server * Use authentication methods to restrict access to the Drupal JSON:API endpoint * Display content in Astro projects using integrated components and APIs",
      "url": "/en/guides/cms/drupal/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "drupal",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "reference/errors/duplicate-content-entry-slug-error",
      "language": "en",
      "title": "Duplicate content entry slug.",
      "summary": "**Duplicate Content Entry Slug** Duplicate content entry slug is a critical error that occurs when multiple entries in a content collection share the same slug, violating the uniqueness requirement for slugs. **Key Features and APIs** * `slug` frontmatter property: must be unique across all entries in a collection * Error message: \"COLLECTION_NAME contains multiple entries with the same slug: SLUG. Slugs must be unique.\" * Implementation detail: Astro's content collection validation checks for duplicate slugs **Use Cases and Implementation** * Use unique slug values for each entry in a collection to avoid this error * Update existing entries with duplicate slugs to use unique values * Consider using UUIDs or other unique identifier generators to ensure slug uniqueness",
      "url": "/en/reference/errors/duplicate-content-entry-slug-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "duplicate",
        "entry",
        "slug."
      ],
      "type": "guide"
    },
    {
      "id": "recipes/dynamically-importing-images",
      "language": "en",
      "title": "Dynamically import images",
      "summary": "**Dynamically Import Images using Vite's `import.meta.glob` Function** **Purpose:** Dynamically import images using Vite's `import.meta.glob` function to display images in Astro components. **Features:** * Use `import.meta.glob` to dynamically import image paths from the `assets` folder. * Define component props to receive image path, alt text, name, and age information. * Utilize Astro's `Astro.props` to access component props. * Import `Image` component from `astro:assets` to display images. **Implementation Details:** * Create a new `assets` folder under the `src` directory and add images inside. * Create a new Astro component and import the `` component. * Define component props and use `import.meta.glob` to dynamically import image paths. * Use `Astro.props` to access component props and display image information. **Use Cases:** * Dynamically import images in Astro components using Vite's `import.meta.glob` function. * Display image information, such as name, age, and photo, in Astro components. * Utilize Astro's `Astro.props` to access component props and display dynamic image content.",
      "url": "/en/recipes/dynamically-importing-images/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "dynamically",
        "import",
        "images"
      ],
      "type": "recipe"
    },
    {
      "id": "guides/ecommerce",
      "language": "en",
      "title": "E-commerce",
      "summary": "Astro components are designed to enable e-commerce functionality on Astro sites, offering various payment processing options, including checkout links, hosted payment pages, and storefronts using payment service APIs. Key features include payment processing overlays, such as Lemon Squeezy and Paddle, which can be integrated as scripts, buttons, or external links, providing basic customization and site branding. APIs and methods include Lemon.js JavaScript library, Astro.props, and getStaticPaths, allowing developers to create and manage digital products, sell products with checkout links, and customize checkout processes. Implementation details and use cases include adding payment processing services, creating checkout links, and customizing checkout overlays, with examples provided for Lemon Squeezy integration, including basic usage and anchor tag implementation.",
      "url": "/en/guides/ecommerce/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "e-commerce"
      ],
      "type": "guide"
    },
    {
      "id": "editor-setup",
      "language": "en",
      "title": "Editor setup",
      "summary": "**Astro Editor Setup** Astro components are customizable code editor integrations that improve the developer experience and unlock new features for Astro projects. Key features include: * Syntax highlighting for `.astro` files * TypeScript type information for `.astro` files * VS Code Intellisense for code completion, hints, and more * Astro extensions for VS Code, Zed, and JetBrains IDEs (Webstorm) Implementation details include: * Installing the Astro VS Code Extension for syntax highlighting, TypeScript type information, and Intellisense * Installing the Astro extension in Zed for syntax highlighting, code completion, and formatting * Installing the Astro plugin in JetBrains IDEs (Webstorm) for syntax highlighting, code completion, and formatting Use cases include: * Improving code editor productivity with Astro-specific features and developer experience enhancements * Unlocking new features and functionality for Astro projects with editor integrations",
      "url": "/en/editor-setup/",
      "keywords": [
        "content",
        "docs",
        "editor",
        "setup"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/missing-middleware-for-internationalization",
      "language": "en",
      "title": "Enabled manual internationalization routing without having a middleware.",
      "summary": "Astro components are designed to handle manual internationalization routing without requiring a middleware file, but this functionality is only available when a custom i18n middleware file is provided. Key features include Astro.props and getStaticPaths, which enable routing and internationalization capabilities. Implementation details involve configuring the i18n.routing setting to 'manual' and providing a custom middleware file to handle internationalization logic.",
      "url": "/en/reference/errors/missing-middleware-for-internationalization/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "enabled",
        "manual",
        "internationalization",
        "routing"
      ],
      "type": "guide"
    },
    {
      "id": "guides/endpoints",
      "language": "en",
      "title": "Endpoints",
      "summary": "**Endpoints** Astro components are used to create custom endpoints that serve any kind of data, including images, RSS documents, and API Routes. **Key Features** * Export a `GET` function (optionally `async`) that receives a `context` object with properties similar to the `Astro` global. * Return a `Response` object with a `name` and `url` to generate static files. * Support for binary data, such as images, using `arrayBuffer()` method. * Type-safe endpoint functions using TypeScript. **Implementation Details** * Create custom endpoints by adding `.js` or `.ts` files to the `/pages` directory. * Use the `GET` function to define the endpoint logic, which is called at build time or on request in SSR mode. * Use the `Response` object to return data, including binary data for images. **Use Cases** * Generate images, expose RSS documents, or use as API Routes to build a full API for your site. * Create custom endpoints for statically-generated sites or opt-in to SSR mode for live server endpoints.",
      "url": "/en/guides/endpoints/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "endpoints"
      ],
      "type": "guide"
    },
    {
      "id": "reference/modules/astro-env",
      "language": "en",
      "title": "Environment Variables API Reference",
      "summary": "Here is the technical documentation summary: **Environment Variables API Reference** The `astro:env` API provides a type-safe schema for environment variables, allowing configuration of server and client availability, data type, and additional properties. Key features include the `getSecret()` helper function for retrieving raw environment variable values by key, and imports from `astro:env/server` for accessing environment variables programmatically. This API is critical for retrieving environment variables in a type-safe and adapter-agnostic manner.",
      "url": "/en/reference/modules/astro-env/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "modules",
        "environment",
        "variables"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/live-content-config-error",
      "language": "en",
      "title": "Error in live content config.",
      "summary": "**Live Content Config Error Handling** Live content config errors occur when the schema is defined as a function for live collections, which is not supported. This error is typically encountered in the live content config file, where a schema object is expected instead of a function. The error message provides guidance on correcting the schema definition to resolve the issue.",
      "url": "/en/reference/errors/live-content-config-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "error",
        "live",
        "config."
      ],
      "type": "guide"
    },
    {
      "id": "reference/error-reference",
      "language": "en",
      "title": "Error reference",
      "summary": "**Error Reference Documentation** Astro components are designed to handle various errors that may occur during development and deployment, providing a comprehensive list of error types and their descriptions. Key features include: * Error types: UnknownCompilerError, ClientAddressNotAvailable, PrerenderClientAddressNotAvailable, StaticClientAddressNotAvailable, NoMatchingStaticPathFound, OnlyResponseCanBeReturned, MissingMediaQueryDirective, NoMatchingRenderer, NoClientEntrypoint, NoClientOnlyHint, InvalidGetStaticPathParam, InvalidGetStaticPathsEntry, InvalidGetStaticPathsReturn * APIs: Astro.clientAddress, getStaticPaths * Methods: handling unknown compiler errors, client address availability checks, static path matching, response type validation, media query directive validation, renderer matching, client entrypoint specification, client-only hint validation Implementation details include error handling mechanisms, adapter compatibility checks, and prerendering functionality. Use cases include troubleshooting guides, error handling in Astro components, and ensuring compatibility with various adapters and renderers.",
      "url": "/en/reference/error-reference/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "error"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/invalid-image-service",
      "language": "en",
      "title": "Error while loading image service.",
      "summary": "**InvalidImageService Error** Astro components are unable to load the configured image service due to an error, typically caused by an incompatible object export or incorrect path. The error is triggered by the `InvalidImageService` component, which is displayed when the image service fails to load. The `InvalidImageService` component is a child of the `DontEditWarning` component, which is imported from `~/components/DontEditWarning.astro`. Implementation details involve checking the image service's default export and path configuration. Use cases include troubleshooting image service issues and verifying compatibility with Astro's image service API.",
      "url": "/en/reference/errors/invalid-image-service/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "error",
        "while",
        "loading",
        "image"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/expected-not-esmimage",
      "language": "en",
      "title": "Expected image options, not an ESM-imported image.",
      "summary": "**ExpectedNotESMImage**: An ESM-imported image cannot be passed directly to `getImage()`. Instead, pass an object with the image in the `src` property, using the `getImage()` method with an object containing the `src` property, such as `const optimizedImage = await getImage({ src: myImage });`. This is a critical implementation detail for Astro image optimization, particularly when working with ESM-imported images.",
      "url": "/en/reference/errors/expected-not-esmimage/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "expected",
        "image",
        "options,",
        "esm-imported"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/expected-image-options",
      "language": "en",
      "title": "Expected image options.",
      "summary": "**ExpectedImageOptions**: Astro's `getImage()` function expects an object as its first parameter, containing properties such as `src`, `width`, and `height`, to optimize images. Passing parameters directly instead of inside an object is a common cause of this error. To fix, wrap parameters in an object, like `getImage({src: myImage, width: 300, height: 300})`.",
      "url": "/en/reference/errors/expected-image-options/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "expected",
        "image",
        "options."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/expected-image",
      "language": "en",
      "title": "Expected src to be an image.",
      "summary": "**ExpectedImage**: Expected `src` property for `getImage` or `` to be either an ESM imported image or a string with the path of a remote image. Received `SRC` (type: `TYPEOF_OPTIONS`). The `src` attribute must be a valid image path or an ESM imported image, and is typically used in conjunction with `getImage()` or `` components.",
      "url": "/en/reference/errors/expected-image/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "expected",
        "image."
      ],
      "type": "guide"
    },
    {
      "id": "reference/experimental-flags/client-prerender",
      "language": "en",
      "title": "Experimental client prerendering",
      "summary": "**Experimental Client Prerendering** Enables pre-rendering of prefetched pages on the client in supported browsers using the Speculation Rules Web API, enhancing the default `prefetch` behavior globally to prerender links on the client. This feature requires browser support and may pose risks when prerendering on the client, as outlined in the Speculation Rules API documentation. To enable client-side prerendering, set `experimental.clientPrerender` to `true` in `astro.config.mjs` and use the `data-astro-prefetch` attribute on `` links.",
      "url": "/en/reference/experimental-flags/client-prerender/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "experimental flags",
        "experimental",
        "client",
        "prerendering"
      ],
      "type": "guide"
    },
    {
      "id": "reference/experimental-flags/csp",
      "language": "en",
      "title": "Experimental Content Security Policy (CSP)",
      "summary": "**Experimental Content Security Policy (CSP)** Astro components are enabled with support for Content Security Policy (CSP) to minimize security threats by controlling resource loading, providing protection against cross-site scripting (XSS) attacks. This feature adds security to Astro's handling of processed and bundled scripts and styles by default, allowing configuration of content types, and provides a `` element with `http-equiv=\"content-security-policy\"` attribute and `script-src` and `style-src` directives based on used scripts and styles. Key features and APIs include: * `experimental.csp` flag in Astro config * `` element with `http-equiv=\"content-security-policy\"` attribute * `script-src` and `style-src` directives * Support for inline scripts with custom hashes * Limitations: inline scripts, Astro's view transitions using ``",
      "url": "/en/reference/experimental-flags/csp/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "experimental flags",
        "experimental",
        "security",
        "policy",
        "(csp)"
      ],
      "type": "guide"
    },
    {
      "id": "reference/experimental-flags/fonts",
      "language": "en",
      "title": "Experimental fonts API",
      "summary": "**Experimental fonts API** This API allows you to use fonts from your filesystem and various font providers through a unified, fully customizable, and type-safe API. It enables automatic web font optimizations, including preload links, optimized fallbacks, and opinionated defaults. To use this feature, configure an `experimental.fonts` object with at least one font, specifying a `provider`, `name`, and `cssVariable` for each font. **Key Features:** * `experimental.fonts` object with font objects * `provider` options: built-in remote providers, custom font provider, local provider * `name`: font family supported by the provider * `cssVariable`: reference to the font family * Automatic web font optimizations: preload links, optimized fallbacks, opinionated defaults **Implementation Details:** * Configure `experimental.fonts` object in `astro.config.mjs` * Add `` component and site-wide styling in `` * Use `fontProviders` to specify font providers and options **Use Cases:** * Use custom fonts from your filesystem or remote providers * Optimize web font performance with automatic preload links and fallbacks * Customize font loading and rendering with opinionated defaults",
      "url": "/en/reference/experimental-flags/fonts/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "experimental flags",
        "experimental",
        "fonts"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/experimental-fonts-not-enabled",
      "language": "en",
      "title": "Experimental fonts are not enabled",
      "summary": "**ExperimentalFontsNotEnabled**: The Font component is used but experimental fonts have not been registered in the Astro config. This error occurs when the `Font` component is utilized, but the experimental font registration is missing in the Astro configuration. The `Font` component relies on registered experimental fonts to function correctly, and this error indicates a configuration mismatch.",
      "url": "/en/reference/errors/experimental-fonts-not-enabled/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "experimental",
        "fonts",
        "enabled"
      ],
      "type": "guide"
    },
    {
      "id": "reference/experimental-flags/content-intellisense",
      "language": "en",
      "title": "Experimental Intellisense for content collections",
      "summary": "**Experimental Intellisense for Content Collections** Astro components are enabled with Intellisense features for content collection entries in compatible editors through the `contentIntellisense` experimental feature. This feature generates JSON schemas in the `.astro` directory, utilizing the Astro language server to provide code completion and quick hints in content files (.md, .mdx, .mdoc). The feature is enabled by setting `contentIntellisense: true` in the Astro configuration file.",
      "url": "/en/reference/experimental-flags/content-intellisense/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "experimental flags",
        "experimental",
        "intellisense",
        "collections"
      ],
      "type": "guide"
    },
    {
      "id": "reference/experimental-flags/live-content-collections",
      "language": "en",
      "title": "Experimental live content collections",
      "summary": "**Experimental Live Content Collections** Astro components are designed to support live content collections, a new type of content collection that fetches data at runtime, enabling access to frequently updated data from CMSs, APIs, databases, or other sources using a unified API. Key features include: * `experimental.liveContentCollections` flag in `astro.config.mjs` * `defineLiveCollection()` function from `astro:content` module * `getLiveCollection()` and `getLiveEntry()` functions for accessing live data * Support for on-demand rendering and live loaders Implementation details include: * Creating a `src/live.config.ts` file to define live collections with a live loader and optional schema * Using the `defineLiveCollection()` function to create live collections * Accessing live data using `getLiveCollection()` and `getLiveEntry()` functions Use cases include: * Fetching frequently updated data from CMSs, APIs, databases, or other sources * Enabling real-time updates in Astro applications * Creating dynamic and interactive content experiences",
      "url": "/en/reference/experimental-flags/live-content-collections/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "experimental flags",
        "experimental",
        "live",
        "collections"
      ],
      "type": "guide"
    },
    {
      "id": "reference/experimental-flags/heading-id-compat",
      "language": "en",
      "title": "Experimental Markdown heading ID compatibility",
      "summary": "**Experimental Markdown heading ID compatibility** Astro components are enhanced with experimental support for Markdown heading ID compatibility, allowing generated IDs to be compatible with platforms like GitHub and npm. The `experimental.headingIdCompat` flag enables this feature, which can be set to `true` in Astro configuration. This flag affects how Astro generates `id` attributes for Markdown headings, retaining trailing hyphens for IDs ending in special characters.",
      "url": "/en/reference/experimental-flags/heading-id-compat/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "experimental flags",
        "experimental",
        "markdown",
        "heading",
        "compatibility"
      ],
      "type": "guide"
    },
    {
      "id": "reference/experimental-flags/preserve-scripts-order",
      "language": "en",
      "title": "Experimental preserve scripts order",
      "summary": "**Experimental preserve scripts order** Astro components are designed to preserve the order of `` and `` tags in the source code, allowing for predictable and consistent rendering of styles and scripts. This feature is enabled by setting the `experimental.preserveScriptOrder` feature flag to `true` in the Astro config, and can be used to maintain the original order of styles and scripts in the generated HTML output. The `preserveScriptOrder` flag is a boolean value that defaults to `false`.",
      "url": "/en/reference/experimental-flags/preserve-scripts-order/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "experimental flags",
        "experimental",
        "preserve",
        "scripts",
        "order"
      ],
      "type": "guide"
    },
    {
      "id": "reference/experimental-flags/raw-env-values",
      "language": "en",
      "title": "Experimental raw environment variables values",
      "summary": "**Astro allows you to configure a type-safe schema for your environment variables and converts variables imported via `astro:env` into the expected type.** **Features:** * `experimental.rawEnvValues` flag to disable coercion of `import.meta.env` values * Type-safe schema for environment variables * Conversion of variables imported via `astro:env` into expected type * Coercion of `import.meta.env` values can be disabled for string values `\"true\"` and `\"1\"` **Implementation details:** * Set `experimental.rawEnvValues` flag to `true` in `astro.config.mjs` * No longer converts string values into booleans or numbers * Aligns `import.meta.env` behavior with Vite **Use cases:** * Disable coercion of `import.meta.env` values for string values * Use `experimental.rawEnvValues` flag to opt in to future behavior * Update project code to apply coercion manually if necessary",
      "url": "/en/reference/experimental-flags/raw-env-values/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "experimental flags",
        "experimental",
        "environment",
        "variables",
        "values"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/generate-content-types-error",
      "language": "en",
      "title": "Failed to generate content types.",
      "summary": "**Astro content generation failed due to synchronization error** The `astro sync` command failed to generate content collection types, resulting in a `GenerateContentTypesError`. This error occurs when the `astro sync` command encounters an issue while processing content collection types, typically due to invalid or missing configuration. The error message provides details on the specific issue, such as `ERROR_MESSAGE`.",
      "url": "/en/reference/errors/generate-content-types-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "failed",
        "generate",
        "types."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/markdown-frontmatter-parse-error",
      "language": "en",
      "title": "Failed to parse Markdown frontmatter.",
      "summary": "**Astro Markdown Frontmatter Parser** Astro components are designed to parse Markdown frontmatter, but failed to do so due to syntax errors such as missing colons or end quotes. The parser encounters errors like \"can not read an implicit mapping pair\" or \"unexpected end of the stream within a double quoted scalar\". The `Astro.props` API can be used to access and validate frontmatter data, and implementation details include checking for missing colons and end quotes in the Markdown file.",
      "url": "/en/reference/errors/markdown-frontmatter-parse-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "failed",
        "parse",
        "markdown",
        "frontmatter."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/failed-to-fetch-remote-image-dimensions",
      "language": "en",
      "title": "Failed to retrieve remote image dimensions",
      "summary": "**Failed to retrieve remote image dimensions** Astro components fail to retrieve remote image dimensions due to incorrect URLs or attempting to infer sizes of images in the public folder. This is typically caused by an incorrect URL or attempting to infer the size of an image in the public folder which is not possible. The `IMAGE_URL` parameter is affected, and the error is critical.",
      "url": "/en/reference/errors/failed-to-fetch-remote-image-dimensions/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "failed",
        "retrieve",
        "remote",
        "image"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/file-parser-not-found",
      "language": "en",
      "title": "File parser not found",
      "summary": "**File Loader Error Handling** The `file` loader in Astro components is designed to handle file-based data loading, but it requires a custom parser function to process specific file types. To resolve the `FileParserNotFound` error, pass a parser function (e.g., `csv`) to the `file` loader using the `parser` option. This can be achieved by providing a custom parser function, such as `csv-parse`, to create a collection from the file type.",
      "url": "/en/reference/errors/file-parser-not-found/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "file",
        "parser",
        "found"
      ],
      "type": "guide"
    },
    {
      "id": "guides/backend/google-firebase",
      "language": "en",
      "title": "Firebase & Astro",
      "summary": "**Firebase & Astro Integration** Firebase & Astro components are a set of APIs and methods that enable integration with the Firebase app development platform, providing a NoSQL database, authentication, real-time subscriptions, functions, and storage. **Key Features and APIs:** * `firebase.initializeApp()` initializes the Firebase app with credentials from the `.env` file * `firebase.auth()` provides authentication functionality for user management * `firebase.firestore()` enables interaction with the NoSQL database * `firebase.functions()` allows execution of server-side functions * `firebase.storage()` provides access to cloud storage **Implementation Details:** * Create an `.env` file in the project root with Firebase credentials * Initialize Firebase in Astro using `firebase.initializeApp()` * Use Firebase APIs and methods to interact with the Firebase services **Use Cases:** * Authenticate users with Firebase authentication * Store and retrieve data in the Firebase NoSQL database * Execute server-side functions using Firebase Cloud Functions * Store and serve files using Firebase Cloud Storage",
      "url": "/en/guides/backend/google-firebase/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "backend",
        "firebase",
        "astro"
      ],
      "type": "backend"
    },
    {
      "id": "guides/cms/flotiq",
      "language": "en",
      "title": "Flotiq & Astro",
      "summary": "Here is the technical documentation summary: **Flotiq & Astro Integration** Flotiq & Astro components are designed to integrate a headless CMS with Astro projects, enabling developers to manage and deliver content through REST and GraphQL-based APIs. Key features include Astro.props, getStaticPaths, and integration with Flotiq's Content Type Definitions and Content Objects. Implementation details involve setting up environment variables, defining Content Type Definitions in Flotiq, and utilizing Flotiq's APIs to fetch and display content in Astro components.",
      "url": "/en/guides/cms/flotiq/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "flotiq",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "reference/errors/font-family-not-found",
      "language": "en",
      "title": "Font family not found",
      "summary": "**Font Family Not Found Error** Font family not found errors occur when the Font component is unable to locate a specified font family. This issue can be resolved by ensuring the font family is correctly imported and registered in the Astro project. The error can be mitigated by implementing font fallbacks or using a font loading library to handle font loading and error handling.",
      "url": "/en/reference/errors/font-family-not-found/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "font",
        "family",
        "found"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/forbidden-rewrite",
      "language": "en",
      "title": "Forbidden rewrite to a static route.",
      "summary": "**Forbidden Rewrite to Static Route** Astro components are restricted from rewriting on-demand routes to static routes when using the \"server\" output, due to prerendered component compilation to HTML files. Specifically, `Astro.rewrite()` is not allowed to rewrite an on-demand route with a static route in server output mode, as it prevents runtime retrieval of prerendered HTML files. This restriction is enforced to prevent forbidden operations during build time.",
      "url": "/en/reference/errors/forbidden-rewrite/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "forbidden",
        "rewrite",
        "static",
        "route."
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/frontmatter-cms",
      "language": "en",
      "title": "Front Matter CMS & Astro",
      "summary": "**Front Matter CMS & Astro** Front Matter CMS integrates with Astro to enable content management within the editor, supporting internationalization and ready for use with Astro projects. **Key Features and APIs** * Supports Astro projects with internationalization * Integrates with Visual Studio Code, Gitpod, and other editors * Uses `FileTree` component from `@astrojs/starlight/components` * Provides `Astro.props` API for accessing Astro project metadata * Utilizes `getStaticPaths` method for generating static paths **Implementation and Use Cases** * Initialize project with Front Matter CMS by clicking the \"Initialize project\" button * Register content folders, such as `src/content/blog`, to enable content creation * Use Front Matter CMS to create and manage content within the editor, with support for multiple folder registrations and internationalization.",
      "url": "/en/guides/cms/frontmatter-cms/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "front",
        "matter",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/framework-components",
      "language": "en",
      "title": "Front-end frameworks",
      "summary": "**Front-end frameworks** Astro components are a collection of UI frameworks, including React, Preact, Svelte, Vue, SolidJS, and AlpineJS, that can be used to build Astro websites without sacrificing performance. Key features include official integrations with various frameworks, support for community-maintained integrations, and the ability to use framework components alongside Astro components using the `import` statement and JSX-like expressions.",
      "url": "/en/guides/framework-components/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "front-end",
        "frameworks"
      ],
      "type": "guide"
    },
    {
      "id": "tutorial/5-astro-api/2",
      "language": "en",
      "title": "Generate tag pages",
      "summary": "**Generate tag pages** Astro components are used to create dynamic page routing and generate multiple pages based on specified routes and props. Key features include the `getStaticPaths` function, which returns an array of page routes, and the `Astro.params` object, which provides access to route parameters. Implementation details involve creating a new file with a `.astro` extension, defining the `getStaticPaths` function, and using the `Astro.params` object to render dynamic content.",
      "url": "/en/tutorial/5-astro-api/2/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "5 astro api",
        "generate",
        "pages"
      ],
      "type": "tutorial"
    },
    {
      "id": "reference/errors/get-static-paths-removed-rsshelper",
      "language": "en",
      "title": "getStaticPaths RSS helper is not available anymore.",
      "summary": "**getStaticPaths RSS Helper Removal** The `getStaticPaths` function no longer exposes an RSS helper for generating a RSS feed, which is deprecated since Astro 4.0. To generate a RSS feed, use the `@astrojs/rss` package instead, following the RSS guide and integration recipe.",
      "url": "/en/reference/errors/get-static-paths-removed-rsshelper/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "getstaticpaths",
        "helper",
        "available",
        "anymore."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/get-static-paths-required",
      "language": "en",
      "title": "getStaticPaths() function required for dynamic routes.",
      "summary": "**getStaticPaths() function required for dynamic routes.** The `getStaticPaths()` function is a required export for dynamic routes, returning the different paths to generate at build time in Static Mode. This function must be implemented to determine all routes at build time, ensuring server-side rendering and on-demand rendering functionality.",
      "url": "/en/reference/errors/get-static-paths-required/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "getstaticpaths()",
        "function",
        "required",
        "dynamic"
      ],
      "type": "guide"
    },
    {
      "id": "getting-started",
      "language": "en",
      "title": "Getting started",
      "summary": "Astro components are reusable UI elements that can be used to build web applications, featuring APIs such as Astro.props, and methods like getStaticPaths, to enable server-side rendering and static site generation. Implementation details include using Astro components like CardGrid, Card, ListCard, and SplitCard to create interactive layouts, and integrating with other frameworks like React and Partytown. Use cases include building content-driven websites, blogs, portfolios, and landing pages, with internationalization support.",
      "url": "/en/getting-started/",
      "keywords": [
        "content",
        "docs",
        "getting",
        "started"
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/ghost",
      "language": "en",
      "title": "Ghost & Astro",
      "summary": "**Ghost & Astro Integration** Ghost & Astro components are used to fetch and display content from a Ghost CMS instance within an Astro project. Key features include: * `@tryghost/content-api` wrapper for interacting with the Ghost Content API * Environment variable support for storing API keys (e.g., `CONTENT_API_KEY`) * TypeScript support for auto-completion and type checking (e.g., `ImportMetaEnv` interface) Implementation details include: * Creating an `.env` file to store API keys * Configuring `env.d.ts` for IntelliSense support * Installing the `@tryghost/content-api` package using npm or yarn Use cases include: * Fetching and displaying blog posts, pages, and other content from a Ghost CMS instance * Integrating Ghost content with Astro components and templates * Using environment variables to securely store API keys and credentials",
      "url": "/en/guides/cms/ghost/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "ghost",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/cms/gitcms",
      "language": "en",
      "title": "GitCMS & Astro",
      "summary": "**GitCMS & Astro Integration** GitCMS & Astro components are a seamless integration of a Git-based headless CMS into Astro projects, enabling Notion-like markdown editing experiences and internationalization capabilities. Key features include Astro.props, getStaticPaths, and Astro components, which leverage GitCMS APIs to manage content and metadata. This integration is ideal for developers building Astro sites that require robust content management and internationalization, and can be implemented using official resources such as configuration guides and Chrome extensions.",
      "url": "/en/guides/cms/gitcms/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "gitcms",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "reference/errors/file-glob-not-supported",
      "language": "en",
      "title": "Glob patterns are not supported in the file loader",
      "summary": "**FileGlobNotSupported**: The `file` loader in Astro does not support glob patterns, requiring a single local file to be passed. Instead, use the built-in `glob` loader to create entries from patterns of multiple local files. This is a limitation of the `file` loader, and the `glob` loader should be used for more complex file loading scenarios.",
      "url": "/en/reference/errors/file-glob-not-supported/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "glob",
        "patterns",
        "supported",
        "file"
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/hashnode",
      "language": "en",
      "title": "Hashnode & Astro",
      "summary": "**Hashnode & Astro Integration** Hashnode & Astro components are used to integrate Hashnode as a CMS with Astro projects, enabling the creation of blogs and publications. **Key Features and APIs** * Utilizes the Hashnode Public API, a GraphQL API, to interact with Hashnode data * Leverages `graphql-request`, a minimal GraphQL client, to fetch data in Astro projects * Supports internationalization (i18n) out of the box * Includes Astro components such as `FileTree` and `Steps` for building and navigating content **Implementation Details and Use Cases** * Requires an Astro project and a Hashnode site to get started * Uses `graphql-request` to fetch data and integrate with Astro projects * Example use case: creating an index page that lists posts with links to dynamically-generated individual post pages",
      "url": "/en/guides/cms/hashnode/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "hashnode",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/cms/statamic",
      "language": "en",
      "title": "Headless Statamic & Astro",
      "summary": "**Headless Statamic & Astro Integration** Astro components are integrated with Statamic, a modern, flat-file CMS, to enable dynamic website and application creation while providing a user-friendly content management interface. Key features include: * Utilizing Statamic's built-in REST API and GraphQL API to connect data to Astro * Enabling REST API and GraphQL API in Statamic Pro version * Fetching data from Statamic site's REST API URL (e.g., `https://[YOUR-SITE]/api/`) * Using `STATAMIC_API_ENABLED=true` or `STATAMIC_GRAPHQL_ENABLED=true` in `.env` file to enable API * Implementing Astro components (e.g., `Grid`, `Card`) to display Statamic data Implementation details and use cases include: * Creating dynamic websites and applications with Statamic data * Using Astro components to display Statamic data (e.g., `getStaticPaths`, `Astro.props`) * Enabling internationalization (i18n) support in Statamic and Astro integration",
      "url": "/en/guides/cms/statamic/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "headless",
        "statamic",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/cms/wordpress",
      "language": "en",
      "title": "Headless WordPress & Astro",
      "summary": "**Headless WordPress & Astro** Astro components are integrated with WordPress as a headless CMS to provide content to Astro projects. **Key Features:** * Utilize WordPress REST API to connect WordPress data to Astro * Optional installation of WPGraphQL or Gato GraphQL for GraphQL support * Fetch WordPress data through site's unique REST API URL and content route (e.g., `posts`) * Render data properties using Astro's `set:html={}` directive **Implementation Details:** * Prerequisites: Astro project and WordPress site with REST API enabled * Set up credentials: WordPress REST API available for external requests without authentication by default * Fetch data: Use site's REST API URL and content route to retrieve data, then render using Astro's `set:html={}` directive",
      "url": "/en/guides/cms/wordpress/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "headless",
        "wordpress",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/cms/hygraph",
      "language": "en",
      "title": "Hygraph & Astro",
      "summary": "**Hygraph & Astro Integration** Hygraph & Astro components are used to fetch content from a Hygraph GraphQL endpoint in an Astro project. **Key Features:** * Expose a Hygraph GraphQL endpoint for fetching content * Use environment variables (e.g., `HYGRAPH_ENDPOINT`) to configure the endpoint * Implement GraphQL queries to fetch content (e.g., `blogPosts` content type with `title` field) * Utilize Astro's `ImportMetaEnv` to enable IntelliSense for environment variables **Implementation Details:** * Create a `.env` file with the Hygraph endpoint URL * Configure `env.d.ts` to enable IntelliSense for environment variables * Use the `HYGRAPH_ENDPOINT` variable to fetch data from the Hygraph GraphQL endpoint * Implement GraphQL queries to fetch specific content types and fields",
      "url": "/en/guides/cms/hygraph/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "hygraph",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "reference/errors/i18n-not-enabled",
      "language": "en",
      "title": "i18n Not Enabled",
      "summary": "**Astro i18n Module:** The `astro:i18n` module is a feature of Astro that enables internationalization support, allowing developers to create multilingual applications. It provides a set of APIs and methods, including `getStaticPaths` and `Astro.props`, for handling locale-specific content and routing. To use the `astro:i18n` module, i18n must be enabled in the Astro config by defining a default locale and a list of supported locales.",
      "url": "/en/reference/errors/i18n-not-enabled/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "i18n",
        "enabled"
      ],
      "type": "guide"
    },
    {
      "id": "reference/modules/astro-assets",
      "language": "en",
      "title": "Image and Assets API Reference",
      "summary": "**Image and Assets API Reference** Astro provides built-in components and helper functions for optimizing and displaying images, including the `` component for optimizing and transforming images, and the `getImage` function for retrieving image metadata. **Key Features and APIs** * `` component with properties `src`, `alt`, and responsive image properties * `getImage` function for retrieving image metadata * `inferRemoteSize` function for inferring remote image sizes * `Picture` component for wrapping `` with a `` element **Implementation Details and Use Cases** The `` component can be used to create responsive images that adjust based on container or device screen size and resolution. It also enforces proper attributes, such as `decoding` and `loading`, for optimized image loading. The `getImage` function can be used to retrieve image metadata, and the `inferRemoteSize` function can be used to infer remote image sizes.",
      "url": "/en/reference/modules/astro-assets/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "modules",
        "image",
        "assets"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/image-missing-alt",
      "language": "en",
      "title": "Image missing required alt property.",
      "summary": "**Image Component Requirements** The Image component in Astro requires the `alt` property to be specified, providing descriptive alt text for users of screen readers and assistive technologies. This ensures image accessibility and compliance with web standards. The `alt` property can be set to an empty string (`alt=\"\"`) for decorative images that don't contribute to the page's understanding.",
      "url": "/en/reference/errors/image-missing-alt/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "image",
        "missing",
        "required",
        "property."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/image-not-found",
      "language": "en",
      "title": "Image not found.",
      "summary": "**ImageNotFound Component: Astro Image Loading Error** The ImageNotFound component is a built-in Astro component that displays an error message when an image cannot be found. It exposes the `getImagePath` method to retrieve the requested image path and provides the `Astro.props` object for accessing component props. This component is useful for handling image loading errors in Markdown files, where images are relative to the current file.",
      "url": "/en/reference/errors/image-not-found/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "image",
        "found."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/markdown-image-not-found",
      "language": "en",
      "title": "Image not found.",
      "summary": "**ImageNotFound Error** Astro components are designed to handle image loading and rendering, but may throw an ImageNotFound error when an image cannot be found at the specified path. Key features include Astro's ability to handle relative image paths, with support for `./` notation to reference images in the same folder as the `.md` file. The `ImageNotFound` error is triggered when Astro's `getStaticPaths` method fails to locate the requested image, and can be resolved by verifying the image path and ensuring it is correctly referenced in the Markdown content.",
      "url": "/en/reference/errors/markdown-image-not-found/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "image",
        "found."
      ],
      "type": "guide"
    },
    {
      "id": "reference/image-service-reference",
      "language": "en",
      "title": "Image Service API",
      "summary": "**Image Service API Summary** Astro components are designed to integrate with image optimization services, providing a flexible and extensible way to handle image transformations and rendering. The Image Service API offers two types of services: Local and External. Local services provide a `transform()` method for image transformations, while External services use a `getURL()` method to point to a remote URL for image rendering. Both services can also provide `getHTMLAttributes()` and `validateOptions()` methods for additional functionality. **Key Features and APIs:** * `transform()`: Local service method for image transformations * `getURL()`: External service method to retrieve a remote URL for image rendering * `getHTMLAttributes()`: Method to determine additional attributes for the output `` tag * `validateOptions()`: Method to validate and augment passed options for image rendering * `parseURL()`: Local service method to use an endpoint for dev mode and on-demand rendering * `AstroConfig['image']`: Configuration object for image rendering * `ImageTransform`: Type definition for image transformation options * `ExternalImageService`: Type definition for external image services",
      "url": "/en/reference/image-service-reference/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "image",
        "service"
      ],
      "type": "guide"
    },
    {
      "id": "guides/images",
      "language": "en",
      "title": "Images",
      "summary": "**Astro Images** Astro provides several ways to use images on your site, including image and picture components, Markdown image syntax processing, SVG components, and an image generating function to optimize and/or transform images. **Key Features and APIs** * `Image` and `Picture` components for optimized and responsive image rendering * Markdown image syntax processing for easy image inclusion * SVG components for scalable vector graphics * `getImage` function for generating images on the fly * Automatic responsive image behavior configuration * Support for storing images in `src/` or `public/` directories **Implementation Details and Use Cases** * Store local images in `src/` for transformation, optimization, and bundling * Use `Image` and `Picture` components for optimized image rendering * Utilize Markdown image syntax for easy image inclusion * Configure automatic responsive image behavior for seamless image rendering",
      "url": "/en/guides/images/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "images"
      ],
      "type": "guide"
    },
    {
      "id": "guides/imports",
      "language": "en",
      "title": "Imports reference",
      "summary": "**Astro imports reference** Astro supports importing various file types with zero configuration required, including Astro components, Markdown, JavaScript, TypeScript, NPM packages, JSON, CSS, CSS modules, images, and assets. This is achieved through the use of the `import` statement in JavaScript, including Astro frontmatter, and `@import` in CSS and `` tags. **Supported file types:** * Astro Components (.astro) * Markdown (.md, .markdown, etc.) * JavaScript (.js, .mjs) * TypeScript (.ts) * NPM Packages * JSON (.json) * CSS (.css) * CSS Modules (.module.css) * Images & Assets (.svg, .jpg, .png, etc.) **Files in `public/`:** * Any static asset can be placed in the `public/` directory and will be copied directly into the final build untouched. * `public/` files are not built or bundled by Astro, supporting any file type. * Files can be referenced by a URL path directly in HTML templates. **Import statements:** * Astro uses ESM, supporting `import` and `export` statements. * `import` statements can be used anywhere in the project JavaScript, including Astro frontmatter.",
      "url": "/en/guides/imports/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "imports",
        "reference"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/missing-index-for-internationalization",
      "language": "en",
      "title": "Index page not found.",
      "summary": "**Astro components are used to render pages, but an index page is required for internationalization routing.** **Key features and APIs include:** * `i18n.routing.prefixDefaultLocale` configuration option * `getStaticPaths` method for generating static paths * `Astro.props` object for accessing component props * `DontEditWarning` component for displaying a warning message **Implementation details and use cases:** * An index page is required to create a redirect to the index URL of the default locale * Internationalization routing is enabled using `i18n.routing.prefixDefaultLocale` * The `getStaticPaths` method is used to generate static paths for internationalized routes * The `Astro.props` object is used to access component props in internationalized routes",
      "url": "/en/reference/errors/missing-index-for-internationalization/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "index",
        "page",
        "found."
      ],
      "type": "guide"
    },
    {
      "id": "install-and-setup",
      "language": "en",
      "title": "Install Astro",
      "summary": "**Astro Installation** Astro components are imported from `@astrojs/starlight/components` and custom components are imported from local files using `import` statements. Key features include the `create astro` CLI command for project setup and the ability to choose from official starter templates or existing themes. Implementation details involve running the CLI command with the `template` flag to select a specific template, and manual installation can be done through a step-by-step guide.",
      "url": "/en/install-and-setup/",
      "keywords": [
        "content",
        "docs",
        "install",
        "astro"
      ],
      "type": "guide"
    },
    {
      "id": "recipes/add-yaml-support",
      "language": "en",
      "title": "Installing a Vite or Rollup plugin",
      "summary": "**Astro plugins are used to extend Astro's functionality by integrating third-party plugins, such as Rollup plugins, to enable features like importing YAML data.** **Key features and APIs:** * `@rollup/plugin-yaml` plugin for importing YAML data * `defineConfig` function for configuring Astro plugins * `vite.plugins` array for adding plugins to the Vite build process * `import` statement for importing YAML data **Implementation details and use cases:** * Install `@rollup/plugin-yaml` using npm, pnpm, or yarn * Import the plugin in `astro.config.mjs` and add it to the Vite plugins array * Import YAML data using an `import` statement * Add type definitions for YAML data in a `*.d.ts` file to enable editor type hints",
      "url": "/en/recipes/add-yaml-support/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "installing",
        "vite",
        "rollup",
        "plugin"
      ],
      "type": "recipe"
    },
    {
      "id": "guides/internationalization",
      "language": "en",
      "title": "Internationalization (i18n) Routing",
      "summary": "**Astro components are designed to handle internationalization (i18n) routing for multi-language sites.** **Key features include:** * `getStaticPaths` API for generating URLs * `Astro.props` for accessing page props and verifying localized URLs * Support for configuring default language, relative page URLs, and preferred languages * Fallback languages for directing visitors to existing content * Middleware for implementing routing logic and verifying localized URLs **Implementation details include:** * Using a middleware function to implement routing logic * Specifying `locales` and `defaultLocale` in an `i18n` configuration object * Configuring routing and fallback behavior for desired URLs **Use cases include:** * Localizing site pages for international audiences * Generating and verifying URLs for multi-language sites * Implementing custom i18n logic using `astro:i18n` helper functions",
      "url": "/en/guides/internationalization/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "internationalization",
        "(i18n)",
        "routing"
      ],
      "type": "guide"
    },
    {
      "id": "reference/modules/astro-i18n",
      "language": "en",
      "title": "Internationalization API Reference",
      "summary": "**Internationalization API Reference** **Purpose:** Astro's Internationalization API provides functions to create URLs using project-configured locales, enabling i18n routing. **Key Features:** * `getRelativeLocaleUrl()`: Retrieves a relative path for a locale, throwing an error if the locale doesn't exist. * `getAbsoluteLocaleUrl()`: Returns an absolute URL for a locale. * `getPathByLocale()`: Retrieves a path based on a locale. * `getLocaleByPath()`: Retrieves a locale based on a path. * `redirectToDefaultLocale()`: Redirects to the default locale. * `redirectToFallback()`: Redirects to a fallback locale. * `notFound()`: Returns a 404 error. * `middleware()`: Provides a middleware function for i18n routing. * `requestHasLocale()`: Checks if a request has a locale. **Implementation Details:** * Functions take into account project configuration values, such as `base`, `trailingSlash`, `build.format`, and `site`. * Returned URLs reflect the `i18n.routing` configuration for the `defaultLocale`. * See the i18n routing guide for features and usage examples.",
      "url": "/en/reference/modules/astro-i18n/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "modules",
        "internationalization"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/invalid-component-args",
      "language": "en",
      "title": "Invalid component arguments.",
      "summary": "**Astro components are rendered using the component syntax `` or `{items.map(item => )}`, not via function calls like `Component()` or `{items.map(Component)}`. **Key features and APIs:** * InvalidComponentArgs error messages * Astro component syntax `` * Destructuring component props using `{items.map(item => )}` **Implementation details and use cases:** * Avoid manual rendering of Astro components using function calls * Use the component syntax for correct rendering and error prevention",
      "url": "/en/reference/errors/invalid-component-args/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "invalid",
        "component",
        "arguments."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/invalid-content-entry-slug-error",
      "language": "en",
      "title": "Invalid content entry slug.",
      "summary": "**Invalid Content Entry Slug Error** Astro components are unable to generate entry slugs due to an invalid `slug` field, which must be a string when present. This error is triggered by the `slug` field being set to a non-string value in a collection entry. The `slug` field is reserved for generating entry slugs and must conform to string type requirements.",
      "url": "/en/reference/errors/invalid-content-entry-slug-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "invalid",
        "entry",
        "slug."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/invalid-dynamic-route",
      "language": "en",
      "title": "Invalid dynamic route.",
      "summary": "**InvalidDynamicRoute**: The INVALID_PARAM param for route ROUTE is invalid. Received **RECEIVED**. A dynamic route param is invalid, often caused by an `undefined` parameter or a missing [rest parameter](/en/guides/routing/#rest-parameters). This error occurs when the `INVALID_PARAM` parameter for the `ROUTE` route is not valid.",
      "url": "/en/reference/errors/invalid-dynamic-route/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "invalid",
        "dynamic",
        "route."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/invalid-get-static-paths-entry",
      "language": "en",
      "title": "Invalid entry inside getStaticPaths return value",
      "summary": "**getStaticPaths Functionality** Astro components are designed to handle server-side rendering and static site generation, utilizing the `getStaticPaths` function to define static routes. This function returns an array of objects, where each object represents a static route with its associated parameters. **Key Features and APIs** * `getStaticPaths` returns an array of objects, where each object contains a `params` property with route parameters. * The function must return an array of objects, not an array of arrays. * Implementation details involve using array methods like `.flatMap()` or `.flat()` to flatten nested arrays. **Use Cases and Implementation** * Use `getStaticPaths` to define static routes for server-side rendering and static site generation. * Ensure the function returns an array of objects, not an array of arrays, to avoid errors. * Utilize array methods to flatten nested arrays and ensure correct output.",
      "url": "/en/reference/errors/invalid-get-static-paths-entry/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "invalid",
        "entry",
        "inside",
        "getstaticpaths"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/env-invalid-variable",
      "language": "en",
      "title": "Invalid Environment Variable",
      "summary": "**Invalid Environment Variable Error** `EnvInvalidVariable` error occurs when an environment variable does not match the data type and/or properties defined in `experimental.env.schema`. This error is triggered when the `KEY` does not match the expected `TYPE`. The error is deprecated and no longer in use in recent Astro versions.",
      "url": "/en/reference/errors/env-invalid-variable/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "invalid",
        "environment",
        "variable"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/env-invalid-variables",
      "language": "en",
      "title": "Invalid Environment Variables",
      "summary": "Astro environment variables validation detects and reports invalid environment variables defined in `env.schema`. Features include schema validation, data type checking, and property matching. APIs and methods involved are `env.schema` and error reporting. Implementation details involve comparing environment variable values against schema definitions, and use cases include detecting and fixing invalid environment variables in Astro projects.",
      "url": "/en/reference/errors/env-invalid-variables/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "invalid",
        "environment",
        "variables"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/invalid-frontmatter-injection-error",
      "language": "en",
      "title": "Invalid frontmatter injection.",
      "summary": "**InvalidFrontmatterInjectionError**: Astro components throw this error when a remark or rehype plugin attempts to inject invalid frontmatter, typically due to an invalid or missing \"astro.frontmatter\" JSON object. This occurs when \"astro.frontmatter\" is set to `null`, `undefined`, or an invalid JSON object. To resolve, ensure \"astro.frontmatter\" is a valid JSON object.",
      "url": "/en/reference/errors/invalid-frontmatter-injection-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "invalid",
        "frontmatter",
        "injection."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/invalid-glob",
      "language": "en",
      "title": "Invalid glob pattern.",
      "summary": "**InvalidGlob**: Astro encountered an invalid glob pattern, typically caused by a glob pattern not being a valid file path. The error occurs when a glob pattern does not start with './', '../' or '/', violating the required syntax. This issue is often resolved by correcting the glob pattern to conform to the specified format.",
      "url": "/en/reference/errors/invalid-glob/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "invalid",
        "glob",
        "pattern."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/invalid-prerender-export",
      "language": "en",
      "title": "Invalid prerender export.",
      "summary": "**Invalid Prerender Export** Astro components are restricted from using prerender exports with unsupported JavaScript syntax, such as variables, `let`, and `var` declarations. **Supported Syntax:** `export const prerender = true` is the only valid syntax for prerender exports, allowing Astro's compiler to statically analyze the directive at build time. **Implementation Details:** The `prerender` feature only supports a subset of valid JavaScript, and attempting to use unsupported syntax will result in an `InvalidPrerenderExport` error.",
      "url": "/en/reference/errors/invalid-prerender-export/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "invalid",
        "prerender",
        "export."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/reserved-slot-name",
      "language": "en",
      "title": "Invalid slot name.",
      "summary": "**Invalid Slot Name Error** Astro components are unable to create slots with reserved names due to internal usage conflicts. Specifically, the `getStaticPaths` method and `Astro.props` API are affected by this limitation, which can be resolved by updating the slot name to a non-reserved value. This error occurs when attempting to use a slot name that conflicts with internal Astro reserved names, such as `SLOT_NAME`.",
      "url": "/en/reference/errors/reserved-slot-name/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "invalid",
        "slot",
        "name."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/only-response-can-be-returned",
      "language": "en",
      "title": "Invalid type returned by Astro page.",
      "summary": "**Astro page return type validation** Astro components are restricted to returning only instances of `Response` from page files. This ensures correct handling of HTTP responses and redirects. The `return` statement in Astro files must be an instance of `Response`, created using the `new Response()` constructor or the `Astro.redirect()` method.",
      "url": "/en/reference/errors/only-response-can-be-returned/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "invalid",
        "type",
        "returned",
        "astro"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/get-entry-deprecation-error",
      "language": "en",
      "title": "Invalid use of getDataEntryById or getEntryBySlug function.",
      "summary": "**getEntry function is the recommended replacement for getDataEntryById and getEntryBySlug functions.** The `getEntry` function is a replacement for the deprecated `getDataEntryById` and `getEntryBySlug` functions, allowing for querying content layer collections. This function is part of the Astro API and can be used to retrieve entries by ID or slug.",
      "url": "/en/reference/errors/get-entry-deprecation-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "invalid",
        "getdataentrybyid",
        "getentrybyslug",
        "function."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/get-static-paths-invalid-route-param",
      "language": "en",
      "title": "Invalid value for getStaticPaths route parameter.",
      "summary": "**getStaticPaths Route Parameter Validation** Astro components are validated for invalid route parameters in `getStaticPaths` function calls, ensuring only supported types (undefined, string, or number) are used for `params` values. The `getStaticPaths` function returns an array of objects with `params` properties, which are encoded into the URL. Only certain types are supported as values, and using unsupported types (e.g., boolean) will result in an error.",
      "url": "/en/reference/errors/get-static-paths-invalid-route-param/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "invalid",
        "value",
        "getstaticpaths",
        "route"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/invalid-get-static-path-param",
      "language": "en",
      "title": "Invalid value returned by a getStaticPaths path.",
      "summary": "**Invalid value returned by a getStaticPaths path.** Astro components are affected when `getStaticPaths` returns an array of objects with an invalid `params` property type. Specifically, the `params` property should be an object, but an invalid `PARAM_TYPE` was provided. This issue is resolved by ensuring the `params` property is an object, as demonstrated in the example code for `pages/blog/[id].astro`.",
      "url": "/en/reference/errors/invalid-get-static-path-param/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "invalid",
        "value",
        "returned",
        "getstaticpaths"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/invalid-get-static-paths-return",
      "language": "en",
      "title": "Invalid value returned by getStaticPaths.",
      "summary": "**getStaticPaths Functionality** Astro components are designed to handle server-side rendering and static site generation, with `getStaticPaths` being a crucial method for pre-rendering pages at build time. This method returns an array of objects, where each object contains a `params` property, which is used to define the routes for a page. The `getStaticPaths` function must return an array of objects, as shown in the example below: ```ts export async function getStaticPaths() { return [ { params: { slug: \"blog\" } }, { params: { slug: \"about\" } } ]; } ``` **Implementation Details and Use Cases** `getStaticPaths` is used to define the routes for a page, allowing Astro to pre-render the page at build time. This method is critical for static site generation and server-side rendering, enabling fast and efficient page loading.",
      "url": "/en/reference/errors/invalid-get-static-paths-return/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "invalid",
        "value",
        "returned",
        "getstaticpaths."
      ],
      "type": "guide"
    },
    {
      "id": "concepts/islands",
      "language": "en",
      "title": "Islands architecture",
      "summary": "**Islands Architecture** Astro components are designed to implement Islands Architecture, a frontend pattern that renders static HTML with smaller \"islands\" of JavaScript added for interactivity or personalization. This approach avoids monolithic JavaScript payloads, improving page responsiveness. Key features include selective hydration, partial rendering, and strategic injection of dynamic regions. **Key APIs and Methods** * `getStaticPaths`: enables server-side rendering and static site generation * `Astro.props`: allows for dynamic data injection into components * `IslandsDiagram` and `ReadMore` components: demonstrate implementation of Islands Architecture **Implementation Details and Use Cases** Islands Architecture is particularly useful for projects requiring fast page loads and strategic hydration of dynamic regions, such as image carousels or interactive widgets. By leveraging selective hydration and partial rendering, developers can create high-performance web applications with Astro.",
      "url": "/en/concepts/islands/",
      "keywords": [
        "content",
        "docs",
        "concepts",
        "islands",
        "architecture"
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/keystatic",
      "language": "en",
      "title": "Keystatic & Astro",
      "summary": "**Keystatic & Astro Integration** Keystatic & Astro components are designed to enable content management and synchronization with GitHub in Astro projects. Key features include: * Integration with Markdoc for content entries and React for the Keystatic Admin UI Dashboard * Support for `getStaticPaths` and Astro.props APIs * Implementation details include installing dependencies using `astro add` and `npm install`/`pnpm add` commands * Use cases include deploying Keystatic & Astro projects and syncing data with GitHub using `write` permissions.",
      "url": "/en/guides/cms/keystatic/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "keystatic",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/cms/keystonejs",
      "language": "en",
      "title": "KeystoneJS & Astro",
      "summary": "KeystoneJS & Astro integrates KeystoneJS as a headless CMS to manage content in Astro projects, enabling schema-driven content modeling and API-first content delivery. Key features include: * KeystoneJS schema definition for content modeling * Astro.props API for accessing KeystoneJS data * getStaticPaths method for server-side rendering and SEO optimization * Internationalization support for multilingual content management Implementation details involve setting up KeystoneJS as a CMS, defining a schema, and integrating it with Astro using the Astro.props API, while use cases include building dynamic, data-driven websites and applications with KeystoneJS-managed content.",
      "url": "/en/guides/cms/keystonejs/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "keystonejs",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/cms/kontent-ai",
      "language": "en",
      "title": "Kontent.ai & Astro",
      "summary": "**Kontent.ai & Astro Integration** Kontent.ai & Astro components are used to add content to Astro projects using Kontent.ai as a headless CMS, enabling structured and modular content management with AI capabilities. **Key Features:** * Connect Astro with Kontent.ai using the Kontent.ai TypeScript SDK * Use environment variables (KONTENT_ENVIRONMENT_ID, KONTENT_PREVIEW_API_KEY) to authenticate with Kontent.ai * Leverage TypeScript IntelliSense for environment variables using `ImportMetaEnv` interface **Implementation Details:** * Create a `.env` file with Kontent.ai credentials (Environment ID, Preview API key) * Configure `env.d.ts` file for TypeScript IntelliSense * Install Kontent.ai TypeScript SDK using npm or yarn **Use Cases:** * Manage content in a structured and modular way using Kontent.ai * Use AI capabilities to enhance content management and delivery * Integrate Kontent.ai with Astro for seamless content delivery",
      "url": "/en/guides/cms/kontent-ai/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "kontent.ai",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "basics/layouts",
      "language": "en",
      "title": "Layouts",
      "summary": "**Layouts** are Astro components used to provide a reusable UI structure, such as a page template, and typically include a page shell (``, `` and `` tags) and a `` to specify where individual page content should be injected. Layout components can accept props, import and use other components, include UI frameworks components and client-side scripts, and do not require a full page shell. They must have their `` element as the parent of all other elements if they contain a page shell. Key features and APIs include `Astro.props`, ``, and the ability to use UI frameworks components and client-side scripts.",
      "url": "/en/basics/layouts/",
      "keywords": [
        "content",
        "docs",
        "basics",
        "layouts"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/config-legacy-key",
      "language": "en",
      "title": "Legacy configuration detected.",
      "summary": "**Legacy Configuration Detection** Astro components are designed to detect and handle legacy configuration options in configuration files, alerting developers to potential issues through the `DontEditWarning` component. Key features include the `ConfigLegacyKey` variable, which outputs a warning message when a legacy configuration option is detected, and the `DontEditWarning` component, which can be used to display this warning to users. Implementation details involve checking for legacy configuration options in configuration files and displaying a warning message when necessary. Use cases include ensuring compatibility with outdated configuration files and providing clear feedback to developers about potential issues.",
      "url": "/en/reference/errors/config-legacy-key/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "legacy",
        "configuration",
        "detected."
      ],
      "type": "guide"
    },
    {
      "id": "reference/legacy-flags",
      "language": "en",
      "title": "Legacy flags",
      "summary": "**Legacy Flags** Legacy flags allow users to opt-in to deprecated or outdated behavior in Astro, enabling them to upgrade to new releases while maintaining compatibility with existing project code. **Features and APIs** * `legacy.collections`: a boolean flag (default: `false`) enabling legacy behavior for content collections (as used in Astro v2 through v4) * `astro.config.mjs` configuration option to enable legacy collections * `defineConfig` method to configure legacy behavior * `defineCollection` method to define collections for legacy collections **Implementation Details and Use Cases** * Enables legacy content collections implementation for `data` and `content` collections * Collections with a `loader` continue to use the Content Layer API * Legacy collections must be located in `src/content/` directory * Collections using the Content Layer API are forbidden in `src/content/` but may exist elsewhere * Defining an empty collection in `src/content/config.ts` implicitly generates a definition for legacy collections",
      "url": "/en/reference/legacy-flags/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "legacy",
        "flags"
      ],
      "type": "guide"
    },
    {
      "id": "guides/upgrade-to/v1",
      "language": "en",
      "title": "Legacy v0.x Upgrade Guide",
      "summary": "**Legacy v0.x Upgrade Guide** Astro components are designed to be upgraded through breaking changes in pre-v1 versions of Astro. **Key Features and APIs:** * `Astro.props` and `Astro.url` helpers for constructing canonical URLs * `Astro.url` helper for accessing the current page/request URL * `Vite 3` upgrade with potential changes in subtle Vite behaviors * `Astro.canonicalURL` deprecated in favor of `Astro.url` * Scoped CSS specificity changes **Implementation Details and Use Cases:** * Update Astro and integrations to the latest version using package managers (npm, pnpm, yarn) * Handle breaking changes in Vite 3 and Astro v1.0 * Use `Astro.url` helper to construct canonical URLs * Update CSS specificity to account for changes in scoped CSS behavior",
      "url": "/en/guides/upgrade-to/v1/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "upgrade to",
        "legacy",
        "v0.x",
        "upgrade",
        "guide"
      ],
      "type": "guide"
    },
    {
      "id": "guides/integrations-guide/lit",
      "language": "en",
      "title": "Lit",
      "summary": "Lit components are custom elements that can be used in Astro projects for on-demand rendering and client-side hydration. Key features include support for Lit's `render` method and access to Astro's `props` and `context` APIs through `Astro.props` and `Astro.context`. Implementation involves adding a client-side script tag to import Lit components, such as `...`.",
      "url": "/en/guides/integrations-guide/lit/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "integrations guide"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/local-image-used-wrongly",
      "language": "en",
      "title": "Local images must be imported.",
      "summary": "**Local Images Must Be Imported** Local images must be imported using the `import` statement or a URL, and cannot be referenced by a string filepath. This applies to `Image` and `getImage` components, which require a full image object or URL as the `src` parameter. Use the `image()` schema helper for local images from content collections to resolve images correctly.",
      "url": "/en/reference/errors/local-image-used-wrongly/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "local",
        "images",
        "must",
        "imported."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/locals-reassigned",
      "language": "en",
      "title": "locals must not be reassigned.",
      "summary": "**LocalsReassigned Error** Locals must not be reassigned, as it throws an error when a value is set as the `locals` field on the Astro global or context. This error is triggered by attempting to directly assign a value to `locals`, which is a critical restriction in Astro. The `LocalsReassigned` error is typically resolved by using the `Astro.props` API to manage local variables instead of reassigning `locals`.",
      "url": "/en/reference/errors/locals-reassigned/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "locals",
        "must",
        "reassigned."
      ],
      "type": "guide"
    },
    {
      "id": "tutorial/3-components/1",
      "language": "en",
      "title": "Make a reusable Navigation component",
      "summary": "**Reusable Navigation Component** Astro components are used to create reusable UI components that can be easily imported and used across multiple pages. **Key Features and APIs** * `Navigation.astro` file: a reusable Astro component that displays navigation links * `import` statement: imports the `Navigation` component into other Astro files * `use` statement: replaces existing navigation HTML with the new reusable component **Implementation Details and Use Cases** * Create a new `src/components/` folder to hold reusable Astro components * Create a new file `Navigation.astro` to define the navigation component * Import and use the `Navigation` component in other Astro files to replace duplicated navigation HTML * Use Astro's `import` and `use` statements to manage component dependencies and usage.",
      "url": "/en/tutorial/3-components/1/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "3 components",
        "make",
        "reusable",
        "navigation",
        "component"
      ],
      "type": "tutorial"
    },
    {
      "id": "guides/markdown-content",
      "language": "en",
      "title": "Markdown in Astro",
      "summary": "**Markdown in Astro** Astro components are designed to render Markdown files with frontmatter YAML or TOML properties, enabling content authors to write text-heavy content like blog posts and documentation. Key features include: * Support for GitHub Flavored Markdown * Frontmatter YAML or TOML properties for custom metadata * Local file imports using `import` statements or `import.meta.glob()` * Content collections queries for fetching and rendering Markdown data Implementation details include organizing Markdown files within the `src/` directory, with automatic page generation for files in `src/pages/`. Use cases include importing Markdown content into `.astro` components or querying and rendering data from content collections helper functions.",
      "url": "/en/guides/markdown-content/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "markdown",
        "astro"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/mdx-integration-missing-error",
      "language": "en",
      "title": "MDX integration missing.",
      "summary": "**Astro components are unable to render MDX files without the `@astrojs/mdx` integration installed.** **Key features and APIs:** * `@astrojs/mdx` integration required for MDX file rendering * `MdxIntegrationMissingError` raised when integration is not installed * `getStaticPaths` and `Astro.props` methods not applicable in this context **Implementation details and use cases:** * Ensure installation of `@astrojs/mdx` integration for MDX file rendering * Refer to [MDX installation and usage](/en/guides/integrations-guide/mdx/) for setup instructions * Critical error occurs when using MDX files without integration installed",
      "url": "/en/reference/errors/mdx-integration-missing-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "integration",
        "missing."
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/microcms",
      "language": "en",
      "title": "microCMS & Astro",
      "summary": "**microCMS & Astro Integration** microCMS & Astro are designed to enable seamless content management and rendering in Astro projects, leveraging microCMS's API-based headless CMS capabilities. Key features include: * **Content schema definition**: Define content structures using microCMS schemas, enabling flexible data modeling and management. * **API-based content retrieval**: Utilize microCMS's API to fetch and render content in Astro components, supporting internationalization and localization. * **Astro.props and getStaticPaths integration**: Leverage Astro's built-in props and getStaticPaths functionality to optimize content rendering and improve SEO. Implementation details and use cases include: * **Content management**: Manage content using microCMS's dashboard, and retrieve it in Astro components using API calls. * **Internationalization**: Support multiple languages and regions using microCMS's built-in internationalization features. * **SEO optimization**: Improve search engine rankings by leveraging Astro's getStaticPaths and microCMS's API-based content retrieval.",
      "url": "/en/guides/cms/microcms/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "microcms",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/middleware",
      "language": "en",
      "title": "Middleware",
      "summary": "**Middleware** allows you to intercept requests and responses and inject behaviors dynamically every time a page or endpoint is about to be rendered, utilizing features like cookies and headers for SSR. Middleware enables setting and sharing request-specific information across endpoints and pages by mutating a `locals` object available in all Astro components and API endpoints. This object is accessible even at build time, allowing for dynamic behavior injection and data sharing.",
      "url": "/en/guides/middleware/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "middleware"
      ],
      "type": "guide"
    },
    {
      "id": "reference/modules/astro-middleware",
      "language": "en",
      "title": "Middleware API Reference",
      "summary": "**Middleware API Reference** Middleware allows you to intercept requests and responses and inject behaviors dynamically every time a page or endpoint is about to be rendered. The Astro middleware API provides several utility functions for creating and managing middleware, including `defineMiddleware()`, `sequence()`, `createContext()`, and `trySerializeLocals()`. **Key Features and APIs:** * `defineMiddleware()`: A utility function for creating middleware with type safety. * `sequence()`: A function that executes middleware functions in the order they are passed. * `createContext()`: A low-level API for creating an `APIContext` to be passed to an Astro middleware `onRequest()` function. * `trySerializeLocals()`: A low-level API for serializing values to strings. **Implementation Details and Use Cases:** * Use `defineMiddleware()` to create middleware with type safety. * Utilize `sequence()` to execute multiple middleware functions in a specific order. * Employ `createContext()` for programmatically executing Astro middleware. * Leverage `trySerializeLocals()` for serializing values to strings.",
      "url": "/en/reference/modules/astro-middleware/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "modules",
        "middleware"
      ],
      "type": "guide"
    },
    {
      "id": "guides/migrate-to-astro/index",
      "language": "en",
      "title": "Migrate an existing project to Astro",
      "summary": "**Astro components are a set of reusable UI elements that can be used to build fast, scalable, and maintainable web applications.** **Key features include:** * Support for UI framework components, CSS stylesheets, and Markdown/MDX files * Integration with popular headless CMSes and eCommerce shop carts * Complete control over project rendering with on-demand rendering capabilities * Astro Islands for efficient rendering of complex UI components **Implementation details and use cases:** * Use Astro's official and community integrations to extend your site * Leverage Astro's simplicity and performance benefits for content-based sites like blogs, landing pages, and portfolios * Take advantage of Astro's flexibility to build fully statically-generated websites, dynamic apps, or a combination of both.",
      "url": "/en/guides/migrate-to-astro/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "migrate to astro",
        "migrate",
        "existing",
        "project",
        "astro"
      ],
      "type": "guide"
    },
    {
      "id": "guides/migrate-to-astro/from-create-react-app",
      "language": "en",
      "title": "Migrating from Create React App (CRA)",
      "summary": "**Migrating from Create React App (CRA) to Astro** Astro components are designed to integrate seamlessly with React components, allowing for a smooth migration of existing Create React App (CRA) projects. Key features include support for using React components inside Astro components, including entire React apps, and file-based routing with dynamic routes. Astro's syntax is similar to JSX, making it easy to transition from CRA to Astro.",
      "url": "/en/guides/migrate-to-astro/from-create-react-app/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "migrate to astro",
        "migration",
        "migrating",
        "from",
        "create"
      ],
      "type": "migration"
    },
    {
      "id": "guides/migrate-to-astro/from-docusaurus",
      "language": "en",
      "title": "Migrating from Docusaurus",
      "summary": "**Migrating from Docusaurus to Astro** Astro components are modern, JavaScript-based site builders for content-driven websites, similar to Docusaurus, supporting MDX pages, file-based routing, and React components with JSX-like syntax. Key features include Astro.props, getStaticPaths, and Astro's JSX-like syntax, allowing for a seamless migration of existing Docusaurus projects. Astro also supports installing NPM packages, including React dependencies, and has official integrations for various frameworks, including React, Preact, and Vue.js.",
      "url": "/en/guides/migrate-to-astro/from-docusaurus/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "migrate to astro",
        "migration",
        "migrating",
        "from",
        "docusaurus"
      ],
      "type": "migration"
    },
    {
      "id": "guides/migrate-to-astro/from-eleventy",
      "language": "en",
      "title": "Migrating from Eleventy",
      "summary": "**Migrating from Eleventy** Astro components are modern, JavaScript-based (Jamstack) site builders that allow using headless CMS, APIs, or Markdown files for data, similar to Eleventy. Key differences include Astro's support for including components from popular JS frameworks and its use of Astro layouts, pages, and components for page templating, as well as its `src/` directory for querying and processing site metadata and a `public/` folder for static assets. Astro handles bundling CSS, JavaScript, and other assets out-of-the-box, eliminating the need for manual configuration.",
      "url": "/en/guides/migrate-to-astro/from-eleventy/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "migrate to astro",
        "migration",
        "migrating",
        "from",
        "eleventy"
      ],
      "type": "migration"
    },
    {
      "id": "guides/migrate-to-astro/from-gatsby",
      "language": "en",
      "title": "Migrating from Gatsby",
      "summary": "**Migrating from Gatsby** Astro components are similar to Gatsby's JSX syntax, with built-in support for Markdown, MDX, and React components, and the ability to install NPM packages, including React libraries. Key differences include Astro's multi-page site structure, use of code fences for JavaScript and HTML, and ESM imports for local file data. Astro projects can be SSG or SSR with page-level prerendering, similar to Gatsby.",
      "url": "/en/guides/migrate-to-astro/from-gatsby/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "migrate to astro",
        "migration",
        "migrating",
        "from",
        "gatsby"
      ],
      "type": "migration"
    },
    {
      "id": "guides/migrate-to-astro/from-gitbook",
      "language": "en",
      "title": "Migrating from GitBook",
      "summary": "**Migrating from GitBook to Astro** Astro components are a replacement for GitBook's online dashboard, utilizing a code editor and development environment for site maintenance. Key features include Astro.props, getStaticPaths, and support for Markdown and file-based routing. Astro's project directory structure and optional Markdoc integration provide a similar syntax to GitBook's custom syntax, enabling a seamless migration of existing content.",
      "url": "/en/guides/migrate-to-astro/from-gitbook/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "migrate to astro",
        "migration",
        "migrating",
        "from",
        "gitbook"
      ],
      "type": "migration"
    },
    {
      "id": "guides/migrate-to-astro/from-gridsome",
      "language": "en",
      "title": "Migrating from Gridsome",
      "summary": "**Migrating from Gridsome** Astro components are modern, reusable UI components that can be used to build static sites, similar to Gridsome. Key similarities include project file structures, Vue component support, and NPM package installation. Astro also supports file-based routing, headless CMS, APIs, and Markdown files for data. **Key Features and APIs** * `.astro` components for building multi-page apps * Support for Vue, React, Preact, Svelte, SolidJS, AlpineJS, and raw HTML templating * `getStaticPaths` for server-side rendering and SEO optimization * `Astro.props` for accessing component props and metadata * Layout components for controlling page `` and layout **Implementation Details and Use Cases** * Use Astro's official Vue integration to reuse existing Vue components and dependencies * Migrate Gridsome's Vue-based SPA routing to Astro's file-based routing * Utilize Astro's layout components to manage page `` and layout * Leverage Astro's support for headless CMS, APIs, and Markdown files for data",
      "url": "/en/guides/migrate-to-astro/from-gridsome/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "migrate to astro",
        "migration",
        "migrating",
        "from",
        "gridsome"
      ],
      "type": "migration"
    },
    {
      "id": "guides/migrate-to-astro/from-hugo",
      "language": "en",
      "title": "Migrating from Hugo",
      "summary": "**Migrating from Hugo to Astro** Astro components are a superset of HTML, utilizing JSX-like syntax for page templating, whereas Hugo uses Go Templating. Key similarities include content-driven website support, Markdown content authoring, and integration with external packages. Astro introduces a component-based architecture, replacing Hugo's partials and shortcodes with Astro's MDX integration and UI framework component support.",
      "url": "/en/guides/migrate-to-astro/from-hugo/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "migrate to astro",
        "migration",
        "migrating",
        "from",
        "hugo"
      ],
      "type": "migration"
    },
    {
      "id": "guides/migrate-to-astro/from-jekyll",
      "language": "en",
      "title": "Migrating from Jekyll",
      "summary": "**Migrating from Jekyll** Astro components are a replacement for Jekyll's Liquid templates, using JSX-like `.astro` files for templating and components. Key features include Astro.props, Astro components, and file-based routing, similar to Jekyll's `_posts/` directory. Astro provides a `src/pages/` directory for all pages and posts, and supports Markdown and HTML content, with special frontmatter YAML properties for page layout and unpublished draft posts.",
      "url": "/en/guides/migrate-to-astro/from-jekyll/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "migrate to astro",
        "migration",
        "migrating",
        "from",
        "jekyll"
      ],
      "type": "migration"
    },
    {
      "id": "guides/migrate-to-astro/from-nextjs",
      "language": "en",
      "title": "Migrating from Next.js",
      "summary": "**Astro components are a set of reusable UI components that can be used to build fast, scalable, and secure websites and applications.** **Key features include:** * `.astro` file syntax similar to JSX * Support for SSG and SSR with page-level prerendering * File-based routing with dynamic routes * Component-based architecture with official integrations for React, Preact, and Solid * Support for installing NPM packages, including React libraries **Implementation details and use cases:** * Split code into \"code fence\" for JavaScript and HTML body * Use `.jsx` or `.tsx` extension for JSX components * Utilize Astro's built-in features for internationalization and accessibility * Leverage Astro's support for NPM packages and integrations with popular frameworks and libraries.",
      "url": "/en/guides/migrate-to-astro/from-nextjs/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "migrate to astro",
        "migration",
        "migrating",
        "from",
        "next.js"
      ],
      "type": "migration"
    },
    {
      "id": "guides/migrate-to-astro/from-nuxtjs",
      "language": "en",
      "title": "Migrating from NuxtJS",
      "summary": "**Migrating from NuxtJS** Astro components are a replacement for NuxtJS, offering a similar component-based structure and file-based routing. Key features include support for Vue components, dynamic routes, and on-demand rendering with page-level prerendering. Astro integrates with Vue libraries and allows installing NPM packages, enabling the reuse of existing Vue components and dependencies.",
      "url": "/en/guides/migrate-to-astro/from-nuxtjs/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "migrate to astro",
        "migration",
        "migrating",
        "from",
        "nuxtjs"
      ],
      "type": "migration"
    },
    {
      "id": "guides/migrate-to-astro/from-pelican",
      "language": "en",
      "title": "Migrating from Pelican",
      "summary": "**Migrating from Pelican to Astro** Astro components are a superset of HTML, using JSX-like syntax for templating, whereas Pelican uses HTML files and Jinja syntax. Astro supports creating pages from Markdown and MDX files, whereas Pelican supports Markdown and reStructured Text. Key APIs and methods for migration include Astro.props, getStaticPaths, and Astro syntax. **Implementation Details and Use Cases** * Use Astro.props to access page metadata and frontmatter values. * Utilize getStaticPaths to generate static paths for pages. * Leverage Astro syntax to create reusable components and templates. * Explore official themes, such as Starlight docs theme starter template, and community themes in the Astro theme showcase. * Pass a `--template` argument to the Astro CLI to customize the build process.",
      "url": "/en/guides/migrate-to-astro/from-pelican/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "migrate to astro",
        "migration",
        "migrating",
        "from",
        "pelican"
      ],
      "type": "migration"
    },
    {
      "id": "guides/migrate-to-astro/from-sveltekit",
      "language": "en",
      "title": "Migrating from SvelteKit",
      "summary": "**Astro components are a set of reusable UI components for building web applications, similar to SvelteKit components, but with support for multiple frameworks including React, Preact, Vue.js, Svelte, SolidJS, AlpineJS, and raw HTML templating.** **Key features include Astro.props, Astro.components, and getStaticPaths, allowing for dynamic data fetching and server-side rendering.** **Implementation details involve migrating existing SvelteKit components to Astro components, leveraging Astro's official Svelte integration and NPM package support, while adapting to Astro's multi-page app architecture and component model.**",
      "url": "/en/guides/migrate-to-astro/from-sveltekit/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "migrate to astro",
        "migration",
        "migrating",
        "from",
        "sveltekit"
      ],
      "type": "migration"
    },
    {
      "id": "guides/migrate-to-astro/from-vuepress",
      "language": "en",
      "title": "Migrating from VuePress",
      "summary": "**Astro components are modern, reusable UI components for building static websites and web applications, similar to VuePress components.** **Key features include:** * Support for file-based routing in the `src/pages/` folder * Built-in support for Markdown files and content-driven websites * Official integration for using Vue components and support for installing NPM packages * `.astro` components for building multi-page apps, with support for various frameworks and raw HTML templating * Layout templates using Astro components, including HTML templating for pages, layouts, and individual UI elements **Implementation details and use cases:** * Migrate existing VuePress projects to Astro by leveraging similarities in project file structures and Markdown support * Use Astro components to build reusable UI elements and layouts, and integrate with various frameworks and libraries * Take advantage of Astro's support for NPM packages and official Vue integration to reuse existing Vue components and dependencies.",
      "url": "/en/guides/migrate-to-astro/from-vuepress/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "migrate to astro",
        "migration",
        "migrating",
        "from",
        "vuepress"
      ],
      "type": "migration"
    },
    {
      "id": "guides/migrate-to-astro/from-wordpress",
      "language": "en",
      "title": "Migrating from WordPress",
      "summary": "**Migrating from WordPress** Astro components are a collection of reusable UI components that can be used to build web applications, similar to WordPress's use of plugins and themes. Key features include Astro.props, Astro.components, and getStaticPaths, which allow for dynamic rendering and server-side rendering of components. Astro also supports Markdown content, similar to WordPress, and encourages a block-based design approach, where individual components are used to build the site. Implementation details include using a code editor and development environment to maintain the site, and leveraging Astro's integrations and themes to build the site, rather than relying on WordPress's extensive plugin and theme market.",
      "url": "/en/guides/migrate-to-astro/from-wordpress/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "migrate to astro",
        "migration",
        "migrating",
        "from",
        "wordpress"
      ],
      "type": "migration"
    },
    {
      "id": "reference/errors/no-client-only-hint",
      "language": "en",
      "title": "Missing hint on client:only directive.",
      "summary": "**Astro components are rendered with client-side only directive, requiring a hint to use the correct renderer.** **Key features and APIs:** * `client:only` directive for server-side rendering * `client:only` hint required for correct renderer usage * `client:only` directive usage: `` **Implementation details and use cases:** * `client:only` components are not run on the server, requiring a hint for correct renderer usage * Use `client:only` hint to specify the correct renderer for client-side only components * See also: [`client:only`](/en/reference/directives-reference/#clientonly)",
      "url": "/en/reference/errors/no-client-only-hint/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "missing",
        "hint",
        "client:only",
        "directive."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/missing-image-dimension",
      "language": "en",
      "title": "Missing image dimensions",
      "summary": "Astro components require explicit width and height attributes for remote images to avoid cumulative layout shift (CLS). This can be achieved by specifying the width and height properties or setting `inferSize` to `true` to fetch the original dimensions. The `width` and `height` attributes are required for images in the public folder, and can be inferred for local images using the `inferSize` option.",
      "url": "/en/reference/errors/missing-image-dimension/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "missing",
        "image",
        "dimensions"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/get-static-paths-expected-params",
      "language": "en",
      "title": "Missing params property on getStaticPaths route.",
      "summary": "**Astro components are designed to handle server-side rendering and static site generation, but require a `params` property on `getStaticPaths` routes to specify path parameters.** **Key features and APIs include:** * `getStaticPaths` method to generate static routes * `params` property to specify path parameters * Implementation details involve specifying required `params` property for each route in `getStaticPaths` array * Use cases include creating routes with dynamic path parameters, such as `site.com/blog/1` **Technical keywords:** Astro, server-side rendering, static site generation, getStaticPaths, params property, path parameters.",
      "url": "/en/reference/errors/get-static-paths-expected-params/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "missing",
        "params",
        "property",
        "getstaticpaths"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/missing-media-query-directive",
      "language": "en",
      "title": "Missing value for client:media directive.",
      "summary": "**Missing value for client:media directive.** The `client:media` directive requires a media query parameter, such as `client:media=\"(max-width: 600px)\"`, to be provided. This parameter is used to specify a media query condition, similar to CSS media queries, to determine when the directive should be applied. The `client:media` directive is used in Astro components, and its usage is documented in the Astro reference documentation.",
      "url": "/en/reference/errors/missing-media-query-directive/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "missing",
        "value",
        "client:media",
        "directive."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/server-only-module",
      "language": "en",
      "title": "Module is only available server-side",
      "summary": "**ServerOnlyModule**: The \"NAME\" module is only available server-side, utilizing Astro's server-side rendering capabilities. It leverages the `ServerOnlyModule` component, which is only rendered on the server, and can be used to implement server-side logic, such as data fetching and API calls. This module can be used in conjunction with Astro's `getStaticPaths` and `Astro.props` APIs to optimize server-side rendering and improve performance.",
      "url": "/en/reference/errors/server-only-module/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "module",
        "only",
        "available",
        "server-side"
      ],
      "type": "guide"
    },
    {
      "id": "guides/backend/sentry",
      "language": "en",
      "title": "Monitor your Astro Site with Sentry",
      "summary": "**Astro components are integrated with Sentry for comprehensive application monitoring and error tracking.** **Key features and APIs include:** * Automatic error reporting and tracing data collection using the Sentry SDK * Integration with Astro CLI for easy installation and configuration * Support for various package managers (npm, pnpm, yarn) * Configuration options for client key (DSN), project name, and auth token **Implementation details and use cases:** * Install the Sentry SDK using the Astro CLI with `npx astro add @sentry/astro` * Configure the Sentry integration in `astro.config.mjs` with client key (DSN), project name, and auth token * Use Sentry's Spotlight dev toolbar app for real-time error tracking and debugging during local development",
      "url": "/en/guides/backend/sentry/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "backend",
        "monitor",
        "your",
        "astro",
        "site"
      ],
      "type": "backend"
    },
    {
      "id": "guides/backend/neon",
      "language": "en",
      "title": "Neon Postgres & Astro",
      "summary": "**Neon Postgres & Astro Integration** **Purpose:** Astro components are integrated with Neon Postgres to enable serverless Postgres database functionality. **Key Features:** * **Environment Configuration:** Set a Neon environment variable in the `.env` file using the `NEON_DATABASE_URL` key. * **Dependency Installation:** Install the `@neondatabase/serverless` package to connect to Neon. * **Neon Client Creation:** Initialize the Neon client in a `src/lib/neon.ts` file using the `neon` function from `@neondatabase/serverless`. * **Querying the Database:** Use the Neon client to query the database from any `.astro` component. **Implementation Details:** * Use the `sql` function from the `neon` client to execute SQL queries. * Define environment variables in a `src/env.d.ts` file for better TypeScript support. **Use Cases:** * Fetch data from the Postgres database using the Neon client. * Execute SQL queries from any `.astro` component.",
      "url": "/en/guides/backend/neon/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "backend",
        "neon",
        "postgres",
        "astro"
      ],
      "type": "backend"
    },
    {
      "id": "reference/errors/no-client-entrypoint",
      "language": "en",
      "title": "No client entrypoint specified in renderer.",
      "summary": "**Astro components are rendered with client-side directives, but require a client entrypoint to hydrate.** **Features and APIs:** * `client:CLIENT_DIRECTIVE` directive * `RENDERER_NAME` renderer * `addRenderer` option * `getStaticPaths` method * `Astro.props` API **Implementation details and use cases:** * Hydrating framework components requires a client entrypoint * Use `addRenderer` option to specify a client entrypoint * See also [Hydrating framework components](/en/guides/framework-components/#hydrating-interactive-components) and [addRenderer option](/en/reference/integrations-reference/#addrenderer-option)",
      "url": "/en/reference/errors/no-client-entrypoint/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "client",
        "entrypoint",
        "specified",
        "renderer."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/no-matching-import",
      "language": "en",
      "title": "No import found for component.",
      "summary": "**Astro components are rendered with dynamic imports, but require explicit import statements to avoid NoMatchingImport errors.** **Key features and APIs:** * `import` statements are required for component usage * `NoMatchingImport` error occurs when import statement is missing or mismatched * `COMPONENT_NAME` is the identifier used in the import statement and component usage **Implementation details and use cases:** * Ensure import statements are correctly written and match the component usage * Use the same identifier for import statements and component usage to avoid errors * Implement dynamic imports for Astro components to enable rendering.",
      "url": "/en/reference/errors/no-matching-import/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "import",
        "found",
        "component."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/no-matching-renderer",
      "language": "en",
      "title": "No matching renderer found.",
      "summary": "**Astro Error Handling: No Matching Renderer Found** Astro components are unable to render when no compatible renderer is installed for the imported component type. This error occurs when none of the configured renderers in `astro.config.mjs` can server-side render the imported component. The error is resolved by installing the appropriate integration for the component type, such as `@astrojs/react` for JSX/TSX files or `@astrojs/vue` for Vue files.",
      "url": "/en/reference/errors/no-matching-renderer/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "matching",
        "renderer",
        "found."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/no-matching-static-path-found",
      "language": "en",
      "title": "No static path found for requested path.",
      "summary": "**Astro error handling components are used to display informative messages to users when a dynamic route is matched but no corresponding path is found.** **Features and APIs:** * `getStaticPaths()` route pattern matching * Error handling for dynamic routes * Integration with Astro's routing system **Implementation details and use cases:** * Displays a warning message when a dynamic route is matched but no path is found * Useful for debugging and troubleshooting routing issues * Can be customized to display different messages or error codes **Technical keywords:** Astro, error handling, dynamic routes, getStaticPaths, routing system.",
      "url": "/en/reference/errors/no-matching-static-path-found/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "static",
        "path",
        "found",
        "requested"
      ],
      "type": "guide"
    },
    {
      "id": "guides/on-demand-rendering",
      "language": "en",
      "title": "On-demand rendering",
      "summary": "**On-demand rendering** Astro components are rendered on demand by a server when a route is requested, generating per-visit, customizable pages and routes. Key features include server-side rendering (SSR), adapter support for various runtimes (e.g., Netlify, Cloudflare), and official adapters for Node.js, Netlify, Vercel, and Cloudflare. Implementation details involve adding an adapter to enable on-demand rendering, with use cases including displaying logged-in user information and updating data without a full-site rebuild.",
      "url": "/en/guides/on-demand-rendering/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "on-demand",
        "rendering"
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/optimizely",
      "language": "en",
      "title": "Optimizely CMS & Astro",
      "summary": "Optimizely CMS & Astro integrates headless CMS functionality with Astro components, enabling content management and rendering of Optimizely CMS data in Astro applications using GraphQL APIs and Astro.props. Key features include support for getStaticPaths, Astro.props, and internationalization, with implementation details and use cases demonstrated in official resources and community examples. This integration allows developers to leverage Optimizely CMS's visual editor and build headless applications with Astro.",
      "url": "/en/guides/cms/optimizely/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "optimizely",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "tutorial/6-islands/4",
      "language": "en",
      "title": "Optional: Make a content collection",
      "summary": "**Astro content collections are a powerful way to manage groups of similar content, such as blog posts, by defining a schema to enforce a common structure and using APIs like `getCollection()` to retrieve content and metadata.** **Key features and APIs:** * `getCollection()` method to retrieve content and metadata * Schema definition using Zod to enforce data structure and validation * Support for frontmatter properties with required and data type specifications * Integration with Astro's built-in file-based routing and content management **Implementation details and use cases:** * Move blog post folder to `src/blog/` and create a schema to define frontmatter properties * Use `getCollection()` to generate blog post index and display individual posts * Leverage schema validation to catch mistakes and receive better code editor guidance",
      "url": "/en/tutorial/6-islands/4/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "6 islands",
        "optional:",
        "make",
        "collection"
      ],
      "type": "tutorial"
    },
    {
      "id": "reference/errors/page-number-param-not-found",
      "language": "en",
      "title": "Page number param not found.",
      "summary": "**Page Number Param Not Found Error** The `PageNumberParamNotFound` error occurs when the `[paginate()]` page number parameter `PARAM_NAME` is not found in the filepath. This error is triggered by the absence of the required page number parameter in the filepath. **Key Features and APIs:** * `[paginate()]` function * `PARAM_NAME` page number parameter * Filepath validation **Implementation Details and Use Cases:** * Error handling for pagination routes * Validation of page number parameters in filepaths * Integration with Astro's routing system **Related APIs and Methods:** * `Astro.props` * `getStaticPaths` * Pagination routing guidelines",
      "url": "/en/reference/errors/page-number-param-not-found/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "page",
        "number",
        "param",
        "found."
      ],
      "type": "guide"
    },
    {
      "id": "basics/astro-pages",
      "language": "en",
      "title": "Pages",
      "summary": "**Pages** are files that live in the `src/pages/` subdirectory of your Astro project, handling routing, data loading, and page layout for every page in your website. Astro supports `.astro`, `.md`, `.mdx`, `.html`, and `.js/.ts` file types in the `src/pages/` directory, leveraging file-based routing and dynamic routing to generate multiple pages. Pages can be linked using standard HTML `` elements with URL paths relative to the root domain. Astro pages use the `.astro` file extension and support features like Astro components, with implementation details including Astro.props and getStaticPaths.",
      "url": "/en/basics/astro-pages/",
      "keywords": [
        "content",
        "docs",
        "basics",
        "pages"
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/payload",
      "language": "en",
      "title": "Payload CMS & Astro",
      "summary": "**Payload CMS & Astro Integration** Payload CMS is a headless open-source content management system that provides content for Astro projects. It integrates with Astro through a REST API, requiring a MongoDB database and a Payload CMS project setup. The integration involves configuring Astro to use a Payload CMS collection, such as the `posts` collection, which can be created manually or generated through a template during Payload CMS installation.",
      "url": "/en/guides/cms/payload/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "payload",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/prefetch",
      "language": "en",
      "title": "Prefetch",
      "summary": "**Prefetch** Astro components are designed to prefetch links for snappier navigation between pages, improving usability and overall enjoyment of a site. Prefetching is enabled through the `prefetch` config, which can be customized with an option object to fine-tune prefetching strategies. The `data-astro-prefetch` attribute can be added to `` links to opt-in to prefetching, with supported strategies including `hover`, `tap`, `viewport`, and `load`.",
      "url": "/en/guides/prefetch/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "prefetch"
      ],
      "type": "guide"
    },
    {
      "id": "tutorial/1-setup/1",
      "language": "en",
      "title": "Prepare your dev environment",
      "summary": "**Prepare your dev environment** Astro components are designed to guide users through setting up their development environment, including installing Node.js, a code editor, and accessing the command line (terminal). Key features include importing necessary components, checking for compatible Node.js versions, and installing a code editor. Implementation details include using Astro components such as `PreCheck`, `Steps`, and `Badge` to display instructions and progress. Use cases include creating a new Astro project, building, developing, and testing a website.",
      "url": "/en/tutorial/1-setup/1/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "1 setup",
        "prepare",
        "your",
        "environment"
      ],
      "type": "tutorial"
    },
    {
      "id": "guides/cms/preprcms",
      "language": "en",
      "title": "Prepr CMS & Astro",
      "summary": "**Prepr CMS & Astro Integration** Prepr CMS & Astro is a headless CMS integration that enables content management and personalization for Astro projects. It provides a GraphQL API to connect data to Astro, allowing for on-demand rendering and internationalization. **Key Features and APIs** * `Prepr` function: fetches data from Prepr CMS using GraphQL API * `fetch` method: sends POST requests to Prepr endpoint with query and variables * `import.meta.env.PREPR_ENDPOINT`: environment variable for Prepr API URL * `src/lib/prepr.js`: configuration file for Prepr endpoint **Implementation Details and Use Cases** * Create a new Astro project with on-demand rendering enabled * Set up a Prepr account and environment with existing blog posts * Configure the Prepr endpoint in `src/lib/prepr.js` using the `Prepr` function * Use the `Prepr` function to fetch data from Prepr CMS in Astro components",
      "url": "/en/guides/cms/preprcms/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "prepr",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "reference/errors/prerender-dynamic-endpoint-path-collide",
      "language": "en",
      "title": "Prerendered dynamic endpoint has path collision.",
      "summary": "**Prerendered dynamic endpoint has path collision.** Astro components are affected by path collisions when prerendering dynamic endpoints with undefined params, causing generated paths to collide during prerendering. This issue can be resolved by preventing undefined params in the endpoint's getStaticPaths() function or adding an additional extension to the endpoint's filename, such as renaming pages/api/[slug].ts to pages/api/[slug].json.ts. The getStaticPaths() function and params API are used to resolve this issue.",
      "url": "/en/reference/errors/prerender-dynamic-endpoint-path-collide/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "prerendered",
        "dynamic",
        "endpoint",
        "path"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/no-prerendered-routes-with-domains",
      "language": "en",
      "title": "Prerendered routes arent supported when internationalization domains are enabled.",
      "summary": "**Prerendered routes are not supported when internationalization domains are enabled.** Static pages are not supported with multiple domains, requiring prerendering to be disabled for the page component (`COMPONENT`) to enable this feature. This limitation is due to the incompatibility between static page rendering and internationalization domains. The `NoPrerenderedRoutesWithDomains` error occurs when attempting to prerender static pages with i18n domains enabled.",
      "url": "/en/reference/errors/no-prerendered-routes-with-domains/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "prerendered",
        "routes",
        "arent",
        "supported"
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/prismic",
      "language": "en",
      "title": "Prismic & Astro",
      "summary": "**Prismic & Astro Integration** Prismic & Astro integration enables developers to leverage Prismic as a headless content management system (CMS) within Astro projects, allowing for dynamic content rendering and management. **Key Features and APIs** * Utilize Prismic's API to fetch and render content in Astro components * Access Prismic's data model and schema through Astro's `Astro.props` API * Implement internationalization and localization using Prismic's built-in features * Leverage Astro's `getStaticPaths` method to pre-render pages with Prismic content **Implementation and Use Cases** * Integrate Prismic as a data source for Astro components using the Prismic API * Use Prismic's schema to define and manage content models in Astro projects * Take advantage of Prismic's internationalization features to support multiple languages and regions in Astro applications",
      "url": "/en/guides/cms/prismic/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "prismic",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "reference/programmatic-reference",
      "language": "en",
      "title": "Programmatic Astro API (experimental)",
      "summary": "**Programmatic Astro API (experimental)** The Astro package exports APIs to programmatically run CLI commands, providing control over Astro's execution. Key features include: * `AstroInlineConfig` type, extending the user Astro config type, with properties `configFile`, `mode`, `logLevel`, and others. * `configFile` property: a custom path to the Astro config file, with options to disable loading or resolve relative paths. * `mode` property: determines the mode used when developing or building the site, influencing Vite's behavior and environment variables. Implementation details and use cases involve using the `AstroInlineConfig` type to customize Astro's behavior, such as setting a custom config file path or mode, and leveraging the `mode` property to control Vite's execution.",
      "url": "/en/reference/programmatic-reference/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "programmatic",
        "astro",
        "(experimental)"
      ],
      "type": "guide"
    },
    {
      "id": "basics/project-structure",
      "language": "en",
      "title": "Project structure",
      "summary": "**Project Structure Overview** Astro projects are organized with an opinionated folder layout, including `src/*` for source code, `public/*` for non-code assets, `package.json` for project manifests, and `astro.config.mjs` for Astro configurations. **Key Features and APIs** * `src/*`: Project source code directory * `public/*`: Non-code, unprocessed assets directory * `package.json`: Project manifest file * `astro.config.mjs`: Astro configuration file * `tsconfig.json`: TypeScript configuration file (recommended) **Implementation Details and Use Cases** Astro projects use the `src/` folder to store source code, including pages, layouts, components, styles, and images, which are processed, optimized, and bundled to create the final website. The `public/` folder contains non-code assets, such as fonts and icons.",
      "url": "/en/basics/project-structure/",
      "keywords": [
        "content",
        "docs",
        "basics",
        "project",
        "structure"
      ],
      "type": "guide"
    },
    {
      "id": "reference/publish-to-npm",
      "language": "en",
      "title": "Publish to NPM",
      "summary": "**Publishing Astro Components to NPM** Astro components can be published directly to and installed from NPM, allowing for reuse across projects and sharing with the Astro community. Key features include: * Using the `npm create astro` command to initialize a new component template * Configuring workspaces within the project to develop the component alongside Astro * Utilizing `package.json` to manage dependencies and metadata * Implementing `getStaticPaths` and `Astro.props` to enable server-side rendering and props management Implementation details involve setting up a basic understanding of Node Modules, Package Manifests, and Workspaces, and using tools like `npm`, `yarn`, or `pnpm` to manage dependencies and package distribution.",
      "url": "/en/reference/publish-to-npm/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "publish"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/route-not-found",
      "language": "en",
      "title": "Route not found.",
      "summary": "**RouteNotFound Component** RouteNotFound is an Astro component that displays an error message when a requested route is not found. It utilizes the `DontEditWarning` component and provides a clear indication of the issue, stating that Astro couldn't find a matching route. The component is ready for internationalization and can be used to handle route not found scenarios in Astro applications.",
      "url": "/en/reference/errors/route-not-found/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "route",
        "found."
      ],
      "type": "guide"
    },
    {
      "id": "guides/routing",
      "language": "en",
      "title": "Routing",
      "summary": "**Astro components are used for file-based routing to generate build URLs based on the file layout of the project's `src/pages/` directory.** **Key features include:** * Standard HTML `` elements for navigation between routes * Automatic page creation from `.astro` page components, Markdown, and MDX files within `src/pages/` * Dynamic route parameters in filenames to generate multiple, matching pages * Access to route parameters from inside page components using `Astro.props` **Implementation details and use cases:** * File-based routing eliminates the need for a separate routing config * Customizable file output format using `build.format` configuration option * Dynamic routes enable generation of multiple pages from a single file template",
      "url": "/en/guides/routing/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "routing"
      ],
      "type": "guide"
    },
    {
      "id": "reference/routing-reference",
      "language": "en",
      "title": "Routing Reference",
      "summary": "**Astro Routing Reference** Astro components are statically generated and prerendered at build time, with optional on-demand server rendering for individual routes or as the default. **Key Features and APIs** * `prerender` property: a boolean value exported from each route to determine prerendering status * `getStaticPaths` method: not applicable, as Astro generates routes automatically * Astro.props: not applicable, as Astro uses a different approach to routing **Implementation Details and Use Cases** * Prerendering can be overridden on a per-page basis by exporting `prerender` with the value `false` * On-demand server rendering can be enabled for individual routes or as the default by configuring `output: 'server'` in the Astro configuration",
      "url": "/en/reference/routing-reference/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "routing"
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/sanity",
      "language": "en",
      "title": "Sanity & Astro",
      "summary": "**Sanity & Astro Integration** Sanity & Astro is a headless content management system integration that enables developers to add content to their Astro projects using Sanity's structured content platform. **Key Features:** * Utilizes Sanity's API to fetch and render content in Astro components * Supports internationalization and localization through Sanity's built-in features * Includes official resources and guides for building blogs and sites with Astro and Sanity **Implementation Details:** * Import Sanity components and APIs in Astro files using `import` statements * Use Sanity's `getStaticPaths` and `Astro.props` to fetch and render content dynamically * Leverage Sanity's structured content model to create and manage content in Astro projects **Use Cases:** * Build blogs and sites with Astro and Sanity using official guides and resources * Integrate Sanity's content management system with Astro components for dynamic content rendering * Utilize Sanity's internationalization features to create multilingual content in Astro projects",
      "url": "/en/guides/cms/sanity/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "sanity",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/client-side-scripts",
      "language": "en",
      "title": "Scripts and event handling",
      "summary": "**Client-Side Scripting in Astro** Astro components can execute client-side JavaScript using standard HTML `` tags, enabling event handling, analytics, animations, and more without relying on UI frameworks. Astro processes and bundles `` tags, supporting imports, TypeScript, and bundling, with scripts injected at the point of declaration. This allows for efficient and flexible client-side scripting in Astro components.",
      "url": "/en/guides/client-side-scripts/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "scripts",
        "event",
        "handling"
      ],
      "type": "guide"
    },
    {
      "id": "tutorial/3-components/4",
      "language": "en",
      "title": "Send your first script to the browser",
      "summary": "**Astro components are used to create reusable UI components for client-side interactivity.** **Key features include:** * Importing Astro components (e.g., `Blanks`, `Box`, `Checklist`, `MultipleChoice`, `Option`, `PreCheck`, `Steps`) * Using Astro's built-in components (e.g., `Steps` from `@astrojs/starlight/components`) * Creating custom components (e.g., `Hamburger.astro`) with Astro's syntax * Using Astro's client-side rendering capabilities for interactivity **Implementation details and use cases:** * Creating a custom `Hamburger` component with Astro's syntax * Using Astro's `script` tag to add client-side JavaScript code * Moving JavaScript code to a separate `.js` file * Using CSS styles to customize the component's appearance (e.g., `global.css`)",
      "url": "/en/tutorial/3-components/4/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "3 components",
        "send",
        "your",
        "first",
        "script"
      ],
      "type": "tutorial"
    },
    {
      "id": "guides/server-islands",
      "language": "en",
      "title": "Server islands",
      "summary": "**Server Islands** Server islands allow you to on-demand render dynamic or personalized \"islands\" individually, without sacrificing the performance of the rest of the page, using the `server:defer` directive and an adapter installed for delayed rendering. **Key Features and APIs** * `server:defer` directive to turn components into server islands * Support for on-demand rendering features, such as fetching content and accessing cookies * Prop passing with serializable data structures, including limitations on data types * Integration with server adapters for delayed rendering **Implementation and Use Cases** Server islands can be used to render dynamic or personalized content, such as user avatars or dynamic content, while allowing the rest of the page to be cached and rendered immediately. This approach provides faster performance and improved user experience.",
      "url": "/en/guides/server-islands/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "server",
        "islands"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/session-storage-save-error",
      "language": "en",
      "title": "Session data could not be saved.",
      "summary": "**Error Handling for Session Data Saving** The `Session data could not be saved` error occurs when the session data fails to save due to an issue with the specified driver `DRIVER`. This error is thrown when the session data cannot be persisted, and is typically encountered when using the `DRIVER` driver. The error is related to the `Sessions` feature and can be resolved by checking the driver configuration and implementation details.",
      "url": "/en/reference/errors/session-storage-save-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "session",
        "data",
        "could",
        "saved."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/session-config-without-flag-error",
      "language": "en",
      "title": "Session flag not set",
      "summary": "**Astro components are used to render static and dynamic content, but throw an error when session storage is configured without enabling the `experimental.session` flag.** **Key features and APIs:** * `experimental.session` flag * Session storage configuration * `getStaticPaths` method * `Astro.props` object **Implementation details and use cases:** * Enabling the `experimental.session` flag is required for session storage configuration * Use cases include configuring session storage for dynamic content and static site generation **Technical keywords:** Astro, session storage, experimental.session flag, static site generation, dynamic content.",
      "url": "/en/reference/errors/session-config-without-flag-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "session",
        "flag"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/session-storage-init-error",
      "language": "en",
      "title": "Session storage could not be initialized.",
      "summary": "**Session Storage Initialization Error** Session storage could not be initialized due to an error with the specified driver `DRIVER`. This error occurs when the `sessionStorage` object fails to initialize, typically due to a missing or invalid driver configuration. The error is thrown when attempting to access the `sessionStorage` object, and can be resolved by verifying the driver configuration and ensuring the session storage is properly initialized.",
      "url": "/en/reference/errors/session-storage-init-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "session",
        "storage",
        "could",
        "initialized."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/session-config-missing-error",
      "language": "en",
      "title": "Session storage was enabled but not configured.",
      "summary": "**Session Storage Configuration Error** Session storage was enabled but not configured, requiring manual storage configuration or use of an adapter providing session storage. The error occurs when the `experimental.session` flag is set to `true` without specifying storage. This issue is resolved in Astro 5.7, where the Sessions feature is no longer experimental.",
      "url": "/en/reference/errors/session-config-missing-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "session",
        "storage",
        "enabled",
        "configured."
      ],
      "type": "guide"
    },
    {
      "id": "guides/sessions",
      "language": "en",
      "title": "Sessions",
      "summary": "**Sessions are used to share data between requests for on-demand rendered pages, storing larger amounts of data on the server without size limits or security issues.** **Key Features:** * Store data on the server, accessible as `Astro.session` in components and pages, and `context.session` in API endpoints, middleware, and actions. * Use a storage driver to store session data, with automatic configuration for Node, Cloudflare, and Netlify adapters, and manual specification required for other adapters. * Interact with session data using the `session` object, allowing for operations such as adding items to a shopping cart and deleting the session ID cookie. **Implementation Details:** * Use `Astro.session.get()` to retrieve session data, and `Astro.session.set()` to store new data. * Specify a storage driver in `astro.config.mjs` using the `session` configuration option. * Access session data in components and pages using `Astro.session`, and in API endpoints, middleware, and actions using `context.session`.",
      "url": "/en/guides/sessions/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "sessions"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/session-without-supported-adapter-output-error",
      "language": "en",
      "title": "Sessions cannot be used with an adapter that doesnt support server output.",
      "summary": "**Sessions require an adapter that supports server output.** Sessions utilize the `buildOutput` adapter feature, specifically requiring the `\"server\"` feature to be set. This ensures that the adapter can handle server output, enabling sessions to function correctly.",
      "url": "/en/reference/errors/session-without-supported-adapter-output-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "sessions",
        "cannot",
        "used",
        "with"
      ],
      "type": "guide"
    },
    {
      "id": "recipes/sharing-state",
      "language": "en",
      "title": "Share state between Astro components",
      "summary": "**Astro components are designed to share state across components using Nano Stores.** **Key features and APIs include:** * Importing and using Nano Stores for shared client storage * Creating a store using `atom` from `nanostores` * Importing and subscribing to the store in Astro components using `` tags * Using `isOpen.set(true)` to update the store and trigger changes in dependent components **Implementation details and use cases:** * Install Nano Stores using npm, pnpm, or yarn * Create a store to track shared state, such as a dialog open status * Use the store in multiple Astro components to control the visibility of UI elements based on the shared state.",
      "url": "/en/recipes/sharing-state/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "share",
        "state",
        "between",
        "astro"
      ],
      "type": "recipe"
    },
    {
      "id": "recipes/sharing-state-islands",
      "language": "en",
      "title": "Share state between islands",
      "summary": "Astro components are designed to share state across framework components with Nano Stores, a lightweight, framework-agnostic library for client-side storage. Key features include: * Using Astro.props to access and update shared state * Implementing stores with Nano Stores' API, including `get`, `set`, and `subscribe` methods * Utilizing `nanostores` library to create and manage shared state across components Implementation details and use cases include: * Partially hydrating components within Astro or Markdown * Sharing state between components with different frameworks, such as React or Vue * Using Nano Stores' lightweight and framework-agnostic design to simplify state management.",
      "url": "/en/recipes/sharing-state-islands/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "share",
        "state",
        "between",
        "islands"
      ],
      "type": "recipe"
    },
    {
      "id": "guides/cms/sitecore",
      "language": "en",
      "title": "Sitecore Experience Manager & Astro",
      "summary": "**Sitecore Experience Manager & Astro** Sitecore Experience Manager & Astro enables developers to integrate Sitecore as a Content Management System (CMS) with Astro, a modern web framework for building fast, scalable, and secure websites. **Key Features and APIs** * Utilize Sitecore Headless API to fetch content and data * Leverage Astro's `getStaticPaths` and `Astro.props` APIs for server-side rendering and data fetching * Integrate with Sitecore JavaScript Software Development Kit (JSS) for Astro **Implementation Details and Use Cases** * Initialize a new Astro project using `npx @astro-sitecore-jss/create-astro-sitecore-jss@latest` * Create a Sitecore Headless website following Sitecore's official documentation * Use Sitecore JSS for Astro to fetch and render content on the client-side **Technical Keywords** * Sitecore Experience Manager * Astro * Headless CMS * Server-side rendering * Data fetching * JavaScript Software Development Kit (JSS)",
      "url": "/en/guides/cms/sitecore/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "sitecore",
        "experience",
        "manager",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/cms/sitepins",
      "language": "en",
      "title": "Sitepins & Astro",
      "summary": "**Sitepins & Astro Integration** Sitepins is a Git-based, headless CMS for Astro projects, offering a clean WYSIWYG editor, version-controlled content workflow, and seamless integration with Astro and other SSGs. Key features include Astro.props, getStaticPaths, and Astro components, which enable developers to manage content with full Git version control. Sitepins integrates with Astro projects via GitHub repository connection, allowing for easy content management and publishing.",
      "url": "/en/guides/cms/sitepins/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "sitepins",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "reference/errors/config-not-found",
      "language": "en",
      "title": "Specified configuration file not found.",
      "summary": "**Specified configuration file not found.** The `ConfigNotFound` error occurs when the specified configuration file using `--config` cannot be resolved. This is typically due to the file not existing or an incorrect path being provided. The error can be resolved by verifying the existence and path of the configuration file, and using the `--config` option with the correct path.",
      "url": "/en/reference/errors/config-not-found/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "specified",
        "configuration",
        "file",
        "found."
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/spinal",
      "language": "en",
      "title": "Spinal & Astro",
      "summary": "**Spinal & Astro Integration** Spinal & Astro is a commercial, SaaS-focused, Git-based CMS integration for Astro projects, enabling content management and internationalization. **Key Features and APIs** * Import Markdown content from a selected folder into Spinal using Astro's `getStaticPaths` and `Astro.props` APIs. * Utilize Spinal's API to connect GitHub accounts and select Astro repositories. * Leverage official resources, such as the Spinal documentation theme built for Astro with Tailwind CSS. **Implementation Details and Use Cases** * Connect Spinal account to GitHub and select Astro repository to import Markdown content. * Use Spinal's API to manage content and enable internationalization. * Deploy production sites using Astro + Spinal, as demonstrated by spinalcms.com.",
      "url": "/en/guides/cms/spinal/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "spinal",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "tutorial/1-setup/4",
      "language": "en",
      "title": "Store your repository online",
      "summary": "**Repository Management** Astro components are used to create a tutorial on storing a repository online, utilizing GitHub as the online git provider. **Key Features and APIs** * Importing Astro components: `Checklist`, `Box`, `PreCheck`, `Steps`, and `Badge` * Using `Steps` component to guide the user through the repository creation process * Utilizing `PreCheck` component to verify user actions * API integration with GitHub for repository creation and code management **Implementation Details and Use Cases** * Creating a new repository on GitHub using the web interface * Committing local code to GitHub using VS Code's Source Control tab * Utilizing Astro components to create a tutorial on repository management and deployment",
      "url": "/en/tutorial/1-setup/4/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "1 setup",
        "store",
        "your",
        "repository",
        "online"
      ],
      "type": "tutorial"
    },
    {
      "id": "guides/cms/storyblok",
      "language": "en",
      "title": "Storyblok & Astro",
      "summary": "**Storyblok & Astro Integration** Astro components are enhanced with Storyblok integration, allowing developers to manage content using reusable components called Bloks. **Key Features and APIs** * `@storyblok/astro` integration module for connecting Storyblok to Astro * `STORYBLOK_TOKEN` environment variable for authentication * `getStaticPaths` API for fetching content from Storyblok * `Astro.props` API for accessing Storyblok content in Astro components **Implementation Details and Use Cases** * Create a `.env` file to store Storyblok credentials * Install `@storyblok/astro` integration module using npm or pnpm * Use `getStaticPaths` API to fetch content from Storyblok in Astro components * Access Storyblok content using `Astro.props` API in Astro components",
      "url": "/en/guides/cms/storyblok/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "storyblok",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/cms/strapi",
      "language": "en",
      "title": "Strapi & Astro",
      "summary": "**Strapi & Astro Integration** Astro components are enhanced with Strapi headless CMS functionality, enabling seamless content management and internationalization. **Key Features and APIs** * `STRAPI_URL` environment variable for Strapi API connection * `ImportMetaEnv` interface for IntelliSense support * `src/lib/strapi.ts` wrapper function for interacting with Strapi API * `Props` interface for API request configuration **Implementation Details and Use Cases** The Strapi & Astro integration allows developers to fetch data from the Strapi API using the `src/lib/strapi.ts` wrapper function, which can be used to populate Astro components with dynamic content. This integration is particularly useful for building headless CMS-powered websites and applications.",
      "url": "/en/guides/cms/strapi/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "strapi",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/cms/studiocms",
      "language": "en",
      "title": "StudioCMS & Astro",
      "summary": "StudioCMS & Astro are designed to build and manage content for Astro projects using a headless CMS, providing a user-friendly dashboard and custom rendering system for Astro components. Key features include Astro.props, getStaticPaths, and Astro components integration, with implementation details and use cases available in the StudioCMS documentation. StudioCMS is built with Astro and supports internationalization, with official resources available on GitHub, Discord, and the StudioCMS documentation website.",
      "url": "/en/guides/cms/studiocms/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "studiocms",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "recipes/tailwind-rendered-markdown",
      "language": "en",
      "title": "Style rendered Markdown with Tailwind Typography",
      "summary": "**Style rendered Markdown with Tailwind Typography** Astro components are enhanced with Tailwind Typography plugin to style rendered Markdown content from Astro's content collections. This is achieved through the creation of a reusable Astro component, ``, which wraps rendered Markdown with Tailwind utility classes. The component utilizes the `@tailwindcss/typography` plugin, which is installed and configured in the project's Tailwind configuration file. **Key Features and APIs:** * `@tailwindcss/typography` plugin for styling rendered Markdown * `` component for wrapping rendered Markdown with Tailwind utility classes * `@tailwindcss/typography` plugin configuration in Tailwind configuration file * Use of Tailwind element modifiers for customizing typography styles **Implementation Details and Use Cases:** * Installation of `@tailwindcss/typography` plugin using npm, pnpm, or yarn * Configuration of `@tailwindcss/typography` plugin in Tailwind configuration file * Creation of reusable `` component for styling rendered Markdown content * Use of Tailwind utility classes to customize typography styles in the `` component",
      "url": "/en/recipes/tailwind-rendered-markdown/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "style",
        "rendered",
        "markdown",
        "with"
      ],
      "type": "recipe"
    },
    {
      "id": "tutorial/2-pages/4",
      "language": "en",
      "title": "Style your About page",
      "summary": "**Style your About page** Astro components are used to style individual pages, including adding attributes and directives to `` tags for customization. Key features include: * Using `` tags with attributes and directives for styling * Adding class names to elements for further styling * Utilizing CSS variables for dynamic styling Implementation details include: * Adding `` tags to individual pages (e.g., `src/pages/about.astro`) * Using attributes and directives to style elements (e.g., `h1 { color: purple; }`) * Adding class names to elements (e.g., `class=\"skill\"`) Use cases include: * Styling individual pages with custom CSS * Using CSS variables for dynamic styling * Adding class names to elements for further styling",
      "url": "/en/tutorial/2-pages/4/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "2 pages",
        "style",
        "your",
        "about",
        "page"
      ],
      "type": "tutorial"
    },
    {
      "id": "guides/styling",
      "language": "en",
      "title": "Styles and CSS",
      "summary": "**Astro components are designed to make styling and writing CSS a breeze, supporting direct CSS writing, CSS libraries, and advanced styling languages like Sass and Less.** **Key features include:** * **Scoped styles**: automatically encapsulated inside each component, preventing CSS leaks and preserving specificity. * ** tag support**: place a tag inside an Astro component to handle styles automatically. * **APIs and methods**: Astro.props, getStaticPaths (not directly related to styling, but mentioned in the context). **Implementation details and use cases:** * Write CSS directly inside Astro components or import favorite CSS libraries. * Use low-specificity selectors like `h1 {}` or `p {}` without worrying about CSS leaks. * Wrap child components in a `` to style them, if needed.",
      "url": "/en/guides/styling/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "styles"
      ],
      "type": "guide"
    },
    {
      "id": "guides/backend/supabase",
      "language": "en",
      "title": "Supabase & Astro",
      "summary": "**Supabase & Astro: Add a Backend to Your Project** Astro components are augmented with Supabase functionality, enabling Postgres database, authentication, edge functions, realtime subscriptions, and storage capabilities. Key features include the `SUPABASE_URL` and `SUPABASE_ANON_KEY` environment variables, which can be added to the `.env` file and typed in `env.d.ts`. The `@supabase/supabase-js` package is installed to connect to Supabase, and Astro's on-demand rendering is enabled with `output: 'server'`.",
      "url": "/en/guides/backend/supabase/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "backend",
        "supabase",
        "astro"
      ],
      "type": "backend"
    },
    {
      "id": "guides/syntax-highlighting",
      "language": "en",
      "title": "Syntax Highlighting",
      "summary": "**Syntax Highlighting in Astro** Astro components are equipped with built-in support for syntax highlighting using Shiki and Prism, enabling automatic highlighting of code fences in Markdown and MDX files, as well as content within the `` and `` components in `.astro` files. This feature is powered by Shiki by default, with the `github-dark` theme, and can be customized or disabled using the `markdown.syntaxHighlight` configuration option. Additionally, community integrations such as Expressive Code provide further text marking and annotation options.",
      "url": "/en/guides/syntax-highlighting/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "syntax",
        "highlighting"
      ],
      "type": "guide"
    },
    {
      "id": "reference/directives-reference",
      "language": "en",
      "title": "Template directives reference",
      "summary": "**Template Directives Reference** **Purpose:** Template directives are a special kind of HTML attribute used to control an element or component's behavior in Astro templates. **Features:** * Control element or component behavior * Enable compiler features or special behavior * Can take custom values, such as arrays or objects * Powered by popular libraries like clsx **APIs and Methods:** * `class:list`: takes an array of class values and converts them into a class string * `set:html`: injects an HTML string into an element, similar to setting `el.innerHTML` **Implementation Details:** * Must include a colon `:` in its name, using the form `X:Y` * Can be used in `.astro` files and some `.mdx` files * Never included directly in the final HTML output of a component **Use Cases:** * Simplify class management with `class:list` * Inject HTML content with `set:html`",
      "url": "/en/reference/directives-reference/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "template",
        "directives"
      ],
      "type": "guide"
    },
    {
      "id": "reference/astro-syntax",
      "language": "en",
      "title": "Template expressions reference",
      "summary": "**Astro component syntax is a superset of HTML, designed to feel familiar to anyone with experience writing HTML or JSX, and adds support for including components and JavaScript expressions.** **Key features include:** * Defining local JavaScript variables in the frontmatter component script using code fences (`---`) * Injecting variables into the component's HTML template using JSX-like expressions * Support for dynamic values calculated in the frontmatter, but not reactive values * Use of curly braces syntax to add variables into HTML * Support for dynamic attributes using curly braces to pass attribute values to HTML elements and components **Implementation details and use cases:** * Variables can be added into HTML using the curly braces syntax * Local variables can be used in curly braces to pass attribute values to HTML elements and components * HTML attributes will be converted to strings, so functions and objects cannot be passed to HTML elements * Use client-side scripts to add event handlers to HTML elements instead of using JSX expressions.",
      "url": "/en/reference/astro-syntax/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "template",
        "expressions"
      ],
      "type": "guide"
    },
    {
      "id": "guides/testing",
      "language": "en",
      "title": "Testing",
      "summary": "**Testing in Astro** Astro supports various testing frameworks for unit tests, component tests, and end-to-end tests, including Jest, Mocha, Jasmine, Cypress, and Playwright. Testing frameworks allow you to write assertions or expectations about code behavior and compare them to actual behavior. Astro provides the `getViteConfig()` helper for setting up Vitest with project settings. **Key Features and APIs** * `getViteConfig()` helper for setting up Vitest with Astro project settings * Vitest configuration options for customizing test environment * Container API for testing Astro components * Support for popular testing frameworks: Jest, Mocha, Jasmine, Cypress, and Playwright **Implementation Details and Use Cases** * Use `getViteConfig()` in `vitest.config.ts` to set up Vitest with Astro project settings * Customize Astro configuration applied in tests by passing a second argument to `getViteConfig()` * Test Astro components using the container API with Vitest",
      "url": "/en/guides/testing/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "testing"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/endpoint-did-not-return-aresponse",
      "language": "en",
      "title": "The endpoint did not return a Response.",
      "summary": "**Astro API Endpoints are designed to return a Response object or a Promise that resolves with a Response object.** **Key Features:** * Must return a `Response` object or a `Promise` that resolves with a `Response` object. * Use `Response.json()` to return JSON data. * Implement `GET` endpoints using `export async function GET({ request, url, cookies }: APIContext): Promise { ... }`. **Implementation Details:** * Use `APIContext` type to access request, URL, and cookies. * Return a `Response` object or a `Promise` that resolves with a `Response` object to avoid `EndpointDidNotReturnAResponse` errors. **Use Cases:** * Returning JSON data from API endpoints. * Handling errors and exceptions in API endpoints. * Implementing secure and reliable API endpoints in Astro.",
      "url": "/en/reference/errors/endpoint-did-not-return-aresponse/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "endpoint",
        "return",
        "response."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/middleware-no-data-or-next-called",
      "language": "en",
      "title": "The middleware didnt return a Response.",
      "summary": "**Astro middleware error handling** Astro middleware error handling is triggered when middleware fails to return a `Response` object, either directly or by calling the `next` function. This occurs when middleware does not return any data or call `next`, resulting in a `MiddlewareNoDataOrNextCalled` error. The error is typically thrown when middleware is defined using `defineMiddleware` and does not properly handle the `context` and `next` parameters.",
      "url": "/en/reference/errors/middleware-no-data-or-next-called/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "middleware",
        "didnt",
        "return",
        "response."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/middleware-not-aresponse",
      "language": "en",
      "title": "The middleware returned something that is not a Response object.",
      "summary": "**MiddlewareNotAResponse**: Astro middleware must return a valid `Response` object. The middleware returned something that is not a `Response` object, such as a string or object, which is not a valid response in Astro. This error occurs when using `defineMiddleware` and returning a non-`Response` value, like in the example `onRequest` function that returns a string.",
      "url": "/en/reference/errors/middleware-not-aresponse/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "middleware",
        "returned",
        "something",
        "that"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/i18n-no-locale-found-in-path",
      "language": "en",
      "title": "The path doesnt contain any locale",
      "summary": "**i18n Utility Error Handling** The `i18nNoLocaleFoundInPath` error occurs when an i18n utility attempts to use a locale from a URL path that does not contain one. To prevent this error, use the `pathHasLocale` method to check URLs for a locale before utilizing i18n utilities. This can be achieved by calling `pathHasLocale` to determine if the path has a locale, and then using i18n utilities accordingly.",
      "url": "/en/reference/errors/i18n-no-locale-found-in-path/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "path",
        "doesnt",
        "contain",
        "locale"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/missing-locale",
      "language": "en",
      "title": "The provided locale does not exist.",
      "summary": "**MissingLocale Error Handling** The `MissingLocale` error occurs when Astro cannot find the requested locale in the configured `i18n.locales`. This error is triggered when the locale/path `LOCALE` does not exist in the `i18n.locales` configuration and corresponding directories within `src/pages/`. The error is resolved by ensuring all supported locales are configured in `i18n.locales` and have corresponding directories within `src/pages/`.",
      "url": "/en/reference/errors/missing-locale/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "provided",
        "locale",
        "does",
        "exist."
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/tina-cms",
      "language": "en",
      "title": "Tina CMS & Astro",
      "summary": "**Tina CMS & Astro Integration** Tina CMS is a Git-backed headless content management system integrated with Astro, enabling developers to add content to their Astro projects using Tina as a CMS. Key features include: * Installation via `npx @tinacms/cli@latest init` or `pnpm dlx @tinacms/cli@latest init`/`yarn dlx @tinacms/cli@latest init` * Integration with Astro's development server via `tinacms dev -c \"astro dev\"` * Access to Tina CMS APIs and methods, including `Astro.props` and `getStaticPaths` * Use of Tina CMS components, such as `Steps` and `PackageManagerTabs` * Support for internationalization and localization Implementation details include modifying the `dev` script in `package.json` to include Tina CMS integration. Use cases include adding content to Astro projects using Tina CMS, leveraging Tina's Git-backed content management capabilities.",
      "url": "/en/guides/cms/tina-cms/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "tina",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "guides/troubleshooting",
      "language": "en",
      "title": "Troubleshooting",
      "summary": "**Astro provides several tools to help troubleshoot and debug code, including `console.log()` statements, debugging framework components, and the built-in `` component.** **Key features and APIs:** * `console.log()` statements for debugging in terminal and browser console * Debugging framework components for server-side and browser-side rendering * `` component for inspecting values in client-side HTML template **Implementation details and use cases:** * `console.log()` statements can be used in Astro frontmatter and `` tags * `` component can be used to inspect values in client-side HTML template * Debugging framework components can be used to debug differences between server output and hydrated components in browser.",
      "url": "/en/guides/troubleshooting/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "troubleshooting"
      ],
      "type": "guide"
    },
    {
      "id": "guides/backend/turso",
      "language": "en",
      "title": "Turso & Astro",
      "summary": "**Turso & Astro** Turso & Astro enables building locally with a SQLite file and deploying globally using Turso, a distributed database built on libSQL. Key features include: * Initializing Turso in Astro using the Turso CLI, environment variables, and the `@libsql/client` package * Creating a Turso client instance with `createClient` and passing `TURSO_DATABASE_URL` and `TURSO_AUTH_TOKEN` * Querying the database using SQL queries and the `turso` client instance Implementation details include configuring environment variables, installing the `@libsql/client` package, and initializing a new client instance. Use cases include building global applications with low query latency and utilizing Turso's distributed database capabilities.",
      "url": "/en/guides/backend/turso/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "backend",
        "turso",
        "astro"
      ],
      "type": "backend"
    },
    {
      "id": "guides/typescript",
      "language": "en",
      "title": "TypeScript",
      "summary": "**TypeScript in Astro** Astro components are enabled with built-in support for TypeScript, allowing import of `.ts` and `.tsx` files, direct TypeScript code writing, and use of an `astro.config.ts` file for configuration. Key features include type checking for component props, automatic type inference for autocompletion and hints in the editor, and support for `tsconfig.json` templates (`base`, `strict`, and `strictest`) for project configuration.",
      "url": "/en/guides/typescript/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "typescript"
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/umbraco",
      "language": "en",
      "title": "Umbraco & Astro",
      "summary": "Here is the technical documentation summary: **Umbraco & Astro Integration** Astro components are integrated with Umbraco CMS to fetch and display content using the Content Delivery API. **Key Features and APIs** * `fetch()` API to access Umbraco content * `ContentDeliveryApi` configuration in `appsettings.json` file * `getStaticPaths` and `Astro.props` methods for dynamic content fetching * Support for internationalization (i18n) and localization (L10n) **Implementation Details and Use Cases** * Use `fetch()` to retrieve content from Umbraco Content Delivery API * Configure `appsettings.json` file to enable Content Delivery API and public access * Display fetched content in Astro components using `map()` and `json()` methods",
      "url": "/en/guides/cms/umbraco/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "cms",
        "umbraco",
        "astro"
      ],
      "type": "cms"
    },
    {
      "id": "reference/errors/response-sent-error",
      "language": "en",
      "title": "Unable to set response.",
      "summary": "**Astro components are unable to set response after it has been sent to the browser.** **Key features and APIs:** * `ResponseSentError` exception * Limited ability to modify response headers, cookies, and status code * Restrictions on making changes outside of page components **Implementation details and use cases:** * Making changes to response after it has been sent is not allowed * Use page components to modify response headers, cookies, and status code * Error handling and exception management for `ResponseSentError`",
      "url": "/en/reference/errors/response-sent-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "unable",
        "response."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/unhandled-rejection",
      "language": "en",
      "title": "Unhandled rejection",
      "summary": "**Unhandled Rejection Handling in Astro** Astro components are designed to catch and handle unhandled rejections from promises, ensuring robust error handling and preventing application crashes. Key features include: * Detection of unhandled rejections using Astro's built-in error handling mechanisms * Display of stack trace for debugging purposes * Recommended implementation of `await` or `.catch()` handlers for promises Implementation details involve integrating Astro's error handling with promise-based code, ensuring that all promises are properly handled to prevent unhandled rejections. Use cases include robust error handling in Astro components, ensuring seamless user experience and application stability.",
      "url": "/en/reference/errors/unhandled-rejection/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "unhandled",
        "rejection"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/unknown-clierror",
      "language": "en",
      "title": "Unknown CLI Error.",
      "summary": "**Astro CLI Error Handling** Astro CLI commands encounter unknown errors due to internal implementation issues, resulting in incomplete or misleading error messages. Key features affected include Astro's command-line interface (CLI) and error handling mechanisms. Implementation details involve Astro's internal error reporting and logging systems, which can be improved through issue reporting and debugging.",
      "url": "/en/reference/errors/unknown-clierror/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "unknown",
        "error."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/unknown-compiler-error",
      "language": "en",
      "title": "Unknown compiler error.",
      "summary": "**Astro Compiler Error Handling** Astro components are designed to handle unknown compiler errors, which can occur due to internal compiler issues. Key features include error detection, error reporting, and integration with the Astro issues list API. The `AstroCompilerError` object provides methods for accessing error details, such as `error.message` and `error.stack`, allowing developers to diagnose and report issues.",
      "url": "/en/reference/errors/unknown-compiler-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "unknown",
        "compiler",
        "error."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/unknown-config-error",
      "language": "en",
      "title": "Unknown configuration error.",
      "summary": "Astro configuration loader encounters unknown errors when loading configuration files, often due to syntax errors, and provides a message with additional information. The error can be resolved by reviewing the configuration file for syntax errors. Critical implementation details include Astro's configuration file loading mechanism and error handling.",
      "url": "/en/reference/errors/unknown-config-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "unknown",
        "configuration",
        "error."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/unknown-content-collection-error",
      "language": "en",
      "title": "Unknown Content Collection Error.",
      "summary": "**Astro Content Collection Error Handling** Astro components are designed to handle unknown content collection errors, which can occur due to errors in `src/content.config.ts` or internal errors. Key features include error detection via `Astro.props` and `getStaticPaths` method implementation. Implementation details involve outputting a `DontEditWarning` component to display the error message, with use cases including debugging and troubleshooting content collection issues.",
      "url": "/en/reference/errors/unknown-content-collection-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "unknown",
        "collection",
        "error."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/unknown-csserror",
      "language": "en",
      "title": "Unknown CSS Error.",
      "summary": "**Astro CSS Error Handling** Astro components are unable to parse CSS due to a syntax error, resulting in an unknown error. The error is typically caused by a syntax error in the CSS code, and the error message should contain more information. The `Astro.props` object is used to access the component's props, and the `getStaticPaths` method is not relevant to CSS error handling.",
      "url": "/en/reference/errors/unknown-csserror/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "unknown",
        "error."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/unknown-markdown-error",
      "language": "en",
      "title": "Unknown Markdown Error.",
      "summary": "Astro components are designed to handle Markdown parsing, but may encounter unknown errors due to syntax issues, which can be resolved by examining the error message for more information. Key features and APIs involved include Astro's Markdown parsing capabilities, error handling, and debugging tools such as error messages and console logs. Implementation details and use cases involve troubleshooting Markdown syntax errors, using Astro's built-in error handling mechanisms, and leveraging debugging tools to identify and resolve parsing issues.",
      "url": "/en/reference/errors/unknown-markdown-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "unknown",
        "markdown",
        "error."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/unknown-vite-error",
      "language": "en",
      "title": "Unknown Vite Error.",
      "summary": "**Vite Error Handling** Vite components are designed to handle unknown errors during rendering, providing a fallback component (`DontEditWarning`) to display when an error occurs. The `DontEditWarning` component is imported and rendered as a fallback, with a link to open an issue on the Astro project repository. This implementation utilizes Astro's component system and Vite's error handling capabilities, with a focus on troubleshooting and debugging.",
      "url": "/en/reference/errors/unknown-vite-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "unknown",
        "vite",
        "error."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/env-unsupported-get-secret",
      "language": "en",
      "title": "Unsupported astro:env getSecret",
      "summary": "**Astro environment variables are used to manage secrets and configuration.** The `astro:env/server` exported function `getSecret` is not supported by your adapter, resulting in an error. This function is used to retrieve environment variables, but its implementation is not compatible with your current adapter.",
      "url": "/en/reference/errors/env-unsupported-get-secret/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "unsupported",
        "astro:env",
        "getsecret"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/unsupported-image-conversion",
      "language": "en",
      "title": "Unsupported image conversion",
      "summary": "**Unsupported Image Conversion in Astro** Astro components do not currently support converting between vector (such as SVGs) and raster (such as PNGs and JPEGs) images, due to limitations in Astro's image processing capabilities. This is reflected in the absence of APIs or methods for image conversion, such as `getStaticPaths` or `Astro.props`. Implementation details and use cases for image conversion in Astro are not currently supported, and users are directed to the Images guide for further information.",
      "url": "/en/reference/errors/unsupported-image-conversion/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "unsupported",
        "image",
        "conversion"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/unsupported-image-format",
      "language": "en",
      "title": "Unsupported image format",
      "summary": "**UnsupportedImageFormat Error** UnsupportedImageFormat is an error that occurs when an unsupported image format is received from an image path. This error is triggered when the built-in image services do not support the image format, currently limited to `SUPPORTED_FORMATS.JOIN(', ')`. The error can be resolved by using an `img` tag directly for unsupported formats, such as GIFs, by importing the image and setting its `src`, `width`, and `height` attributes.",
      "url": "/en/reference/errors/unsupported-image-format/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "unsupported",
        "image",
        "format"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/unsupported-external-redirect",
      "language": "en",
      "title": "Unsupported or malformed URL.",
      "summary": "**UnsupportedExternalRedirect**: The destination URL in the external redirect from \"FROM\" to \"TO\" is unsupported. An external redirect must start with http or https, and must be a valid URL. This error occurs when the destination URL does not meet these requirements, and is typically resolved by validating the URL using the `Astro.redirect` API.",
      "url": "/en/reference/errors/unsupported-external-redirect/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "unsupported",
        "malformed",
        "url."
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/unsupported-config-transform-error",
      "language": "en",
      "title": "Unsupported transform in content config.",
      "summary": "**Unsupported transform in content config.** Astro components require `transform()` functions in content config to return valid JSON or data types compatible with the devalue library, including Dates, Maps, and Sets. This ensures compatibility with the devalue library, which is used for data serialization. The `transform()` function must return a valid JSON object or a compatible data type to prevent `UnsupportedConfigTransformError` and `PARSE_ERROR`.",
      "url": "/en/reference/errors/unsupported-config-transform-error/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "unsupported",
        "transform",
        "config."
      ],
      "type": "guide"
    },
    {
      "id": "upgrade-astro",
      "language": "en",
      "title": "Upgrade Astro",
      "summary": "**Upgrade Astro** Astro components are designed to be easily upgradable, with a robust versioning system and comprehensive documentation updates. Key features include: * `@astrojs/upgrade` command for one-click upgrades * `npm install`, `pnpm add`, and `yarn add` commands for manual upgrades * Access to Astro's changelog and upgrade guides for detailed change information Implementation details include: * Using package managers (npm, pnpm, yarn) to update Astro and integrations * Running `@astrojs/upgrade` command to upgrade Astro and official integrations together * Manual upgrades using `npm install`, `pnpm add`, and `yarn add` commands Use cases include: * Upgrading Astro to the latest version * Updating official integrations to their current versions * Accessing detailed change information through Astro's changelog and upgrade guides",
      "url": "/en/upgrade-astro/",
      "keywords": [
        "content",
        "docs",
        "upgrade",
        "astro"
      ],
      "type": "guide"
    },
    {
      "id": "guides/upgrade-to/v2",
      "language": "en",
      "title": "Upgrade to Astro v2",
      "summary": "**Upgrade to Astro v2** Astro components are designed to be highly customizable and extensible, with features like Astro.props, getStaticPaths, and Astro components integration. This guide provides a comprehensive upgrade path for migrating from Astro v1 to Astro v2, including implementation details and use cases for upgrading Astro and its integrations. Key APIs and methods include npm install, pnpm add, and yarn add for updating dependencies, as well as Astro v2.0 breaking changes and removal of Node 14 support.",
      "url": "/en/guides/upgrade-to/v2/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "upgrade to",
        "upgrade",
        "astro"
      ],
      "type": "guide"
    },
    {
      "id": "guides/upgrade-to/v3",
      "language": "en",
      "title": "Upgrade to Astro v3",
      "summary": "**Upgrade to Astro v3** Astro components are now upgraded to the latest version (v3.0) with improved features and APIs, including `getStaticPaths` and `Astro.props`. The upgrade process involves updating the project's version of Astro using a package manager, such as npm, pnpm, or yarn, and removing experimental flags from `astro.config.mjs`. This upgrade enables features like view transitions and persistent islands, which were previously available as experimental flags.",
      "url": "/en/guides/upgrade-to/v3/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "upgrade to",
        "upgrade",
        "astro"
      ],
      "type": "guide"
    },
    {
      "id": "guides/upgrade-to/v4",
      "language": "en",
      "title": "Upgrade to Astro v4",
      "summary": "**Upgrade to Astro v4** Astro components are upgraded to the latest version (v4.0) using package manager commands, such as `npx @astrojs/upgrade`, `pnpm dlx @astrojs/upgrade`, and `yarn dlx @astrojs/upgrade`, to update Astro and official integrations. The upgrade process includes potentially breaking changes and removal of deprecated features, requiring codebase updates for projects that don't work as expected.",
      "url": "/en/guides/upgrade-to/v4/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "upgrade to",
        "upgrade",
        "astro"
      ],
      "type": "guide"
    },
    {
      "id": "guides/upgrade-to/v5",
      "language": "en",
      "title": "Upgrade to Astro v5",
      "summary": "**Upgrade to Astro v5** Astro components are upgraded to v5.0, introducing breaking changes and feature removals. Key features and APIs include `@astrojs/upgrade` CLI, `npm`, `pnpm`, and `yarn` package manager integration, and manual integration upgrade options. Implementation details involve updating Astro and official integrations using `npx`, `pnpm dlx`, or `yarn dlx` commands, and potentially upgrading other dependencies. Use cases include upgrading from Astro v4 to v5, and addressing breaking changes and feature removals.",
      "url": "/en/guides/upgrade-to/v5/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "upgrade to",
        "upgrade",
        "astro"
      ],
      "type": "guide"
    },
    {
      "id": "guides/backend/index",
      "language": "en",
      "title": "Use a backend service with Astro",
      "summary": "**Astro components are designed to integrate with backend services, enabling features like authentication, storage, and data management.** **Key features and APIs include:** * `getStaticPaths` for server-side rendering and static site generation * `Astro.props` for accessing and manipulating component props * Integration with community-maintained backend services through the Astro integrations directory **Implementation details and use cases:** * Use backend services to manage databases, user authentication, and server-side functionality * Integrate popular features like user sign-ups, persistent data storage, and API generation * Leverage backend services for application monitoring, user-uploaded asset storage, and real-time communication",
      "url": "/en/guides/backend/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "backend",
        "service",
        "with",
        "astro"
      ],
      "type": "guide"
    },
    {
      "id": "guides/cms/index",
      "language": "en",
      "title": "Use a CMS with Astro",
      "summary": "**Astro components are designed to integrate with Content Management Systems (CMS) to fetch and display dynamic content.** **Key features include:** * Support for headless CMS integrations using JavaScript SDKs or CMS-provided integrations * Ability to fetch content data from a CMS using Astro's built-in APIs, such as `getStaticPaths` and `Astro.props` * Integration with popular CMSes like Storyblok, providing a seamless content management experience **Implementation details and use cases:** * Use a headless CMS to manage content outside of the Astro project, unlocking features like visual content editors and collaboration tools * Fetch content data from a CMS using Astro's APIs, enabling dynamic content rendering and updating * Choose a CMS that provides an Astro integration or JavaScript SDK for streamlined content management and display.",
      "url": "/en/guides/cms/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "with",
        "astro"
      ],
      "type": "guide"
    },
    {
      "id": "guides/media/index",
      "language": "en",
      "title": "Use a DAM with Astro",
      "summary": "**Astro components are designed to integrate with Digital Asset Managers (DAMs) to manage images and videos.** **Key features include:** * Integration with headless DAMs via APIs or SDKs * Support for hosted media systems like Cloudinary * Built-in image storage options * Use cases include managing assets across multiple web or mobile properties, and integrating with PIMs to connect assets to products. **Implementation details:** * Use community-maintained integrations for connecting a DAM or hosted media system * Fetch assets via API or SDK * Display assets on the website or app using Astro components **Technical keywords:** Digital Asset Manager, headless DAM, API, SDK, image storage, hosted media system, PIM, integration, Astro components.",
      "url": "/en/guides/media/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "media",
        "with",
        "astro"
      ],
      "type": "guide"
    },
    {
      "id": "recipes/bun",
      "language": "en",
      "title": "Use Bun with Astro",
      "summary": "**Astro components are integrated with Bun, an all-in-one JavaScript runtime & toolkit, enabling seamless development and deployment of Astro sites.** **Key features and APIs include:** * `bunx create-astro` command for creating new Astro projects with Bun * `bun install` command for installing dependencies * `@types/bun` package for runtime types * `astro add` command for using official Astro integrations * `--bun` CLI flag for running Astro commands with Bun's runtime **Implementation details and use cases include:** * Creating new Astro projects with Bun using `bunx create-astro` * Installing dependencies with `bun install` * Using official Astro integrations with `astro add` * Running Astro commands with Bun's runtime using `--bun` CLI flag",
      "url": "/en/recipes/bun/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "with",
        "astro"
      ],
      "type": "recipe"
    },
    {
      "id": "guides/fonts",
      "language": "en",
      "title": "Using custom fonts",
      "summary": "**Custom Fonts in Astro** Astro components allow for the use of custom fonts through the `@font-face` statement in CSS, enabling the registration of font families and their corresponding font files. The `font-family` value from the `@font-face` statement can be used to style elements in components or layouts. **Key Features and APIs** * `@font-face` statement for registering custom font families * `font-family` property for applying custom fonts to elements * Fontsource project for simplifying the use of Google Fonts and other open-source fonts **Implementation Details and Use Cases** * Add font files to `public/fonts/` directory * Use Fontsource project to install and use open-source fonts * Apply custom fonts to elements using the `font-family` property in CSS **Technical Keywords** * Custom fonts * `@font-face` statement * Fontsource * Google Fonts * Open-source fonts * Font registration * Font styling",
      "url": "/en/guides/fonts/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "using",
        "custom",
        "fonts"
      ],
      "type": "guide"
    },
    {
      "id": "guides/environment-variables",
      "language": "en",
      "title": "Using environment variables",
      "summary": "**Astro Environment Variables** Astro provides access to Vite's built-in environment variables support and includes default environment variables for project configuration. Environment variables can be used and organized with type safety, available for use inside Astro context, and managed with a schema in the Astro configuration. Environment variables are statically replaced at build time and can be accessed using `import.meta.env` methods, with some variables available only in server-side code for security purposes.",
      "url": "/en/guides/environment-variables/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "using",
        "environment",
        "variables"
      ],
      "type": "guide"
    },
    {
      "id": "recipes/streaming-improve-page-performance",
      "language": "en",
      "title": "Using streaming to improve page performance",
      "summary": "**Astro components are optimized for streaming to improve page performance by sending components to the browser as they become available.** **Key features include:** * HTML streaming for faster page loading * Ability to move data fetches to smaller components to avoid blocking page rendering * Use of `await` calls in smaller components to take advantage of Astro's streaming **Implementation details and use cases:** * Refactoring example demonstrates how to move fetch calls to other components to optimize loading * Using smaller components to perform data fetches allows Astro to render HTML sooner * Streaming enables faster page loading and improved user experience",
      "url": "/en/recipes/streaming-improve-page-performance/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "using",
        "streaming",
        "improve",
        "page"
      ],
      "type": "recipe"
    },
    {
      "id": "reference/errors/locals-not-an-object",
      "language": "en",
      "title": "Value assigned to locals is not accepted.",
      "summary": "**Astro middleware defines are restricted to object assignments.** Astro middleware defines restrict the value assigned to `context.locals` to an object, throwing `LocalsNotAnObject` when attempting to assign a non-object value such as numbers, strings, etc. The `defineMiddleware` function expects an object as the second argument, which is assigned to `context.locals`. For example, `context.locals = 1541;` will throw `LocalsNotAnObject`.",
      "url": "/en/reference/errors/locals-not-an-object/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "value",
        "assigned",
        "locals",
        "accepted."
      ],
      "type": "guide"
    },
    {
      "id": "recipes/captcha",
      "language": "en",
      "title": "Verify a Captcha",
      "summary": "**Verify a Captcha** Astro components are used to create an API route and fetch it from the client to verify Google reCAPTCHA v3 without exposing the secret to clients. **Key Features and APIs** * `POST` endpoint to accept recaptcha data and verify it with reCAPTCHA's API * `fetch` API to access the endpoint from a client script * `URLSearchParams` to construct the request body * `Response` object to return the verification result **Implementation Details and Use Cases** This recipe requires a project with Server-Side Rendering (SSR) enabled and uses environment variables to store sensitive data. It demonstrates how to create a REST API endpoint to run functions like authentication and verification without exposing sensitive data to the client.",
      "url": "/en/recipes/captcha/",
      "keywords": [
        "content",
        "docs",
        "recipes",
        "recipe",
        "verify",
        "captcha"
      ],
      "type": "recipe"
    },
    {
      "id": "guides/view-transitions",
      "language": "en",
      "title": "View transitions",
      "summary": "**View Transitions** Astro components enable seamless navigation between pages with view transitions, a popular design choice for preserving visual continuity. View transitions are powered by the View Transitions browser API and include built-in animation options, customizable animations, and support for forwards and backwards navigation animations. **Key Features and APIs** * Built-in animation options: `fade`, `slide`, and `none` * Customizable animations with full control over transition animation * Support for forwards and backwards navigation animations * Ability to carry HTML elements from the current page to the next during navigation * Option to prevent client-side navigation for non-page links * Control over fallback behavior for browsers without View Transition API support * Automatic support for `prefers-reduced-motion`",
      "url": "/en/guides/view-transitions/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "view",
        "transitions"
      ],
      "type": "guide"
    },
    {
      "id": "reference/modules/astro-transitions",
      "language": "en",
      "title": "View Transitions Router API Reference",
      "summary": "**View Transitions Router API Reference** Astro components are designed to control and interact with the View Transitions API and client-side router, providing features for routing, animation customization, and transition directives. **Key Features and APIs:** * ``: Opt-in to view transitions on individual pages by importing and adding the routing component to ``. * `fade` and `slide`: Utility functions for customizing the duration of built-in animations, returning `TransitionDirectionalAnimations`. * `getStaticPaths` and `Astro.props`: APIs for interacting with the client-side router and view transitions. **Implementation Details and Use Cases:** * Control the router and add transition directives to page elements and components. * Customize animation durations using `fade` and `slide` utility functions. * Use `` to enable view transitions on individual pages.",
      "url": "/en/reference/modules/astro-transitions/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "modules",
        "view",
        "transitions",
        "router"
      ],
      "type": "guide"
    },
    {
      "id": "concepts/why-astro",
      "language": "en",
      "title": "Why Astro?",
      "summary": "**Astro is a web framework for building content-driven websites like blogs, marketing, and e-commerce, pioneering a new frontend architecture to reduce JavaScript overhead and complexity.** **Key Features:** * Islands: A component-based web architecture optimized for content-driven websites * UI-agnostic: Supports React, Preact, Svelte, Vue, Solid, HTMX, web components, and more * Server-first: Moves expensive rendering off of visitors' devices * Zero JS, by default: Less client-side JavaScript to slow down the site * Content collections: Organize, validate, and provide TypeScript type-safety for Markdown content * Customizable: Partytown, MDX, and hundreds of integrations to choose from **Implementation Details:** * Astro includes everything needed to create a website, with built-in integrations and API hooks for customization * Supports server-first rendering, reducing JavaScript overhead and complexity * Optimized for content-driven websites, with features like content collections and UI-agnostic support",
      "url": "/en/concepts/why-astro/",
      "keywords": [
        "content",
        "docs",
        "concepts",
        "astro?"
      ],
      "type": "guide"
    },
    {
      "id": "tutorial/1-setup/3",
      "language": "en",
      "title": "Write your first line of Astro",
      "summary": "**Astro components are a set of reusable UI elements for building web applications, featuring internationalization support and integration with Astro's Starlight components.** **Key features include:** * Importing Astro components using `import` statements (e.g., `Checklist`, `Box`, `InstallGuideTabGroup`) * Using Astro's `Steps` component for guided tutorials and instructions * Accessing Astro's `Astro.props` object for metadata and configuration * Utilizing Astro's `getStaticPaths` API for server-side rendering and SEO optimization **Implementation details and use cases:** * Creating a new Astro project and editing the `index.astro` file to update page content * Using Astro's `Steps` component to guide users through a tutorial or instructional process * Integrating Astro components with other libraries and frameworks, such as `@astrojs/starlight/components`",
      "url": "/en/tutorial/1-setup/3/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "1 setup",
        "write",
        "your",
        "first",
        "line"
      ],
      "type": "tutorial"
    },
    {
      "id": "tutorial/2-pages/2",
      "language": "en",
      "title": "Write your first Markdown blog post",
      "summary": "**Astro components are used to create interactive blog posts with Markdown content.** **Key features include:** * Importing Astro components (e.g., Checklist, Blanks, Box, MultipleChoice, Option, PreCheck, Badge) and Starlight components (e.g., Steps) * Using Markdown syntax in `.md` files for blog post content * Utilizing Astro's built-in features for internationalization and metadata (e.g., title, pubDate, description, author, image, tags) **Implementation details and use cases:** * Creating a new directory for blog posts and adding a new `.md` file * Writing Markdown content with metadata and formatting (e.g., headings, lists) * Using Astro's preview feature to test and troubleshoot blog posts * Linking to blog posts on the Blog page",
      "url": "/en/tutorial/2-pages/2/",
      "keywords": [
        "content",
        "docs",
        "tutorial",
        "2 pages",
        "write",
        "your",
        "first",
        "markdown"
      ],
      "type": "tutorial"
    },
    {
      "id": "guides/backend/xata",
      "language": "en",
      "title": "Xata & Astro",
      "summary": "**Xata & Astro: Serverless Database Integration** Astro components are integrated with Xata, a serverless data platform, to provide a full-text search and analytics engine with a single consistent REST API. **Key Features and APIs:** * `XATA_API_KEY` and `databaseURL` environment variables are configured and used by the Xata SDK instance. * `@xata.io/client` is added to the `package.json` file. * `xata.ts` file is generated with types tailored to the database schema. * IntelliSense and type safety are enabled for environment variables using `env.d.ts` file. **Implementation Details and Use Cases:** * Xata CLI is used to generate the SDK instance and configure environment variables. * Database URL and API key are automatically pulled by the SDK instance. * Project structure is updated to include the `xata.ts` file and `@xata.io/client` in `package.json`.",
      "url": "/en/guides/backend/xata/",
      "keywords": [
        "content",
        "docs",
        "guides",
        "backend",
        "xata",
        "astro"
      ],
      "type": "backend"
    },
    {
      "id": "reference/errors/invalid-rewrite404",
      "language": "en",
      "title": "You attempted to rewrite a 404 inside a static page, and this isnt allowed.",
      "summary": "**InvalidRewrite404**: Rewriting a 404 is only allowed inside on-demand pages. **Purpose/Function**: Prevent rewriting 404 pages in static pages. **Features/APIs/Methods**: `InvalidRewrite404` error, `on-demand pages`, `static pages`. **Implementation Details**: This error occurs when attempting to rewrite a 404 page inside a static page, which is not allowed. **Use Cases**: Upgrading to a recent Astro version to resolve the issue, consulting unmaintained documentation for older versions.",
      "url": "/en/reference/errors/invalid-rewrite404/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "attempted",
        "rewrite",
        "inside",
        "static"
      ],
      "type": "guide"
    },
    {
      "id": "reference/errors/incorrect-strategy-for-i18n",
      "language": "en",
      "title": "You cant use the current function with the current strategy",
      "summary": "Astro components are restricted by the `i18n.routing.strategy` configuration setting, which must be set to `\"manual\"` to use certain internationalization functions. The `IncorrectStrategyForI18n` error occurs when using functions like `Astro.props` or `getStaticPaths` with `i18n.routing.strategy` set to a value other than `\"manual\"`. This limitation is due to the interaction between Astro's i18n routing and the underlying internationalization functionality.",
      "url": "/en/reference/errors/incorrect-strategy-for-i18n/",
      "keywords": [
        "content",
        "docs",
        "reference",
        "errors",
        "cant",
        "current",
        "function",
        "with"
      ],
      "type": "guide"
    }
  ]
}